---
title: "长宽转换"
---

## 简介

主要介绍使用`pivot_longer`和`pivot_wider`进行长宽数据转换，这两个函数都是来自于`tidyr`包，是`gather`和`spread`的升级，比原函数功能更加强大，且参数更加清晰直观好记。

## 加载R包

```{r}
library(tidyr)
library(dplyr)
library(readr)
```

## 宽变长

宽数据变为长数据，宽数据通常是直接输入的原始数据，宽数据方便录入原始资料，但是不便于数据分析。因此在分析时需要变为长数据。

### 列名是字符型数据

这是一个宽数据，是一个关于不同季节和宗教信仰的人们的收入数据。

```{r}
relig_income
```

这个数据包含3个变量：

- `religion`：宗教
- `income`：分布在不同的列名中
- `count`：单元格中的数字

我们使用`pivot_longer`把它变为长数据，这是一个最简单的宽数据变长数据的示例：

```{r}
relig_income %>% 
  pivot_longer(cols = !religion, 
               names_to = "income",
               values_to = "count")
```

- `pivot_longer`的第一个参数是数据集，这里是`relig_income`，已省略，
- 第二个参数是哪些列需要变形，在这里是除了`religion`的所有列，
- 第三个参数是需要创建的列名，用来存放数据集中原有的列名，这里是`income`，
- 第四个参数是需要创建的用来存放值的列名，这里是`count`

新创建的两列`income`和`count`都不是原来数据集有的，因此需要加引号。


### 列名是数值型数据

使用`billboard`数据集，列名中含有数字，而不是纯字符。

```{r}
billboard
```

现在我们需要把不同的周放在一列中，因为它其实是一个变量，然后不同的周下面的值也放在一列中，同时我们发现周下面的数字有一些缺失值，我们想丢掉含有这些缺失值的行。

```{r}
billboard %>% 
  pivot_longer(cols = starts_with("wk"),
               names_to = "week",
               values_to = "rank",
               values_drop_na = T
               )
```

假如我们想知道每首歌在表单上待了几周，我们可以把`week`这一列变为数值型，这需要另外的参数`names_prefix/names_transform`。

```{r}
billboard %>% 
  pivot_longer(
    cols = starts_with("wk"),
    names_to = "week",
    values_to = "rank",
    values_drop_na = T,
    names_prefix = "wk", # 数字前面的前缀是什么
    names_transform = list(week = as.integer) # 对新建的week做什么操作
  )
```

或者你可以直接使用`readr`包中的`parse_number()`函数直接解析`week`这一列。

```{r}
billboard %>% 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    names_transform = list(week = readr::parse_number), # 对新建的week这一列解析
    values_to = "rank",
    values_drop_na = TRUE,
  )
```

### 列名中含有多个变量

在整洁数据的概念中，每一列都应该是一个变量，假如在列名中含有多个变量，那么我们就需要把这些列名变为不同的列，以`who`数据集为例。

```{r}
who
```

从`new_sp_mo14`到`newrel_f65`这几列的列名都包含了4个变量：

- `new/new_`代表了一个变量，但是所有的都是`new`，暂且不管，
- `sp/rel/ep`也是一个变量，代表是如何被诊断的，
- `m/f`是性别，也是一个变量，
- `014/1524/2535/3544/4554/65`代表年龄范围，也是一个变量。

也就是说这些列应该被重组为4列，可以使用正则表达式提取这些列的规律，然后进行重组，这里只分了3列：

```{r}
who %>% pivot_longer(
  cols = new_sp_m014:newrel_f65,
  names_to = c("diagnosis","gender","age"), # new那一列没写，因为都一样
  names_pattern = "new_?(.*)_(.)(.*)", # 正则表达式3个括号对应上面3个列名
  values_to = "count"
)
```

假如我们知道自己的数据情况，比如这个数据，`gender`这一列和`age`这一列，可以变为因子型，这样方便后面的分析：

```{r}
who %>% pivot_longer(
  cols = new_sp_m014:newrel_f65,
  names_to = c("diagnosis", "gender", "age"), 
  names_pattern = "new_?(.*)_(.)(.*)",
  names_transform = list(
    gender = ~ readr::parse_factor(.x, levels = c("f", "m")),
    age = ~ readr::parse_factor(
      .x,
      levels = c("014", "1524", "2534", "3544", "4554", "5564", "65"), 
      ordered = TRUE
    )
  ),
  values_to = "count",
)
```

### 每一行有多个观测

在整洁数据中，每行一个观测，每列一个变量。

有时一行会有多个观测，你想创建的新列的名字是原数据列名的一部分。

```{r}
family <- tribble(
  ~family,  ~dob_child1,  ~dob_child2, ~gender_child1, ~gender_child2,
       1L, "1998-11-26", "2000-01-29",             1L,             2L,
       2L, "1996-06-22",           NA,             2L,             NA,
       3L, "2002-07-11", "2004-04-05",             2L,             2L,
       4L, "2004-10-10", "2009-08-27",             1L,             1L,
       5L, "2000-12-05", "2005-02-28",             2L,             1L,
)
family <- family %>% mutate_at(vars(starts_with("dob")), parse_date)
family
```

在这个数据集中，每一行有2个孩子的信息，每个孩子都有性别和生日两个信息（或者两个值，value）。我们应该把chid变为一列，gender变为一列，dob变为一列。

`.value`参数告诉`pivot_longer`：列名的一部分是要用的，会变成输出数据的一个变量。

```{r}
family %>% pivot_longer(
  cols = !family,
  names_to = c(".value","child"), # 列名中其他部分要用的
  names_sep = "_", # 列名中的分隔符
  values_drop_na = T
)
```


在另一个`anscombe`数据集中也存在同样的问题：

```{r}
anscombe
```

这个数据集有4对变量（x1和y1，x2和y2，x3和y3,x4和y4）:

```{r}
anscombe %>% 
  pivot_longer(
    cols = everything(),
    names_to = c(".value","set"), # 列名中x,y要用的
    names_pattern = "(.)(.)"
  ) %>% 
  arrange(set)
```


接下来再介绍一个数据集也是这样的情况，帮助大家理解：

```{r}
pnl <- tibble(
  x = 1:4,
  a = c(1, 1,0, 0),
  b = c(0, 1, 1, 1),
  y1 = rnorm(4),
  y2 = rnorm(4),
  z1 = rep(3, 4),
  z2 = rep(-2, 4),
)

pnl
```

接下来变为长数据：

```{r}
pnl %>% 
  pivot_longer(
    !c(x, a, b), 
    names_to = c(".value", "time"), # y和z是要用的，其他变为time
    names_pattern = "(.)(.)"
  )
```


### 列名有重复

比如下面这个数据集，列名是有重复的：

```{r}
df <- tibble(id = 1:3, y = 4:6, y = 5:7, y = 7:9, .name_repair = "minimal")
df
```

`pivot_longer`处理这种数据时，会自动添加新列：

```{r}
df %>% 
  pivot_longer(
    cols = !id,
    names_to = "name",
    values_to = "value"
  )
```


假如多个输入数据的列名会变成输出数据的一列，也是这样的情况：

```{r}
df <- tibble(id = 1:3, x1 = 4:6, x2 = 5:7, y1 = 7:9, y2 = 10:12)
df
```

这个数据集也是有2对的，可以按照上面的思路写

```{r}
df %>% pivot_longer(!id, names_to = ".value", names_pattern = "(.).")
```

当然也可以按照每一行有多个观测的数据集的思路写：

```{r}
df %>% pivot_longer(!id, names_to = c(".value","group"), names_pattern = "(.)(.)")
```


以上就是宽数据变长数据的常见情况，基本涵盖了日常数据，下面讲解长数据变成宽数据的例子。

## 长变宽

`pivot_wider`是`pivot_longer`的反向操作，把长数据变为宽数据。宽数据一般不常用，但是在总结图表或者导入其他软件使用时很有用。

尤其是在做中药处方数据挖掘方面，非常有用！

### capture-recapture data

使用`fish_encounters`数据集，这个数据记录了鱼游到水边会不会被检测到。

这个数据集非常实用，如果你做中医药处方数据挖掘相关工作，那么学会这个例子中的方法基本就是解决了大部分问题！

```{r}
fish_encounters
```

许多分析都需要每一个工作站(station)是一列：

```{r}
fish_encounters %>% 
  pivot_wider(
    names_from = station,
    values_from = seen
  )
```

这个数据集记录的是鱼是否被检测到，如果检测到就是1，所有你会发现长数据变为宽数据后出现了很多`NA`，但其实这些`NA`代表的是没被检测到。

对于这种数据，我们可以通过添加参数解决，把`NA`变成0:

```{r}
fish_encounters %>% pivot_wider(
  names_from = station,
  values_from = seen,
  values_fill = 0 # 自动填充0
)
```

这样就很清楚了，1代表被检测到，0代表没被检测到。

这个数据也是中药处方数据挖掘中常用的频率矩阵。

### 汇总功能

`pivot_wider`支持简单的汇总功能，以下面的`warpbreaks`数据集为例，这是每个样本都有9个重复的实验设计：

```{r}
warpbreaks <- warpbreaks %>% as_tibble() %>% 
  select(wool, tension, breaks)

warpbreaks
```

```{r}
warpbreaks %>% count(wool, tension)
```

假如我们想把`tension`这一列变为多列，会发生问题：

```{r}
warpbreaks %>% pivot_wider(
  names_from = wool,
  values_from = breaks
)
```

这段提示告诉我们：输出数据中一个单元格的值包含了多个输入数据的单元格值，上面的这个数据`wool`和`tension`这两列，`A`和`L`对应的`breaks`的值有多个，这样得到的结果每个单元格中是一个列表。可以通过传递一个函数解决：

```{r}
warpbreaks %>% 
  pivot_wider(
    names_from = wool,
    values_from = breaks,
    values_fn = list(breaks = mean)
  )
```

这样我们就得到了平均值，对于简答的汇总操作可以使用`pivot_wider`，但是对于复杂的操作还是建议先汇总再进行长宽转换。

长数据转换为宽数据就是需要每一行都有唯一标识符，不然就会有问题，如果不想汇总，也可以为每个观测添加唯一的标识符，然后再转换：

```{r}
warpbreaks %>% 
  mutate(row_id = row_number()) %>% 
  pivot_wider(
    names_from = wool,
    values_from = tension
  )
```

### 从多个变量中生成列名

假如我们有一个数据集包含产品、国家、年，以tidy形式储存：

```{r}
production <- expand.grid(
  product = c("A","B"),
  country = c("AI","EI"),
  year = 2000:2014
) %>% 
  filter((product == "A" & country == "AI") | product == "B") %>% 
  mutate(production = rnorm(nrow(.)))

production
```

想在我们想把这个数据集变成宽数据，其中一列包含`product`和`country`两列的信息，我们该怎么办呢？

```{r}
production %>% pivot_wider(
  names_from = c(product, country), # 直接放一起即可
  values_from = production
)
```

可以通过多个参数控制输出数据的列名：

```{r}
production %>% pivot_wider(
  names_from = c(product, country),
  values_from = production,
  names_sep = ".",       # 连接符
  names_prefix = "prod." # 前缀
)
```

也可以通过`names_glue`函数：

```{r}
production %>% pivot_wider(
  names_from = c(product, country),
  values_from = production,
  names_glue = "prod_{product}_{country}" # glue函数很好用
)
```


### 整洁的数据

以`us_rent_income`数据集为例，这个数据集是关于美国2017年每个州的收入和租金。

```{r}
us_rent_income
```

可以看到`estimate`和`moe`是值，我们可以把它们用作`values_from`的参数：

```{r}
us_rent_income %>% 
  pivot_wider(
    names_from = variable,
    values_from = c(estimate, moe),
    names_sep = "."
  )
```

函数会自动帮我们把列名连到一起，非常方便。


### 隐式缺失值

有时我们会遇到因子型数据，但不是所有的水平都有相应的值，例如下面这个数据：

```{r}
weekdays <- c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")

daily <- tibble(
  day = factor(c("Tue", "Thu", "Fri", "Mon"), levels = weekdays),
  value = c(2, 3, 1, 5)
)

daily
```

可以看到`day`是因子型，且有7个水平，但不是所有的水平都显示出来了，假如我们想要都显示出来，也可以办到：

```{r}
daily %>% pivot_wider(
  names_from = day,
  values_from = value,
  names_expand = T # 所有水平都显示出来
)
```

假如`names_from`含有多列，那么函数会自动组合所有可能：

```{r}
percentages <- tibble(
  year = c(2018, 2019, 2020, 2020),
  type = factor(c("A", "B", "A", "B"), levels = c("A", "B")),
  percentage = c(100, 100, 40, 60)
)

percentages
```


接下来变为宽数据：

```{r}
pivot_wider(
  percentages,
  names_from = c(year, type), # 多列
  values_from = percentage,
  names_expand = TRUE, # 自动给出所有组合
  values_fill = 0 # 没有的填充0
)
```

上面这种情况是`names`含有因子型，另一种相似的情况是`id_cols`（可以简单理解为能够区分不同行数据的唯一标识符列）含有隐式缺失值（因子型），这种情况下需要用`id_expand`。

```{r}
daily <- daily %>% mutate(type = factor(c("A","B","B","A")))
daily
```

接下来变为宽数据：

```{r}
daily %>% 
  pivot_wider(
    names_from = type,
    values_from = value,
    id_expand = T
  )
```

但是其实不用也是不会报错的：

```{r}
daily %>% 
  pivot_wider(
    names_from = type,
    values_from = value
  )
```


### 没用的列

有些数据中的某一列对于长宽转换是没用的，但是这一列你又不想丢掉，这种情况可以使用`unused_fn`搞定。

```{r}
updates <- tibble(
  county = c("Wake", "Wake", "Wake", "Guilford", "Guilford"),
  date = c(as.Date("2020-01-01") + 0:2, as.Date("2020-01-03") + 0:1),
  system = c("A", "B", "C", "A", "C"),
  value = c(3.2, 4, 5.5, 2, 1.2)
)

updates
```


现在我们想把`system`这一列进行转换：

```{r}
updates %>% 
  pivot_wider(
    names_from = system,
    values_from = value,
    id_cols = county
  )
```

这样虽然不会报错，但是`date`那一列的信息就完全丢失了。

我们可以通过使用`unused_fn`进行调整，比如我们可以通过函数保留最新的日期：

```{r}
updates %>% 
  pivot_wider(
    id_cols = county,
    names_from = system,
    values_from = value,
    unused_fn = list(date = max)
  )
```

这样就保留了最新的日期。

也可以直接把`date`列变为列表形式保存下来：

```{r}
updates %>% 
  pivot_wider(
    id_cols = county,
    names_from = system,
    values_from = value,
    unused_fn = list(date = list) # 神奇的操作！
  )
```


### 通讯录数据

假如我们有一个下面这样的通讯录数据：

```{r}
contacts <- tribble(
  ~field, ~value,
  "name", "Jiena McLellan",
  "company", "Toyota", 
  "name", "John Smith", 
  "company", "google", 
  "email", "john@google.com",
  "name", "Huxley Ratcliffe"
)

contacts
```

这个数据没有任何一列能够区分每一行怎么分组。

我们可以创建一个新列，每当`field`这一列出现`name`时，就加一。

```{r}
contacts <- contacts %>% 
  mutate(
    person_id = cumsum(field == "name")
  )
contacts
```

这样操作以后每个人就都有了唯一的标识符。这样就可以把`field`和`value`这两列进行`pivot`了。

```{r}
contacts %>% 
  pivot_wider(
    names_from = field,
    values_from = value
  )
```


## 先变长再变宽

有些数据单纯的一次变宽或变长是不能解决的，需要联合使用`pivot_longer`和`pivot_wider`。

使用`world_bank_pop`数据集演示，这个数据集是2000年到2017年的每个国家的人口数据。

```{r}
world_bank_pop
```

首先这个数据很明显不是整洁数据，所以我们先把它变成整洁数据：

```{r}
pop2 <- world_bank_pop %>% 
  pivot_longer(
    cols = "2000":"2017", # 因为是字符型需要加引号
    names_to = "year",
    values_to = "value"
  )

pop2
```

接下来看看`indicator`这一列：

```{r}
pop2 %>% count(indicator)
```

这里`SP.POP.GROW`是人口增长量，`SP.POP.TOTL`是人口总量，`SP.URB*`也是一样的，不过是城市人口。很明显这一列包含了多个信息，下面我们把这一列拆分为多列：

```{r}
pop3 <- pop2 %>% 
  separate(indicator, 
           c(NA,"area","variable"),
           sep = "\\."
           )

pop3
```

这样一个数据还不是很直观，我们可以把`variable`这一列“变宽”：

```{r}
pop3 %>% 
  pivot_wider(
    names_from = variable,
    values_from = value
  )
```

这样的数据看起来是不是更加一目了然呢？

### 问卷调查数据

在临床中常用到问卷调查，每一个问题都有1个或多个选择（比如ABCD）等，这样的数据都会变得非常宽，类似这样：

```{r}
multi <- tribble(
  ~id, ~q1, ~q2, ~q3,
  1, "A", "B", "C",
  2, "C", "B",  NA,
  3, "D",  NA,  NA,
  4, "B", "D",  NA
)

multi
```

这样的数据`id`就是id，没啥实际意义，`q1/q2/q3`代表不同的问题，比如上面的数据表示第一个问题选择了ABCD四个选项。

现在我们想把ABCD变成单独的4列，然后每一个问题是一行，有没有选择用TRUE和FALSE表示。

可以通过2步实现：

```{r}
multi2 <- multi %>% 
  pivot_longer(
  cols = !id,
  names_to = "choice", # 这种情况下这个和下面那个参数可以省略
  values_to = "value", # 可省略
  values_drop_na = T
  ) %>% 
  mutate(checked = TRUE)

multi2
```

接下来再变成宽数据，并且把缺失值用FALSE代表：

```{r}
multi2 %>% 
  pivot_wider(
    id_cols = id,
    names_from = value,
    values_from = checked,
    values_fill = FALSE
  )
```

这样就达到目的了，每一行是一个问题，列是不同的选项，如果选了就是TRUE，如果没选就是FALSE，很好看。


## 手动操作

长宽数据转换通过之前的示例讲解，基本覆盖了大多数情况，但是复杂的日常生活总是有很多意想不到的场景需求。因此作者开发了更为强大和自由的手动操作过程。

基本理念就是先创建一个类似**模板**的东西，然后根据这个**模板**进行转换。

### 变长

还是以`relig_income`这个数据集为例。

```{r}
relig_income
```


现在我们像把这个数据变为长数据，我们可以先建立一个**模板**，语法并没有什么不同：

```{r}
spec <- relig_income %>% 
  build_longer_spec(
    cols = !religion, 
    names_to = "income",
    values_to = "count"
    ) # 建立模板

spec
```

可以看到多了`.name`和`.value`列，这就是模板的作用，可以用在接下来的转换中。

```{r}
# 使用模板进行转换
pivot_longer_spec(relig_income, spec)
```

上面的2步其实和正常的1步效果一样，只是为了演示模板的基础用法，在实际情况中大家可以自己设定更为精确的模板。

```{r}
relig_income %>% 
  pivot_longer(
    cols = !religion,
    names_to = "income",
    values_to = "count"
  )
```

### 变宽

```{r}
us_rent_income
```

```{r}
# 简单的变宽
us_rent_income %>% 
  pivot_wider(
    names_from = variable,
    values_from = c(estimate, moe)
  )
```


现在你不太喜欢这个列名，你想要`income_moe/rent_moe`这样的列名，这可以通过创建模板来实现。

```{r}
# 创建模板
spec1 <- us_rent_income %>% 
  build_wider_spec(names_from = variable, values_from = c(estimate, moe))
spec1
```

可以发现这个原始模板不是我们想要的，稍作修改：

```{r}
spec2 <- spec1 %>% 
  mutate(.name = paste0(variable, ifelse(.value == "moe", "_moe", "")))

spec2
```

现在列名终于是我们想要的了，接下来就可以以此为模板进行转换了。

```{r}
us_rent_income %>% 
  pivot_wider_spec(spec = spec2)
```

非常成功！


### 完全手动操作

有时候通过函数生成模板比较困难，还不如直接纯手动构建！

```{r}
construction
```

纯手动构建模板：

```{r}
spec <- tribble(
  ~.name,            ~.value, ~units,  ~region,     
  "1 unit",          "n",     "1",     NA,          
  "2 to 4 units",    "n",     "2-4",   NA,          
  "5 units or more", "n",     "5+",    NA,          
  "Northeast",       "n",     NA,      "Northeast", 
  "Midwest",         "n",     NA,      "Midwest",   
  "South",           "n",     NA,      "South",     
  "West",            "n",     NA,      "West",      
)
```


我们想要把上面这个数据集变长，下面就可以用模板了。

进行转换：

```{r}
pivot_longer_spec(construction, spec)
```

### 理念

使用`spec`（模板）进行长宽转换是完全镜像的操作，只要用同一个`spec`，结果是完全可以回复的。

```{r}
# 和原数据一模一样
construction %>% 
  pivot_longer_spec(spec) %>% 
  pivot_wider_spec(spec)
```


使用模板可以帮我们精确控制数据转换的过程，在宽数据变为长数据后，将会有：nrow(df) * nrow(spec) rows, and ncol(df) - nrow(spec) + ncol(spec) - 2 列。
