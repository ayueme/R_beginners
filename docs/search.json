[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R语言零基础入门",
    "section": "",
    "text": "前言",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "index.html#r语言在医学中的应用",
    "href": "index.html#r语言在医学中的应用",
    "title": "R语言零基础入门",
    "section": "R语言在医学中的应用",
    "text": "R语言在医学中的应用\n很多初学者可能并不知道R语言在医学中有什么用，我先简单介绍一下。R语言在医学中的使用非常广泛，涉及方方面面！\n首先肯定是医学统计分析，R语言就是统计学家开发的，相比于SPSS、SAS、Stata等软件，R语言的统计分析功能更加强大，一些新的统计方法也会首先使用R语言实现。对于一些复杂的meta分析等方法，目前也只有R语言才能实现。\n其次是R语言在生信数据分析中应用广泛，经久不衰的生信数据挖掘也一直是医学生发文的热点方向之一。各种常见的生信下游分析（比如：差异分析、富集分析、生存分析、免疫相关分析、单细胞分析等）都是在R语言中实现的，各大生信数据库（比:TCGA、GEO、ICGC、CCLE等）挖掘也是以R语言为主。\n第3是R语言在临床预测模型和机器学习方面的应用。临床预测模型也一直是发文的热点之一，目前多数临床预测模型相关的文章都是以R语言为主，除了传统的3大回归模型（线性回归、逻辑回归、COX回归）外，各种机器学习方法的使用也越来越频繁，这些都可以使用R语言实现。而且R语言在机器学习领域也越来越强大、易用。\n第4是R语言在孟德尔随机化中的应用，孟德尔随机化曾是发文的爆点，各种MR分析方法都是以MR为主，R语言可以实现全套的MR分析。\n第5是R语言在各大医学数据库挖掘中的使用，比如近几年非常火热的nhanes、GBD、CHARLS、FAERS、MIMIC、eICU等，它们的分析需要使用R语言。传统的EXCEL和SPSS无法实现这些复杂的分析。\n第5是R语言的绘图功能强大，常见的统计图表（条形图、折线图、散点图、直方图、箱线图、小提琴图等）轻松拿捏，各种常见的医学三线表轻松绘制，亚组分析和森林图等1行代码实现；各种生信常见图形也是不在话下，比如热图、网络图等；各种地图也是手到擒来。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "index.html#为什么要写这个合集",
    "href": "index.html#为什么要写这个合集",
    "title": "R语言零基础入门",
    "section": "为什么要写这个合集",
    "text": "为什么要写这个合集\n公众号一直免费分享各种R语言教程，主要是面向医学生/医生或者公卫、流统、统计等群体，但是这部分人是没有任何编程基础的，即使写的已经非常通俗简单了（甚至有朋友觉得太啰嗦），但还是有很多人跟着公众号的教程自己做不出来，并且有很多朋友一直问有没有相关的视频教程，之前是没有的，现在有了！这个教程就是专门为编程零基础的医学生/医生准备的。\n我在学习R语言的时候，走了很多弯路，我把其中的一些注意点写出来，让大家少走点弯路。\n我认为《R语言是实战》是最适合医学生入门R语言的书籍，没有之一。但是由于书的作者是老外，所以这本书的开头部分和中国的特殊情况不太合适，比如它没有告诉我们大陆地区安装R包需要更改镜像，所以你一上来就遇到最大的难题：R包安装……并且有相当一部分医学生学习R语言是为了分析生信数据，然而这部分R包的安装又与默认方法不同……我太明白R包安装失败的痛苦了，刚学的时候啥也不懂，经常就困在安装R包上几个小时甚至几天！\n另外就是有一些概念比较晦涩难懂，这对于没有任何计算机背景的医学生/医生来说是非常难解决的问题，尤其是刚开始接触R的时候，报错了也不知道怎么解决，或者找不到合适的解决方案，非常煎熬。又或者是你在相关的交流群问别人，可能出现“别人看不懂你的问题”或者“别人的回答你看不懂”，无效交流。\n有一个非常著名的悖论就是：当你学会某项技能或知识时，你就会忘记你不会的时候是什么样子。我会尽量做到从初学者的角度进行讲解，虽然我也已经忘记我不会的时候是什么样子……",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "index.html#内容简介",
    "href": "index.html#内容简介",
    "title": "R语言零基础入门",
    "section": "内容简介",
    "text": "内容简介\n本合集主要面向医学生/医生，或者公卫、流统、统计等群体，可能不适合其他专业。本合集仅有R语言最基础的内容，R语言实战内容会在本合集结束后新开合集介绍。\n初学者学习R语言不需要完全记住所有内容，只需要有个大概印象即可，这样你在遇到类似的问题时可以知道解决的途径，也可以避免与别人交流时因为完全听不懂而产生无效交流。等使用次数多起来之后自然就会记住各种概念和用法，学习编程是一个熟能生巧的过程，一定要多敲代码！\n主要内容如下：\n\n与我的其他合集一样，本合集也会长期保持不定期更新，并且也是网页版免费看，PDF版付费获取（暂未整理）。\n\n免费文档观看网址：R语言零基础入门\nPDF版获取链接：暂未整理\n\n所有内容都已在我的个人公众号（医学和生信笔记）发布，收录在R语言入门合集中，包括数据获取方式，想要白嫖的可在历史推文中查看对应的文章（有些数据会在公众号文章的评论区放出获取方式）。\n为了方便大家学习，我已经录制了配套的视频，放在了哔哩哔哩（我的B站账号：阿越就是我），免费观看，点击直达：R语言零基础入门\n限于个人专业、水平、时间等问题，难免有很多不足之处，欢迎大家以各种方式（微信、QQ、公众号留言等）交流、建议。但是请不要抬杠，也请不要成为喷子、伸手党、张嘴党。",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "index.html#参考书目",
    "href": "index.html#参考书目",
    "title": "R语言零基础入门",
    "section": "参考书目",
    "text": "参考书目\n主要参考了3本书：\n\n《R语言实战》\n《R数据科学》\n《R语言编程-基于tidyverse》",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "index.html#推荐阅读",
    "href": "index.html#推荐阅读",
    "title": "R语言零基础入门",
    "section": "推荐阅读",
    "text": "推荐阅读\n推荐一些适合医学生/医生的R语言书籍：\n\n入门/R语言基础：\n\n《R语言实战》\n《R数据科学》\n《R语言编程-基于tidyverse》\n\nR语言绘图：\n\n《R数据可视化手册》（超详细版ggplot2绘制各种图形的说明书）\n《ggplot2：数据分析与图形艺术》（ggplot2作者写的书）\n《R绘图系统》（R语言绘图进阶）\n\n预测模型和机器学习：\n\n《应用预测建模》（caret说明书，适合医学生入门预测模型）\n《R语言整洁建模》（《tidy modeling with R》中文版，本人翻译，已上市）\n《R语言机器学习-基于mlr3》（中文版翻译中，未上市）\n《精通机器学习-基于R》（进一步了解caret及其他机器学习R包）",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "index.html#作者介绍",
    "href": "index.html#作者介绍",
    "title": "R语言零基础入门",
    "section": "作者介绍",
    "text": "作者介绍\n\n阿越，外科医生，R语言爱好者，长期分享R语言和医学统计学、临床预测模型、生信数据挖掘、R语言机器学习等知识。\n哔哩哔哩：阿越就是我\nGithub：ayueme\n公众号：医学和生信笔记，欢迎扫码关注：",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "01-R和Rstudio.html",
    "href": "01-R和Rstudio.html",
    "title": "1  R/Rstudio/Rtools",
    "section": "",
    "text": "1.1 什么是R语言？\nR语言是一门编程语言，但是同时一个统计软件。R语言的全称是：The R Project for Statistical Computing\n如果你是一个医学生或者医生，那么你一定用过或听说过SPSS，SPSS是一个统计软件，R语言与之类似，也可以实现各种统计分析，但不同的是，R语言需要自己编写代码，而SPSS只要鼠标点击即可（其实SPSS也可以写代码的）。所以你可以简单理解为R语言是一个比SPSS更加强大的统计软件。\n与常见的其他统计分析软件（比如：SPSS、Excel、SAS、Stata、Graphpad Prism）相比，R最主要的优势是免费和功能更加强大。\nR语言的功能非常强大，因为它需要自己编写代码，所以和Python类似，也是一门编程语言，虽然R擅长统计分析，但并不是只能做统计分析！除了统计分析，R语言还非常擅长数据分析、数据可视化、统计建模等。\n以下是几个官方网址：\n根据视频教程操作即可，注意版本选择（初次安装选择最新的即可，大佬随便选）。",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R/Rstudio/Rtools</span>"
    ]
  },
  {
    "objectID": "01-R和Rstudio.html#什么是r语言",
    "href": "01-R和Rstudio.html#什么是r语言",
    "title": "1  R/Rstudio/Rtools",
    "section": "",
    "text": "R只是实现目的一种工具，学会了R并不代表学会了统计学，也不要把R和统计划等号！\n\n\n\n\n\n\n\n警告\n\n\n\n\n安装路径不能有中文，必须先改成英文（也可以安装在D盘，等）；\n安装时建议取消勾选Message Translation，这样报错信息都是英文，方便你搜索解决方法。\n\n\n\n\n\nR官方网址：https://www.r-project.org/\nR官方镜像网址：https://cran.r-project.org/mirrors.html",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R/Rstudio/Rtools</span>"
    ]
  },
  {
    "objectID": "01-R和Rstudio.html#什么是rstudio",
    "href": "01-R和Rstudio.html#什么是rstudio",
    "title": "1  R/Rstudio/Rtools",
    "section": "1.2 什么是Rstudio？",
    "text": "1.2 什么是Rstudio？\n当你安装完R语言之后，它是可以直接使用的，只是此时它的界面非常丑陋，而且缺少各种好用的功能。\n\n\n\nR语言的原生界面\n\n\n上图是R语言的原生界面，看起来很原始，毫无美感，感觉和高大上没什么关系。\n而RStudio是专门为R语言量身定制的集成开发环境（简称IDE），你可以理解成RStudio是R语言的一层漂亮的衣服，安装了RStudio之后，首先是使用界面更加漂亮、更加现代化了，除此之外，还增加了很多顺手的小功能。\n\n\n\n安装Rstudio之后的界面\n\n\n安装RStudio之后，界面明显更加好看了，非常的美观，各种按钮、布局等也更加的现代化。\n\n由于我进行了一些自定义的界面设置，部分细节可能和你的不同。\n\n以下是RStudio官方下载地址：\n\nRStudio官方下载网址：https://posit.co/download/rstudio-desktop/",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R/Rstudio/Rtools</span>"
    ]
  },
  {
    "objectID": "01-R和Rstudio.html#rtools",
    "href": "01-R和Rstudio.html#rtools",
    "title": "1  R/Rstudio/Rtools",
    "section": "1.3 Rtools",
    "text": "1.3 Rtools\n为了保证顺畅的使用，Windows用户还需要安装Rtools，MAC和linux用户不需要安装。\n下载Rtools的官方地址是：https://cran.r-project.org/bin/windows/Rtools/\n\n打开后需要选择合适的版本，注意不要选错，我选的是RTools4.3（因为我的R是4.3.x版本，你不要选错，你的R如果是4.4.x，你就要选择RTools4.4，如果R是4.5.x，就选择RTools4.5。以此类推，明白吗？），点击后来到一下界面，点击Rtools43 installer（如果你选的不是RTools4.3，那么数字也会不同，不难理解吧）即可下载exe安装文件，下载完点击安装即可。\n\n视频版教程见B站。\n\n\n\n\n\n\n注意\n\n\n\nrtools4.4及以后推出了ARM版本（64-bit ARM Rtools44 installer），注意你的电脑的CPU类型，不要选错！\n\n\n都安装好之后就可以开始正式的R语言学习之旅了！",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>R/Rstudio/Rtools</span>"
    ]
  },
  {
    "objectID": "02-第一次上手使用.html",
    "href": "02-第一次上手使用.html",
    "title": "2  R语言初体验",
    "section": "",
    "text": "2.1 控制台和脚本窗口\n在Console（中文：控制台）窗口中，大于号&gt;的后面，输入1+1，然后按回车键，就会给出计算结果。同理输入其他运算式，按回车键，都会立马得到结果。\nR语言中的一些常见数学运算：\n# + - * /\n1+1\n## [1] 2\n1-1\n## [1] 0\n3*2\n## [1] 6\n10 / 2\n## [1] 5\n\nabs(-10) # 绝对值\n## [1] 10\nsqrt(25) # 平方根\n## [1] 5\nlog(100)\n## [1] 4.60517\nlog10(100)\n## [1] 2\nlog2(100)\n## [1] 6.643856\nexp(10) # 指数函数\n## [1] 22026.47\n\nceiling(3.257) # 往上取整数\n## [1] 4\nfloor(3.257) # 往下取整数\n## [1] 3\nround(3.275, digits = 2) # 四舍五入\n## [1] 3.28\n除了数学运算，还可以输入各种函数，比如输入print(\"Hello, world\")，你可以尝试下。\n但是通常我们是不会直接在控制台窗口写代码的，而是在脚本窗口写代码，控制台用来查看代码输出结果。R脚本文件的扩展名为.R。\n以下是两种方式新建一个R脚本：\n方法一：依次点击左上角的File-New file-R Script，即可打开一个新的R脚本：\n方法二：点击New File小图标，再点击R script，也可以新建一个R脚本，两种方法完全一样。\n新建脚本文件后，我们就可以在脚本中写自己的代码了，这里写好的代码可以保存的，方便以后使用。如果你没保存，会有*提示，下面的保存按钮可以保存当前脚本（快捷键“control+s”），保存时可以修改这个脚本的名字：\n在这个脚本文件里可以写任何你想写的代码，比如上面我写了一个名字为fruits的向量，其中包括3个元素：apple、banana、watermelon。\n在R语言中，如果需要创建一个名字为a的对象，并且让a等于3，就是通过“赋值”实现的，下面就是示例：通过赋值，让a等于3：\na &lt;- 3 # 让a等于3\na # 把a打印在屏幕中，看看是不是3？\n## [1] 3\nR语言中使用&lt;-作为赋值符号，而不是=（但是使用=也可以，没有任何问题），以下两种写法都可以：\n# 通过赋值让a=3，以下两种写法都可以\na &lt;- 3\na = 3\n\n# 通过赋值让b=4，以下两种写法都可以\nb &lt;- 4\nb = 4\n\n# 查看a+b\na+b\n## [1] 7\n\n# 让dd是一串字符：\ndd &lt;- \"你好，我是阿越\"\n# 打印dd\nprint(dd)\n## [1] \"你好，我是阿越\"\n写好代码之后如果你要运行这个代码的话只需要把光标位置放在你要运行的代码的这一行，然后点击Run即可运行这行代码（也可以使用快捷键“control+enter”），代码运行结果会出现在控制台窗口：\n点击Run之后，代码运行结果会出现在控制台窗口：\n如果命令提示符（也就是控制台窗口中的&gt;）变成了一个加号（+），这表示我们输入的代码不完整，它正在等你输入完整的代码，这种情况通常是因为我们输入的代码太长了，超过了1行的限制，或者代码中的标点符号（比如：括号，逗号等）不成对。此时按“Esc”即可退回到正常状态下。\nRStudio的一大优点就是有代码自动补全和语法高亮功能。\n当你输入代码时，编辑器会提供语法高亮和代码补全提示。你只要输入前3个字母，再按Tab键，即可显示所有可能的函数，按上下方向键可以选择你需要的函数，选好之后按enter键即可选中。鼠标停留在函数名字上即可显示该函数的用法：\n另一个常用的快捷键是赋值符号：&lt;-，它是由小于号&lt;和减号-组成的，在RStudio中可以通过快捷键Alt+-快速输入。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R语言初体验</span>"
    ]
  },
  {
    "objectID": "02-第一次上手使用.html#控制台和脚本窗口",
    "href": "02-第一次上手使用.html#控制台和脚本窗口",
    "title": "2  R语言初体验",
    "section": "",
    "text": "注意\n\n\n\n这个大于号&gt;叫命令提示符，提示你这里是输入代码的地方。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n注意\n\n\n\n上图脚本中前两行我写了很多中文，而且在每一行的前面都加了#，#表示这一行不是代码，不需要运行，你可以在#后面写任何你想写的东西，比如一些解释说明的话等。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n注意\n\n\n\n光标位置在代码的开头、中间、结尾都没关系，RStudio都能识别出来，你也可以直接使用鼠标全部选中你要运行的代码，再点击Run，也可以达到一样的效果。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R语言初体验</span>"
    ]
  },
  {
    "objectID": "02-第一次上手使用.html#环境窗口和绘图窗口",
    "href": "02-第一次上手使用.html#环境窗口和绘图窗口",
    "title": "2  R语言初体验",
    "section": "2.2 环境窗口和绘图窗口",
    "text": "2.2 环境窗口和绘图窗口\n当我们运行代码后，我们建立的对象（比如上面的a、b、dd）会出现在Enviroment窗口中：\n\n初学者可能会经常遇到一个错误：\n错误：找不到对象xxx\n\nError: object 'ee' not found\n这个时候你就要确认下，你是否已经创建了这个对象，在哪里查看有没有这个对象？在环境面板中查看，环境面板中的东西都叫对象，比如上图中的fruits、x、y就是三个对象。\n比如你现在运行以下代码，就会得到以上报错：\nprint(ee)\n\n错误: 找不到对象'ee'\n就是因为你并没有创建这个对象（环境面板中并没有ee这个对象）！你先创建这个对象就不会报错了：\n\nee &lt;- \"先定义我，我就不会报错！\" # 先定义（或者叫创建）对象\nprint(ee)  # 就不会报错了\n## [1] \"先定义我，我就不会报错！\"\n\n清除当前环境中的某个对象，可以用：\nrm(xxx) # xxx是对象名字，rm是remove的缩写\n比如清除dd这个对象，只需要使用：\n\n# 运行以下代码，看看环境面板中dd是不是没有了？\nrm(dd)\n\n如果要同时清除所有对象，可以直接点击Enviroment窗口中的小扫帚图标，也可以直接用：\n\nrm(list = ls()) # ls()是list的缩写，意思是列出当前所有对象\n\n当我们执行画图代码后，图形会出现在Plots窗口：",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R语言初体验</span>"
    ]
  },
  {
    "objectID": "02-第一次上手使用.html#推荐的rstudio设置",
    "href": "02-第一次上手使用.html#推荐的rstudio设置",
    "title": "2  R语言初体验",
    "section": "2.3 推荐的RStudio设置",
    "text": "2.3 推荐的RStudio设置\n点击Tools-Global Options，按照以下图片所示进行设置。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R语言初体验</span>"
    ]
  },
  {
    "objectID": "02-第一次上手使用.html#rstudio自定义设置",
    "href": "02-第一次上手使用.html#rstudio自定义设置",
    "title": "2  R语言初体验",
    "section": "2.4 rstudio自定义设置",
    "text": "2.4 rstudio自定义设置\n\n更改代码界面的字体大小：\n\n\n\n更改主题，比如改成黑色背景的，或者更改代码的字体等，可以点击Tools-Global Options来到以下界面进行更改：\n\n\n注意，由于我自己安装了很多额外的主题和字体，所以我的部分主题和字体你是没有的。\n\n\n\n更改脚本窗口、控制台、环境面板等面板的位置和布局：",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>R语言初体验</span>"
    ]
  },
  {
    "objectID": "03-R包安装.html",
    "href": "03-R包安装.html",
    "title": "3  R包介绍和安装",
    "section": "",
    "text": "3.1 什么是R包？\nR包是别人整理好的工具包，内置各种函数以及帮助文档等信息，可以用来实现特定的功能。\nR包相当于手机里的APP，不同的APP有不同的功能，不同的R包也有不同的功能，比如：有些R包是专门用来画热图的（pheatmap、complexheatmap等），有些R包是专门用来做生存分析（survival、survminer等）的，等。\nR语言在安装时会有很多自带的R包（包括base、datasets、utils、grDevices、graphics、stats、methods），这些R包不需要额外安装，都是出场自带的，安装好R语言就能用了。类似于刚买的新手机有很多内置APP，这些内置APP是不用自己额外安装的。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R包介绍和安装</span>"
    ]
  },
  {
    "objectID": "03-R包安装.html#r包安装",
    "href": "03-R包安装.html#r包安装",
    "title": "3  R包介绍和安装",
    "section": "3.2 R包安装",
    "text": "3.2 R包安装\nR包就相当于手机里的各种APP，自带的APP很明显是无法满足日常使用的，所以我们需要自己安装其他APP。同理，R自带的R包也是无法满足我们要求的，所以我们也要自己安装其他R包。\n安装R包就类似于给手机安装APP，安装方式有多种。比如：\n\n小米手机可以从小米应用商店安装APP，也可以从酷安安装APP，还可以从Google play安装，还可以从官网下载apk文件到本地安装，等；\n苹果手机可以从App Store安装，还可以通过巨魔商店安装，也可以本地安装。\n\nR包安装也有多种方法，不同的R包是存放在不同的应用商店的。比较常见的R包安装主要是4种：\n\n从CRAN安装，\n从bioconductor安装，\n从github安装，\n下载安装包本地安装。\n\n随着学习的深入你还会遇见其他安装方法，我列举的这几种是最常见的。\nR语言是老外发明的东西，我们要访问老外的东西，由于众所周知的原因，是很困难的。不只是R，其他的东西比如Python、Linux等，都是这样。\n所以在安装R包时，我们一定要先修改镜像（mirror）（或者你可以使用魔法，就像你使用Google play需要魔法一样，如果你在国外的话自然是不需要这一步的）。镜像可以简单理解为中国人为了方便自己下载安装，把国外的东西完整复制了一份放到国内，而且会随着国外的更新而更新。使用镜像的好处的不需要魔法我们也可以流畅快速地下载安装R包。\n一个R包只需要安装一次即可重复使用，R包也可以更新、卸载、重装，这个道理和手机APP简直是一模一样。\n以下是4种R包安装方法的详细介绍，这部分我在哔哩哔哩也有相应的视频介绍，点击即可观看：R语言零基础入门\n\n3.2.1 从CRAN安装\nCRAN是最主要的存储R包的仓库，大多数R包都是存储在这里的。\n要从CRAN安装，我们首先要修改镜像（如果你人在国外是不需要这一步的）。这个过程在安装好Rstudio之后非常简单，依次点击：Tools-Global Options：\n\n然后按照下图所示依次点击，在列出的镜像中任选一个中国的镜像即可（比如我选择了上海交通大学的镜像，理论上改好镜像之后下载会飞快并且不会出现下载不完全的情况，如果发生了，可以换镜像试试），选好之后点击OK即可。这样就修改好镜像了，下面就可以畅快的安装R包了。这种修改镜像只需要1次修改即可，以后从CRAN安装R包都会默认使用你选择的这个镜像，不用每次都改。\n\n比如我们现在想要安装ggplot2这个R包，使用以下代码即可：\n\ninstall.packages(\"ggplot2\")\n\n这也是默认的安装CRAN中的R包的方式，即：使用install.packages(\"xxx\")。\n\n\n\n\n\n\n注释\n\n\n\n安装R包时一定要注意，R包的名字不能拼错，大小写也不能错，而且必须加引号，双引号或者单引号都可以，但是必须是英文状态下的！加载R包不需要引号。\n\n\n\n\n3.2.2 从bioconductor安装\n医学生/医生学习R语言有相当一部分人是想做生信分析的，绝大多数做生信分析的R包都不在CRAN中，而是存储在bioconductor中，这个网站是专门存储生物信息学分析所用R包的。\n\n这个仓库也是老外建立维护的，所以要安装这里的R包，自然也是先要更改镜像的。\n从bioconductor的官方镜像列表中可知，目前中国镜像有以下4个，分别是清华大学的镜像、南京大学的镜像、中国科学技术大学的镜像、西湖大学的镜像，如下所示：\n\n每次在安装bioconductor的R包之前，都要先运行以下代码更换镜像，任选一个运行即可，目前我推荐你使用西湖大学的镜像，原因请看bioconductor有新的镜像选择啦：\n# 使用清华大学的镜像\noptions(BioC_mirror=\"https://mirrors.tuna.tsinghua.edu.cn/bioconductor\")\n\n# 使用南京大学的镜像\noptions(BioC_mirror=\"https://mirrors.nju.edu.cn/bioconductor/\")\n\n# 使用中国科学技术大学的镜像\noptions(BioC_mirror=\"https://mirrors.ustc.edu.cn/bioc/\")\n\n# 使用西湖大学的镜像\noptions(BioC_mirror=\"https://mirrors.westlake.edu.cn/bioconductor\")\n\n\n\n\n\n\n提示\n\n\n\nbioconductor的镜像不像CRAN那样只需要改一次，每次在安装bioconductor的包之前，都需要运行一下修改镜像的代码。但是随着学习的深入，你以后也可以通过修改.Rporfile文件实现1次修改，永久使用！建议初学者就别搞这些花里胡哨的操作了，还是每次都运行一下吧。\n\n\n运行完以上代码更改好镜像之后，我们还需要先安装一个bioconductor的R包管理器，才能安装bioconductor中的R包，使用以下代码安装bioconductor的R包管理器，也就是BiocManager包。\n由于bioconductor更新频繁，所以版本号会经常变，大家一定要亲自打开官方网站查看当前版本，使用官方网址给出的代码！不要单纯的复制粘贴！\n官方网址：安装bioconductor的官方网址\n\n\n# 安装BiocManager包\n# 注意不要搞错版本，否则小白搞不定！！\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\nBiocManager::install(version = \"3.18\") # 这个版本会变化的，根据官网来！！\n\n安装好这个包管理器之后，就可以安装bioconductor的R包了。以后再安装bioconductor的R包时，也不需要再重新安装这个包管理器了。\n\n\n\n\n\n\n注意\n\n\n\nR语言每年会进行1次版本大更新，时间大约是每年的4月份，bioconductor每年会进行两次更新，时间大约是每年的4月份和10月份。bioconductor的版本和R的版本是有对应关系的。对于初学者来说，不建议跨版本使用。\n通常来说R语言安装好之后不需要频繁的更新，一般不会影响使用，但是如果你一定要更新的话，建议每年的5月份进行更新，刚好是R和bioconductor同时更新的时间，此时的版本刚好匹配，初学者安装R包出错的概率要小一些。\n\n\n比如我们要安装一个做差异分析的R包：limma，就可以使用以下代码：\n\n# 每次都要先改镜像，建议使用西湖大学的镜像\noptions(BioC_mirror=\"https://mirrors.westlake.edu.cn/bioconductor\")\n\n# 改完镜像再安装\nBiocManager::install(\"limma\")\n\n这样limma包就安装好了。以后你要安装bioconductor中的R包，就先改镜像，然后使用BiocManager::install(\"xxx\")即可。\n\n\n3.2.3 从github安装\n有一些R包既不在CRAN，也不在bioconductor，而是在github中。要安装github中的R包，建议借助devtools或者remotes包实现。\n\n\n\n\n\n\n注意\n\n\n\nremotes可以认为是devtools的精简版，其实区别不大，所以我个人比较推荐使用devtools。\n\n\n首先从CRAN安装devtools包：\n\n# 没改镜像的记得先改镜像\ninstall.packages(\"devtools\")\n\n安装好之后再使用install_github()安装github中的R包，比如，我现在想要安装easyTCGA这个包，使用以下代码即可：\n\nlibrary(devtools)\ninstall_github(\"ayueme/easyTCGA\")\n\n其中easyTCGA是R包的名字，前面的ayueme是仓库所有者的名字。千万不要写错，写错必然报错！\n一般你找到这个R包都会有介绍如何安装，直接复制粘贴即可，github左上角也会有名字的，照抄就行，比如：\n\n但是国内访问github是有困难的，如果你的网络不行，那么这个方式大概率你会失败。有的时候即使你能打开github的网页，也不见得你用以上方法就能安装成功。那么这时你可以尝试下面介绍的本地安装。\n\n\n\n\n\n\n注意\n\n\n\n遇到以下报错，一般都是由于网络问题导致的：\n\ncannot open url: xxxx\ntimeout xxxx\ndownload from https://api.github.com/xxxx failed\n\n你能上谷歌或者YouTube，不代表你能从github（或者GDC TCGA的官网等）下载东西。\n\n\n\n\n3.2.4 本地安装\n本地安装R包就和本地安装手机APP没有任何区别，把安装包下载下来，然后安装就好了。\n还是以上面的easyTCGA为例，如果你要本地安装，首先你得下载这个R包到你的电脑上，所以你得找到这个R包的下载地址才行！\n在github上面的R包的下载地址都是有规律的，通常都是：https://github.com/xxxx/R包名字\n比如：easyTCGA包的下载地址是：https://github.com/ayueme/easyTCGA\n打开网址后，按照顺序依次点击：Code-Download ZIP，即可把R包下载到本地了（对你的网络有要求，因为这个网站也是老外的！）。\n\n\n\n下载github的R包\n\n\n我下载的R包存放在我的E盘-R-R包，这个文件夹里面，所以存放路径是：E:/R/R包/easyTCGA-main.zip\n此时安装包已经下载好了，我们可以借助devtools里面的install_local()函数安装本地R包：\n\nlibrary(devtools)\n\n# 注意你的R包存放路径不要写错！写错必报错！\ninstall_local(\"E:/R/R包/easyTCGA-main.zip\")\n\n本地安装需要注意R包依赖的问题。R包依赖的意思是有些R包是建立在其他R包的基础上的，所以你在安装时需要注意先后顺序，必须先安装某个包然后才能安装另一个包，否则就会出现安装失败。比如easyTCGA就是建立在很多R包之上，所以如果你没提前安装easyTCGA的依赖包，那么在进行本地安装时也会报错。\n这是本地安装最大的弊端，install.packages()和BiocManager::install()在安装R包时会自动帮你先安装依赖包，所以不会有问题。\neasyTCGA有以下依赖包，需要你先安装好下面的依赖包，才能安装easyTCGA：\n\n# 安装bioconductor上面的依赖R包\n# 首先要改镜像\noptions(BioC_mirror=\"https://mirrors.westlake.edu.cn/bioconductor\")\nif(!require(\"BiocManager\")) install.packages(\"BiocManager\")\nif(!require(\"TCGAbiolinks\")) BiocManager::install(\"TCGAbiolinks\")\nif(!require(\"SummarizedExperiment\")) BiocManager::install(\"SummarizedExperiment\")\nif(!require(\"DESeq2\")) BiocManager::install(\"DESeq2\")\nif(!require(\"edgeR\")) BiocManager::install(\"edgeR\")\nif(!require(\"limma\")) BiocManager::install(\"limma\")\n\n# 安装cran上面的依赖R包\nif(!require(\"survival\")) install.packages(\"survival\")\nif(!require(\"broom\")) install.packages(\"broom\")\nif(!require(\"devtools\")) install.packages(\"devtools\")\nif(!require(\"reshape2\")) install.packages(\"reshape2\")\nif(!require(\"data.table\")) install.packages(\"data.table\")\nif(!require(\"ggplot2\")) install.packages(\"ggplot2\")\nif(!require(\"ggpubr\")) install.packages(\"ggpubr\")\n\n以上安装R包的代码我加了一个if判断语句，意思是：如果我已经安装了这个R包，就不要重复安装了，如果没安装，就帮我安装。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R包介绍和安装</span>"
    ]
  },
  {
    "objectID": "03-R包安装.html#其他安装方法",
    "href": "03-R包安装.html#其他安装方法",
    "title": "3  R包介绍和安装",
    "section": "3.3 其他安装方法",
    "text": "3.3 其他安装方法\n除了以上介绍的安装方法外，还有一些R包的安装方法比较特殊，这里给大家简单介绍下，就以mlr3proba为例。这个R包由于一些原因不在CRAN中，如果你要安装Github版本，可以按照以下代码安装：\n\nremotes::install_github(\"mlr-org/mlr3proba\")\n\n但是如果你要使用install.packages()函数安装，需要按照如下方式进行：\n\ninstall.packages(\"mlr3proba\", repos = \"https://mlr-org.r-universe.dev\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R包介绍和安装</span>"
    ]
  },
  {
    "objectID": "03-R包安装.html#终极大法",
    "href": "03-R包安装.html#终极大法",
    "title": "3  R包介绍和安装",
    "section": "3.4 终极大法",
    "text": "3.4 终极大法\n直接百度、谷歌、必应。\n比如一个叫linkET的包，你不知道怎么安装，直接搜索啊：",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R包介绍和安装</span>"
    ]
  },
  {
    "objectID": "03-R包安装.html#r包常见报错",
    "href": "03-R包安装.html#r包常见报错",
    "title": "3  R包介绍和安装",
    "section": "3.5 R包常见报错",
    "text": "3.5 R包常见报错\n1. 载入了名字空间‘rlang’ 1.0.1，但需要的是&gt;= 1.0.2\n\n`rlang`包的版本太低了，你需要先安装1.0.2以上版本的`rlang`，记得直接关闭Rstudio，重新打开再安装\n\n2. 不存在叫‘latticeExtra’这个名字的程辑包\n\n首先看看自己的拼写错了吗？标点符号有错误吗？没问题就安装这个`latticeExtra`包即可\n\n3. 程序包安装入‘C:/Users/xxx/AppData/Local/R/win-library/4.2’(因为‘lib’没有被指定)\nWarning in install.packages : package ‘limma’ is not available for this version of R\nA version of this package for your version of R might be available elsewhere\n\n`limma`包在bioconductor上，不在CRAN上，要通过`BiocManager`安装。\n\n4. 安装程序包‘mapproj’时退出狀態的值不是0\n\n大概率依赖包没装好。\n\n5. library(lsmeans) Error: 找不到‘lsmeans’所需要的程辑包‘emmeans’\n\n缺什么就安装什么。找不到`emmeans`就安装`emmeans`。\n\n6. 用devtools从github安装包，无论是直接安装还是本地安装，都报timeout错误\n\ngithub在国外，访问国外的网站你得科学上网，你网络行吗？你能访问谷歌不代表你能从github下载东西。\n\n7. 安装r包时出现：update all/some/none?\n\n问你要不要：更新所有R包/部分R包/不更新？输入n就行了，表示不更新。\n\n8. library(tidyverse)出现一大推字\n\n── Attaching core tidyverse packages ────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n── Conflicts ──────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package to force all conflicts to become errors\n\n正常的，不用管，只要没有`Error`就没事。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>R包介绍和安装</span>"
    ]
  },
  {
    "objectID": "04-什么是函数.html",
    "href": "04-什么是函数.html",
    "title": "4  R包、函数、帮助文档",
    "section": "",
    "text": "4.1 函数\n函数的英文是function，所以函数是用来实现特定功能的、由别人整理好的一段代码，通常一个R包会包含多个函数。这就好比一个手机APP可以做多个事情，比如微信可以用来文字聊天、视频聊天、查看订阅号消息等，甚至还可以看直播。\n一个R包里面有多个函数，这些函数也可以实现不同的功能。比如graphics包里面的两个函数：\nplot(1:10,1:10) # 画图\nlines(1:10) # 添加一条线\n这里的plot()就是一个函数，可以实现画图功能。当你运行plot(1:10,1:10)之后，它会为你开辟一片空间用于画图，然后把这个图的框架（4条框以及坐标等）给你画出来，然后把点也给你画上去，这就是这个函数的功能（当然它还有其他功能）。\n当你接着运行lines(1:10)之后，它会给你画一条线，这就是lines()这个函数的功能。\n当我们在使用某个手机APP时，肯定是要先打开这个APP，然后才能使用它，R包也是如此，一定要先加载R包，才能使用R包里的函数。\n这个plot()函数是graphics包里面的，这个R包是R语言自带的（有些自带的不需要加载也能使用），不需要额外安装，使用时也不需要加载（即不需要先library(graphics)），自己安装的R包是需要先加载才能使用里面的函数的。\n比如ggplot()函数是属于ggplot2这个R包的，这个R包是需要自己安装的，所以在使用前需要先加载才能使用：\n# 先加载对应的R包\nlibrary(ggplot2)\n\n# 才能使用里面的函数\nggplot()\n我经常看到有人把函数当做R包，然后使用install.packages(\"\")进行安装，非常错误的做法，比如有一个R包叫rms，其中有一个函数叫lrm，有的人不明所以，直接使用install.packages(\"lrm\")，结果报错:\n你要安装的是R包，不是函数，千万要注意，别犯这种低级错误。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R包、函数、帮助文档</span>"
    ]
  },
  {
    "objectID": "04-什么是函数.html#函数",
    "href": "04-什么是函数.html#函数",
    "title": "4  R包、函数、帮助文档",
    "section": "",
    "text": "install.packages(\"lrm\")\n将程序包安装入‘C:/Users/liyue/AppData/Local/R/win-library/4.3’\n(因为‘lib’没有被指定)\nWarning in install.packages :\n  package ‘lrm’ is not available for this version of R\n\nA version of this package for your version of R might be available elsewhere,\nsee the ideas at\nhttps://cran.r-project.org/doc/manuals/r-patched/R-admin.html#Installing-packages",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R包、函数、帮助文档</span>"
    ]
  },
  {
    "objectID": "04-什么是函数.html#参数",
    "href": "04-什么是函数.html#参数",
    "title": "4  R包、函数、帮助文档",
    "section": "4.2 参数",
    "text": "4.2 参数\n每个函数都有特定的参数（argument），比如上面的plot(1:10,1:10)，其中的1:10就是plot这个函数的参数，你也可以写成plot(x = 1:10, y = 1:10)：\n\nplot(x = 1:10, y = 1:10)\n\n\n\n\n\n\n\n\n这也是完整的写法，其中的x、y被称为形式参数（简称形参），1:10被称为实际参数（简称实参）。\n形参是函数的作者规定的，这个名字如果你写了，就要写对，不能乱写，必须按照人家的规定来，实参是需要你自己提供的。\n如果你写了形参的话，可以不用管参数的顺序：\n\nopar &lt;- par(mfrow=c(1,2))\n# 先写x或y都不影响\nplot(x = c(2,4,6,8,10), y = 1:5)\nplot(y = 1:5, x = c(2,4,6,8,10))\n\n\n\n\n\n\n\npar(opar)\n\n形参是可以省略的，但是省略后要按照作者规定的顺序提供实参，不然就会出问题（初学者建议写上形参），比如：\n\nopar &lt;- par(mfrow=c(1,2))\n# 不写形参先后顺序有影响，会默认第一个是x,第二个是y\nplot(c(2,4,6,8,10), 1:5)\nplot(1:5, c(2,4,6,8,10))\n\n\n\n\n\n\n\npar(opar)\n\n这些参数是有要求的，不按照规定写就会报错。比如：\n\n有的参数需要你提供数值型的向量（数据类型会在后面几章介绍）给它，如果你提供的不是数值型向量，那么它就会报错；\n有的参数不能有NA或者缺失值，如果你提供的数据里有NA或者缺失值，那么它肯定会报错。\n\n这个东西是很机械的，不可更改，函数的作者规定的，不按照要求写必然报错！\n还有一些参数是有默认值的，如果你没有指定，它就会使用默认值。比如：\n?t.test\n\n# 其中的mu = 0, paired = FALSE, var.equal = FALSE, \n# conf.level = 0.95 都是默认值\n如何知道每个参数的具体要求及函数的使用方法呢？我们可以直接查看帮助文档。帮助文档是函数的开发者按照一定的要求写的、能够让使用者快速理解函数用法的文档。\n绝大多数R语言中的函数都可以通过?xxx或者help(xxx)查看函数的帮助文档（自己安装的R包需要先加载），比如：\n\n# 以下两种方法都可以\n?lines\n\n# 或者\nhelp(\"lines\")\n\n当你运行上面的代码后，在Rstudio右侧help面板中会出现该函数的帮助文档，如下图所示：\n\n帮助文档是学习函数用法的最好方法，这也是你以后最常用的学习方法（当然有些帮助文档写的很烂）。\n很多人一看到英文就头大，那么这样的话你可能不适合学R语言，绝大多数函数的帮助文档和报错信息都是只需要英语4级水平即可理解的，没有任何难度，只需要你认真去读一读就能得到很多信息！（只学到这里不往下学的话估计还是看不懂帮助文档的，大概就是单词你都认识，但是不知道什么意思）\n比如，在上面这个帮助文档中：\n\n在这个帮助文档中，首先是Description，这部分会简要的告诉你这个函数是干啥的，比如这个函数的描述告诉你，这个函数可以使用不同方式给出的坐标，并把点连接成线。\n下面是Usage，这部分主要是展示这个函数的基本用法，以及有哪些参数，比如lines有两种用法，要么是lines(x, ...)，要么是lines(x, y = NULL, type = \"l\", ...)。\n再往下是Arguments，这部分是参数的细节，这部分会详细告诉你，每个参数接受哪种类型等。比如x,y，这两个参数需要一个vectors，也就是一个向量，此时你必须提供一个向量，如果提供其他类型，必然报错！\n再往下是一些需要注意的细节（Details）以及参考文献（References）等，最后是使用示例（Examples），这个示例可以直接运行，你也可以通过示例学习函数的用法。\n\n如果现在的你还是无法理解帮助文档的内容，也不用着急，因为初学都是这样的，随着学习的深入，你会越来越得心应手。\n很多初学者喜欢直接复制粘贴别人的代码，然后直接把数据换成自己的，绝大多数都会遇到报错，无法运行。主要原因就是不知道每个函数的具体要求，别人的代码是按照要求写的，自然可以运行，你的东西和别人不一样，不符合函数的要求，必然报错。\n以下是一些常用的帮助函数，你可以自己输入一下试试看，多敲代码是学习编程的最好方法：\n\n自己学习以上代码时记得把对象的名字换成自己想看的，你输入上面的foo必报错！\n关于R包的函数使用时的常见错误：",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>R包、函数、帮助文档</span>"
    ]
  },
  {
    "objectID": "05-导入导出文件.html",
    "href": "05-导入导出文件.html",
    "title": "5  导入导出文件",
    "section": "",
    "text": "5.1 工作路径\n首先说下工作路径的问题，当前工作目录（working-directory）是你的R语言读取和保存文件的默认位置。\n如果你没改过，这个位置有一个默认值，在第2章介绍过：点击Tools-Global Options，按照以下图片所示进行设置，方框里的就是默认工作目录。\n确定好你的R语言的工作目录以及你的文件的存放位置后，才能顺利读取文件，比如你的工作目录在D盘，但是你的文件在E盘，如果读取时没有明确指定文件位置，就会报错。\n打开RStudio后，可以使用getwd()查看当前工作目录（注意，和视频中的路径不太一样，千万要注意你自己的路径是什么！）：\ngetwd()\n## [1] \"F:/R_books/r4beginners_base_r\"\n以上结果说明我在：F:/R_books/r4beginners_base_r这个文件夹里（和视频中的路径略有不同）。\n也可以查看Console（控制台）的左上角获取当前的工作目录：\n可以使用setwd()重新设置当前工作目录：\n# 设置为F盘R_books文件夹\nsetwd(\"F:/R_books/\")\n确认当前工作目录是非常重要的，尤其是在读取或者保存文件的时候，你总得知道你目前在哪个文件夹吧？\n以下是一些用于管理R工作路径的函数：\n除此之外还有一些可以和当前工作目录交互的函数，比如列出当前工作目录下的所有文件和文件夹：\nlist.files()\n##  [1] \"_book\"                        \"_language.yml\"               \n##  [3] \"_quarto.yml\"                  \"01-R和Rstudio.html\"          \n##  [5] \"01-R和Rstudio.qmd\"            \"02-第一次上手使用.html\"      \n##  [7] \"02-第一次上手使用.qmd\"        \"03-R包安装.html\"             \n##  [9] \"03-R包安装.qmd\"               \"04-什么是函数.html\"          \n## [11] \"04-什么是函数.qmd\"            \"04-什么是函数_files\"         \n## [13] \"05-导入导出文件.qmd\"          \"05-导入导出文件.rmarkdown\"   \n## [15] \"06-R中的数据类型.qmd\"         \"07-数据结构.qmd\"             \n## [17] \"08-类型判断和转换.qmd\"        \"09-数值和字符串处理.qmd\"     \n## [19] \"10-控制结构和自编函数.qmd\"    \"11-apply系列.qmd\"            \n## [21] \"12-实用技巧.qmd\"              \"13-TCGA_mrna表达矩阵整理.qmd\"\n## [23] \"14-R绘图入门.qmd\"             \"15-tidyverse简介.qmd\"        \n## [25] \"16-完结篇.qmd\"                \"9999-appendix.qmd\"           \n## [27] \"brca_clin.xlsx\"               \"brca_filter.R\"               \n## [29] \"datasets\"                     \"figs\"                        \n## [31] \"firsttest.R\"                  \"index.html\"                  \n## [33] \"index.qmd\"                    \"LICENSE\"                     \n## [35] \"mystats.R\"                    \"preamble.tex\"                \n## [37] \"r-beginners.Rproj\"            \"README.md\"                   \n## [39] \"site_libs\"                    \"tcga_meso\"\n\n# 类似的函数还有dir()\n还可以只列出符合要求的文件，比如列出所有以qmd结尾的文件：\nlist.files(pattern = \"qmd$\") # 涉及正则表达式\n##  [1] \"01-R和Rstudio.qmd\"            \"02-第一次上手使用.qmd\"       \n##  [3] \"03-R包安装.qmd\"               \"04-什么是函数.qmd\"           \n##  [5] \"05-导入导出文件.qmd\"          \"06-R中的数据类型.qmd\"        \n##  [7] \"07-数据结构.qmd\"              \"08-类型判断和转换.qmd\"       \n##  [9] \"09-数值和字符串处理.qmd\"      \"10-控制结构和自编函数.qmd\"   \n## [11] \"11-apply系列.qmd\"             \"12-实用技巧.qmd\"             \n## [13] \"13-TCGA_mrna表达矩阵整理.qmd\" \"14-R绘图入门.qmd\"            \n## [15] \"15-tidyverse简介.qmd\"         \"16-完结篇.qmd\"               \n## [17] \"9999-appendix.qmd\"            \"index.qmd\"",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>导入导出文件</span>"
    ]
  },
  {
    "objectID": "05-导入导出文件.html#工作路径",
    "href": "05-导入导出文件.html#工作路径",
    "title": "5  导入导出文件",
    "section": "",
    "text": "注释\n\n\n\n注意，在R中写路径时需要使用斜杠/，而不是反斜杠\\，如果你要在路径中使用反斜杠，必须用两个\\\\，比如：F:/R_books/和F:\\\\R_books\\\\都是正确的，但是F:\\R_books\\是错误的。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>导入导出文件</span>"
    ]
  },
  {
    "objectID": "05-导入导出文件.html#读取文件",
    "href": "05-导入导出文件.html#读取文件",
    "title": "5  导入导出文件",
    "section": "5.2 读取文件",
    "text": "5.2 读取文件\n不同文件有不同的后缀名，Windows系统可更改是否显示后缀名：\n\n不同的后缀名说明文件是不同的格式，不同的格式需要不同的软件（函数）才能打开，乱用就会导致打不开或者打开乱码。\n\n5.2.1 Excel\n这个格式太常见了，大家日常生活用的大部分都是这种格式。\n比如有这么一个excel文件：brca_clin.xlsx，这个数据是我从TCGA官网下载的乳腺癌患者的临床信息，包含：患者ID、样本ID、样本类型（normal还是tumor？）、年龄、性别等。\n它里面的内容是这样的：\n\n\n\n示例excel\n\n\n现在我们需要把它读入R里面。\n我推荐你使用readxl包读取Excel文件。这个R包并不是“出厂自带”的，因此我们需要先安装这个R包（提醒：你更改镜像了吗？）：\n\ninstall.packages(\"readxl\")\n\n安装好之后，我们需要加载这个R包才能使用：\n\nlibrary(readxl)\n\n然后我们就可以读取这个文件了，读取时，你必须指明你的文件在哪里！这就涉及到工作路径的问题了，如果你的文件和当前工作路径不在同一个文件夹下，那么一定要指定你的文件在哪里。如果文件路径没写对，就会出现下面这种类似的报错，一般情况下，它会告诉你：你的路径没写对、或者找不到这个文件、这个文件不存在、不能打开连接等等错误。\n\n# col_names = TRUE 表示这个文件是有列名的\nbrca_clin &lt;- read_xlsx(\"E:/brca_clin.xlsx\", col_names = TRUE)\n\nError: `path` does not exist: ‘E:/brca_clin.xlsx’\n\n这个时候你就要去确认下，你的这个brca_clin.xlsx文件到底在哪里！当你给它正确的路径时，它就不会报错。比如这个示例文件位于F:/R_books/r4beginners_base_r中，你写对了就能读进来：\n\n# 读取\nbrca_clin &lt;- read_xlsx(\"F:/R_books/r4beginners_base_r/brca_clin.xlsx\", \n                       col_names = T)\n\nbrca_clin[1:5,2:5] # 查看第1-5行，第2-5列\n## # A tibble: 5 × 4\n##   patient      sample           sample_type         initial_weight\n##   &lt;chr&gt;        &lt;chr&gt;            &lt;chr&gt;                        &lt;dbl&gt;\n## 1 TCGA-BH-A1FC TCGA-BH-A1FC-11A Solid Tissue Normal            260\n## 2 TCGA-AC-A2FM TCGA-AC-A2FM-11B Solid Tissue Normal            220\n## 3 TCGA-BH-A0DO TCGA-BH-A0DO-11A Solid Tissue Normal            130\n## 4 TCGA-E2-A1BC TCGA-E2-A1BC-11A Solid Tissue Normal            260\n## 5 TCGA-BH-A0BJ TCGA-BH-A0BJ-11A Solid Tissue Normal            200\n\n这样我们就成功把文件读取到R里面了，并且这个文件的内容被存储在brca_clin这个对象（object）中，此时你可以在Environment面板中看到brca_clin这个对象。\n上面代码中的F:/R_books/r4beginners_base_r/brca_clin.xlsx这种路径写法被称为绝对路径，意思是：从最开始的位置一直往下写，除此之外，还有一种写法是相对路径，即从相对于当前路径的位置开始写。\n比如，我这段脚本的当前工作路径位于F盘-R_books文件夹-r4beginners_base_r文件夹中（还记得怎么查看当前工作路径吗？getwd()），和brca_clin.xlsx这个文件同处于一个文件夹中，那么在读取时也可以这么写：\n\n# 因为在同一路径下，所以可以直接写名字\nbrca_clin &lt;- read_xlsx(\"brca_clin.xlsx\", col_names = T)\n\n# 或者\nbrca_clin &lt;- read_xlsx(\"./brca_clin.xlsx\", col_names = T)\n\n其中的./表示当前工作路径，可以省略不写。\n如果一个名字是brca_expr.xlsx的文件位于F盘-R_books文件夹-r4beginners_base_r文件夹-datasets文件夹中，也就是说datasets这个文件夹是和当前工作路径同一级的，但是我们要读取的文件在datasets文件夹中，那么在读取时就可以这么写：\n\n# 加了一个datasets/\nbrca_expr &lt;- read_xlsx(\"datasets/brca_expr.xlsx\", col_names = T)\n\n如果一个名字是brca_expr_不要删.xlsx的文件位于F盘-R_books文件夹中，也就是说位于当前工作路径的上一级文件夹中，如果要读取这个文件，可以使用以下代码：\n\nbrca_expr_不要删 &lt;- read_xlsx(\"../brca_expr_不要删.xlsx\", col_names = T)\n\n其中，../表示上一级目录（当前工作目录的上一级），不能省略。\n以上是对于路径的简单介绍，大家要自己多加练习，仔细体会。\n相对路径写起来更加简单，所以以下示例都会用相对路径进行演示。\n除了路径问题，对于新手还有几个点需要注意：\n\n注意/，\\，\"\"，''，这些标点一定要在英文状态下输入！R语言的文件路径只支持/或者\\\\，不能是\\；\n这个示例文件是有列名的，所以在读取的时候加了col_names=T这个参数，没有列名就要改成F；\n如果你的数据使用了合并/拆分单元格、各种格式、公式等，会报错！复杂的表头在读取时代码也会变得很复杂，建议大家初学时都整理成示例文件这种简单的表头；\n这个文件是.xlsx格式的，如果不是，那你需要用其他函数，比如：使用read_xls()函数读取.xls结尾的文件；每个函数的功能都是有要求的，不能乱用，记得多查看函数的帮助文档。\n如果你读取中文遇到乱码问题，那大概率是遇到了编码问题，这是一个很复杂的问题：\n\n首先你可以通过点击Rstudio中的Tools-Global Options，到达以下界面，把默认编码方式改为utf-8，然后关闭rstudio，重新读取；\n\n\n\n\nutf8编码\n\n\n\n有时直接升级R包/R/rstudio/，重新保存文件为utf-8等方式也可以解决问题；\n如果都不行，直接百度！具体情况具体分析！\n\n\n\n\n5.2.2 csv\ncsv文件是一种逗号分隔文件，打开后和excel看起来一模一样，以下是一个csv文件示例，你不要问为什么看不到逗号……\n\n\n\n示例csv\n\n\n一般推荐把excel文件另存为csv文件，因为方便R语言读取，不需要安装额外的R包也可以读取~\n\n# read.csv是R自带的函数，不用加载R包；header = T 表示这个文件有列名\ncsv &lt;- read.csv(\"datasets/brca_clin.csv\", header = T)\n\ncsv\n##                         barcode      patient           sample\n## 1  TCGA-BH-A1FC-11A-32R-A13Q-07 TCGA-BH-A1FC TCGA-BH-A1FC-11A\n## 2  TCGA-AC-A2FM-11B-32R-A19W-07 TCGA-AC-A2FM TCGA-AC-A2FM-11B\n## 3  TCGA-BH-A0DO-11A-22R-A12D-07 TCGA-BH-A0DO TCGA-BH-A0DO-11A\n## 4  TCGA-E2-A1BC-11A-32R-A12P-07 TCGA-E2-A1BC TCGA-E2-A1BC-11A\n## 5  TCGA-BH-A0BJ-11A-23R-A089-07 TCGA-BH-A0BJ TCGA-BH-A0BJ-11A\n## 6  TCGA-E2-A1LH-11A-22R-A14D-07 TCGA-E2-A1LH TCGA-E2-A1LH-11A\n## 7  TCGA-BH-A1FB-11A-33R-A13Q-07 TCGA-BH-A1FB TCGA-BH-A1FB-11A\n## 8  TCGA-BH-A18M-11A-33R-A12D-07 TCGA-BH-A18M TCGA-BH-A18M-11A\n## 9  TCGA-BH-A0BM-11A-12R-A089-07 TCGA-BH-A0BM TCGA-BH-A0BM-11A\n## 10 TCGA-E2-A153-11A-31R-A12D-07 TCGA-E2-A153 TCGA-E2-A153-11A\n## 11 TCGA-B6-A0RH-01A-21R-A115-07 TCGA-B6-A0RH TCGA-B6-A0RH-01A\n## 12 TCGA-BH-A1FU-01A-11R-A14D-07 TCGA-BH-A1FU TCGA-BH-A1FU-01A\n## 13 TCGA-AR-A0TX-01A-11R-A084-07 TCGA-AR-A0TX TCGA-AR-A0TX-01A\n## 14 TCGA-A1-A0SE-01A-11R-A084-07 TCGA-A1-A0SE TCGA-A1-A0SE-01A\n## 15 TCGA-OL-A5D6-01A-21R-A27Q-07 TCGA-OL-A5D6 TCGA-OL-A5D6-01A\n## 16 TCGA-E2-A1IK-01A-11R-A144-07 TCGA-E2-A1IK TCGA-E2-A1IK-01A\n## 17 TCGA-AN-A0FT-01A-11R-A034-07 TCGA-AN-A0FT TCGA-AN-A0FT-01A\n## 18 TCGA-A2-A3KD-01A-12R-A213-07 TCGA-A2-A3KD TCGA-A2-A3KD-01A\n## 19 TCGA-A2-A0EO-01A-11R-A034-07 TCGA-A2-A0EO TCGA-A2-A0EO-01A\n## 20 TCGA-A2-A04P-01A-31R-A034-07 TCGA-A2-A04P TCGA-A2-A04P-01A\n##            sample_type initial_weight ajcc_pathologic_stage\n## 1  Solid Tissue Normal            260             Stage IIA\n## 2  Solid Tissue Normal            220             Stage IIB\n## 3  Solid Tissue Normal            130               Stage I\n## 4  Solid Tissue Normal            260              Stage IA\n## 5  Solid Tissue Normal            200             Stage IIB\n## 6  Solid Tissue Normal             60               Stage I\n## 7  Solid Tissue Normal            320             Stage IIB\n## 8  Solid Tissue Normal            310            Stage IIIA\n## 9  Solid Tissue Normal            100             Stage IIB\n## 10 Solid Tissue Normal            250             Stage IIB\n## 11       Primary Tumor            130             Stage IIA\n## 12       Primary Tumor            110              Stage IA\n## 13       Primary Tumor            470             Stage IIA\n## 14       Primary Tumor             90               Stage I\n## 15       Primary Tumor            200             Stage IIA\n## 16       Primary Tumor             70             Stage IIA\n## 17       Primary Tumor            130             Stage IIB\n## 18       Primary Tumor            770            Stage IIIA\n## 19       Primary Tumor            200              Stage IA\n## 20       Primary Tumor            250            Stage IIIC\n##    days_to_last_follow_up gender age_at_index\n## 1                      NA female           78\n## 2                      NA female           87\n## 3                    1644 female           78\n## 4                     501 female           63\n## 5                     660 female           41\n## 6                    3247 female           59\n## 7                      NA female           60\n## 8                      NA female           39\n## 9                    1876 female           54\n## 10                    707 female           51\n## 11                   5749 female           51\n## 12                     NA female           44\n## 13                   1972 female           64\n## 14                   1321 female           56\n## 15                    385 female           71\n## 16                   1800 female           71\n## 17                    214 female           63\n## 18                   1206 female           47\n## 19                   2442 female           54\n## 20                     NA female           36\n\n或者用read.table()函数读取。由于该函数可以读取很多格式，而每种文件格式的分隔符并不相同（比如csv文件是逗号分隔，txt文件是Tab分隔），因此在使用该函数时需要指定文件的分隔符：\n\ncsv &lt;- read.table(\"datasets/brca_clin.csv\", header = T,\n                  sep = \",\" # 指定分隔符！\n                  )\n\ncsv\n##                         barcode      patient           sample\n## 1  TCGA-BH-A1FC-11A-32R-A13Q-07 TCGA-BH-A1FC TCGA-BH-A1FC-11A\n## 2  TCGA-AC-A2FM-11B-32R-A19W-07 TCGA-AC-A2FM TCGA-AC-A2FM-11B\n## 3  TCGA-BH-A0DO-11A-22R-A12D-07 TCGA-BH-A0DO TCGA-BH-A0DO-11A\n## 4  TCGA-E2-A1BC-11A-32R-A12P-07 TCGA-E2-A1BC TCGA-E2-A1BC-11A\n## 5  TCGA-BH-A0BJ-11A-23R-A089-07 TCGA-BH-A0BJ TCGA-BH-A0BJ-11A\n## 6  TCGA-E2-A1LH-11A-22R-A14D-07 TCGA-E2-A1LH TCGA-E2-A1LH-11A\n## 7  TCGA-BH-A1FB-11A-33R-A13Q-07 TCGA-BH-A1FB TCGA-BH-A1FB-11A\n## 8  TCGA-BH-A18M-11A-33R-A12D-07 TCGA-BH-A18M TCGA-BH-A18M-11A\n## 9  TCGA-BH-A0BM-11A-12R-A089-07 TCGA-BH-A0BM TCGA-BH-A0BM-11A\n## 10 TCGA-E2-A153-11A-31R-A12D-07 TCGA-E2-A153 TCGA-E2-A153-11A\n## 11 TCGA-B6-A0RH-01A-21R-A115-07 TCGA-B6-A0RH TCGA-B6-A0RH-01A\n## 12 TCGA-BH-A1FU-01A-11R-A14D-07 TCGA-BH-A1FU TCGA-BH-A1FU-01A\n## 13 TCGA-AR-A0TX-01A-11R-A084-07 TCGA-AR-A0TX TCGA-AR-A0TX-01A\n## 14 TCGA-A1-A0SE-01A-11R-A084-07 TCGA-A1-A0SE TCGA-A1-A0SE-01A\n## 15 TCGA-OL-A5D6-01A-21R-A27Q-07 TCGA-OL-A5D6 TCGA-OL-A5D6-01A\n## 16 TCGA-E2-A1IK-01A-11R-A144-07 TCGA-E2-A1IK TCGA-E2-A1IK-01A\n## 17 TCGA-AN-A0FT-01A-11R-A034-07 TCGA-AN-A0FT TCGA-AN-A0FT-01A\n## 18 TCGA-A2-A3KD-01A-12R-A213-07 TCGA-A2-A3KD TCGA-A2-A3KD-01A\n## 19 TCGA-A2-A0EO-01A-11R-A034-07 TCGA-A2-A0EO TCGA-A2-A0EO-01A\n## 20 TCGA-A2-A04P-01A-31R-A034-07 TCGA-A2-A04P TCGA-A2-A04P-01A\n##            sample_type initial_weight ajcc_pathologic_stage\n## 1  Solid Tissue Normal            260             Stage IIA\n## 2  Solid Tissue Normal            220             Stage IIB\n## 3  Solid Tissue Normal            130               Stage I\n## 4  Solid Tissue Normal            260              Stage IA\n## 5  Solid Tissue Normal            200             Stage IIB\n## 6  Solid Tissue Normal             60               Stage I\n## 7  Solid Tissue Normal            320             Stage IIB\n## 8  Solid Tissue Normal            310            Stage IIIA\n## 9  Solid Tissue Normal            100             Stage IIB\n## 10 Solid Tissue Normal            250             Stage IIB\n## 11       Primary Tumor            130             Stage IIA\n## 12       Primary Tumor            110              Stage IA\n## 13       Primary Tumor            470             Stage IIA\n## 14       Primary Tumor             90               Stage I\n## 15       Primary Tumor            200             Stage IIA\n## 16       Primary Tumor             70             Stage IIA\n## 17       Primary Tumor            130             Stage IIB\n## 18       Primary Tumor            770            Stage IIIA\n## 19       Primary Tumor            200              Stage IA\n## 20       Primary Tumor            250            Stage IIIC\n##    days_to_last_follow_up gender age_at_index\n## 1                      NA female           78\n## 2                      NA female           87\n## 3                    1644 female           78\n## 4                     501 female           63\n## 5                     660 female           41\n## 6                    3247 female           59\n## 7                      NA female           60\n## 8                      NA female           39\n## 9                    1876 female           54\n## 10                    707 female           51\n## 11                   5749 female           51\n## 12                     NA female           44\n## 13                   1972 female           64\n## 14                   1321 female           56\n## 15                    385 female           71\n## 16                   1800 female           71\n## 17                    214 female           63\n## 18                   1206 female           47\n## 19                   2442 female           54\n## 20                     NA female           36\n\n是不是很简单，注意点和excel一样。\n\n\n\n\n\n\n注释\n\n\n\nread.table()函数是一个通用的读取表格型数据的函数，它既可以读取csv文件，又可以读取txt文件，只要指定不同的分隔符即可。\n\n\n\n\n5.2.3 txt\ntxt文件也是我们常见的文件类型，通常这种数据也是可以直接读取的，不需要额外安装R包。\n现在我们有一个这样的txt文件，它看起来不规整，但其实是规整的哦，不要被表象迷惑，也千万不要试图用空格键把它对齐！！\n\n\n\ntxt文件\n\n\ntxt是tab键分隔的文件，在读取时，一定要指定分隔符：\n\ntmp &lt;- read.table(\"datasets/brca_clin.txt\",\n                  sep = \"\\t\", # 必须要指定分隔符：\\t，表示Tab键分隔\n                  header = T)\ntmp\n##                         barcode      patient           sample\n## 1  TCGA-BH-A1FC-11A-32R-A13Q-07 TCGA-BH-A1FC TCGA-BH-A1FC-11A\n## 2  TCGA-AC-A2FM-11B-32R-A19W-07 TCGA-AC-A2FM TCGA-AC-A2FM-11B\n## 3  TCGA-BH-A0DO-11A-22R-A12D-07 TCGA-BH-A0DO TCGA-BH-A0DO-11A\n## 4  TCGA-E2-A1BC-11A-32R-A12P-07 TCGA-E2-A1BC TCGA-E2-A1BC-11A\n## 5  TCGA-BH-A0BJ-11A-23R-A089-07 TCGA-BH-A0BJ TCGA-BH-A0BJ-11A\n## 6  TCGA-E2-A1LH-11A-22R-A14D-07 TCGA-E2-A1LH TCGA-E2-A1LH-11A\n## 7  TCGA-BH-A1FB-11A-33R-A13Q-07 TCGA-BH-A1FB TCGA-BH-A1FB-11A\n## 8  TCGA-BH-A18M-11A-33R-A12D-07 TCGA-BH-A18M TCGA-BH-A18M-11A\n## 9  TCGA-BH-A0BM-11A-12R-A089-07 TCGA-BH-A0BM TCGA-BH-A0BM-11A\n## 10 TCGA-E2-A153-11A-31R-A12D-07 TCGA-E2-A153 TCGA-E2-A153-11A\n## 11 TCGA-B6-A0RH-01A-21R-A115-07 TCGA-B6-A0RH TCGA-B6-A0RH-01A\n## 12 TCGA-BH-A1FU-01A-11R-A14D-07 TCGA-BH-A1FU TCGA-BH-A1FU-01A\n## 13 TCGA-AR-A0TX-01A-11R-A084-07 TCGA-AR-A0TX TCGA-AR-A0TX-01A\n## 14 TCGA-A1-A0SE-01A-11R-A084-07 TCGA-A1-A0SE TCGA-A1-A0SE-01A\n## 15 TCGA-OL-A5D6-01A-21R-A27Q-07 TCGA-OL-A5D6 TCGA-OL-A5D6-01A\n## 16 TCGA-E2-A1IK-01A-11R-A144-07 TCGA-E2-A1IK TCGA-E2-A1IK-01A\n## 17 TCGA-AN-A0FT-01A-11R-A034-07 TCGA-AN-A0FT TCGA-AN-A0FT-01A\n## 18 TCGA-A2-A3KD-01A-12R-A213-07 TCGA-A2-A3KD TCGA-A2-A3KD-01A\n## 19 TCGA-A2-A0EO-01A-11R-A034-07 TCGA-A2-A0EO TCGA-A2-A0EO-01A\n## 20 TCGA-A2-A04P-01A-31R-A034-07 TCGA-A2-A04P TCGA-A2-A04P-01A\n##            sample_type initial_weight ajcc_pathologic_stage\n## 1  Solid Tissue Normal            260             Stage IIA\n## 2  Solid Tissue Normal            220             Stage IIB\n## 3  Solid Tissue Normal            130               Stage I\n## 4  Solid Tissue Normal            260              Stage IA\n## 5  Solid Tissue Normal            200             Stage IIB\n## 6  Solid Tissue Normal             60               Stage I\n## 7  Solid Tissue Normal            320             Stage IIB\n## 8  Solid Tissue Normal            310            Stage IIIA\n## 9  Solid Tissue Normal            100             Stage IIB\n## 10 Solid Tissue Normal            250             Stage IIB\n## 11       Primary Tumor            130             Stage IIA\n## 12       Primary Tumor            110              Stage IA\n## 13       Primary Tumor            470             Stage IIA\n## 14       Primary Tumor             90               Stage I\n## 15       Primary Tumor            200             Stage IIA\n## 16       Primary Tumor             70             Stage IIA\n## 17       Primary Tumor            130             Stage IIB\n## 18       Primary Tumor            770            Stage IIIA\n## 19       Primary Tumor            200              Stage IA\n## 20       Primary Tumor            250            Stage IIIC\n##    days_to_last_follow_up gender age_at_index\n## 1                      NA female           78\n## 2                      NA female           87\n## 3                    1644 female           78\n## 4                     501 female           63\n## 5                     660 female           41\n## 6                    3247 female           59\n## 7                      NA female           60\n## 8                      NA female           39\n## 9                    1876 female           54\n## 10                    707 female           51\n## 11                   5749 female           51\n## 12                     NA female           44\n## 13                   1972 female           64\n## 14                   1321 female           56\n## 15                    385 female           71\n## 16                   1800 female           71\n## 17                    214 female           63\n## 18                   1206 female           47\n## 19                   2442 female           54\n## 20                     NA female           36\n\n\n\n5.2.4 tsv\n这个类型的文件也是以\\t为分隔符的，所以读取时和txt文件完全一样，使用read.table()函数即可，就不重复介绍了。\n\n\n5.2.5 SPSS\n如果是spss软件产生的.sav文件，可以使用foreign包中的read.spss()函数读取，或者使用haven包中的read_sav()函数。\n这两个包在使用前需要先安装，安装过程这里就不演示了。\n\n# foreign包读取\nlibrary(foreign)\nspss &lt;- foreign::read.spss(\"datasets/例03-05.sav\",to.data.frame = T)\n\nspss\n##    no  hb\n## 1   1 112\n## 2   2 137\n## 3   3 129\n## 4   4 126\n## 5   5  88\n## 6   6  90\n## 7   7 105\n## 8   8 178\n## 9   9 130\n## 10 10 128\n## 11 11 126\n## 12 12 103\n## 13 13 172\n## 14 14 116\n## 15 15 125\n## 16 16  90\n## 17 17  96\n## 18 18 162\n## 19 19 157\n## 20 20 151\n## 21 21 135\n## 22 22 113\n## 23 23 175\n## 24 24 129\n## 25 25 165\n## 26 26 171\n## 27 27 128\n## 28 28 128\n## 29 29 160\n## 30 30 110\n## 31 31 140\n## 32 32 163\n## 33 33 100\n## 34 34 129\n## 35 35 116\n## 36 36 127\n\n\n\n\n\n\n\n注释\n\n\n\n这里的foreign::read.spss()使用了包的名字::函数名字这种方法，意思是指定使用foreign中的read.spss()函数。有时候不同的R包中会有相同名字的函数，使用这种方法可以避免混淆。\n\n\n\n# haven包读取\nlibrary(haven)\nspss &lt;- read_sav(\"datasets/例03-05.sav\")\n\nspss\n## # A tibble: 36 × 2\n##       no    hb\n##    &lt;dbl&gt; &lt;dbl&gt;\n##  1     1   112\n##  2     2   137\n##  3     3   129\n##  4     4   126\n##  5     5    88\n##  6     6    90\n##  7     7   105\n##  8     8   178\n##  9     9   130\n## 10    10   128\n## # ℹ 26 more rows\n\n这个例子是比较简单的，有时候需要指定特定的编码方式，可以通过使用?read_sav/?read.spss查看更改编码的方式。\n\nhaven这个包是专门设计用来读取spss/SAS/STATA格式的文件的。\n\n\n\n5.2.6 rdata\n如果是rdata/Rdata/RData文件，这个是R自带的格式，大小写不影响，都能识别，直接load()即可，但是要注意一定要写对文件路径！或者也可以直接双击rdata/Rdata/RData文件，或者选中文件-单击鼠标右键-打开方式-选择Rstudio。\n如果要读取一个名字为brca_example.rdata的文件，它位于datasets这个文件夹（这个文件夹是和当前工作目录同一级的）中，可以使用以下代码：\n\n# 直接加载\nload(file = \"datasets/brca_example.rdata\")\n\n如果是rds文件，这个也是R常用的格式，使用readRDS()函数即可，也要注意文件路径。\n\n# 注意要取一个名字\ntmp &lt;- readRDS(file = \"datasets/brca_example.rds\") \n\n常见的就是这些，当你掌握这些简单的之后，你可以尝试更加复杂的，以后肯定也会遇到，不过有了这些简单的作为基础，相信你能更快的解决这类问题。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>导入导出文件</span>"
    ]
  },
  {
    "objectID": "05-导入导出文件.html#查看文件",
    "href": "05-导入导出文件.html#查看文件",
    "title": "5  导入导出文件",
    "section": "5.3 查看文件",
    "text": "5.3 查看文件\n下面是一些常用的用于帮助检查数据的函数（后面的章节还会继续介绍）：\n\ndim(brca_clin)       # 查看数据有多少行多少列，dim是dimension的缩写\n## [1] 20  9\nstr(brca_clin)       # 查看数据的结构，几行几列？数据类型？\n## 'data.frame':    20 obs. of  9 variables:\n##  $ barcode               : chr  \"TCGA-BH-A1FC-11A-32R-A13Q-07\" \"TCGA-AC-A2FM-11B-32R-A19W-07\" \"TCGA-BH-A0DO-11A-22R-A12D-07\" \"TCGA-E2-A1BC-11A-32R-A12P-07\" ...\n##  $ patient               : chr  \"TCGA-BH-A1FC\" \"TCGA-AC-A2FM\" \"TCGA-BH-A0DO\" \"TCGA-E2-A1BC\" ...\n##  $ sample                : chr  \"TCGA-BH-A1FC-11A\" \"TCGA-AC-A2FM-11B\" \"TCGA-BH-A0DO-11A\" \"TCGA-E2-A1BC-11A\" ...\n##  $ sample_type           : chr  \"Solid Tissue Normal\" \"Solid Tissue Normal\" \"Solid Tissue Normal\" \"Solid Tissue Normal\" ...\n##  $ initial_weight        : num  260 220 130 260 200 60 320 310 100 250 ...\n##  $ ajcc_pathologic_stage : chr  \"Stage IIA\" \"Stage IIB\" \"Stage I\" \"Stage IA\" ...\n##  $ days_to_last_follow_up: int  NA NA 1644 501 660 3247 NA NA 1876 707 ...\n##  $ gender                : chr  \"female\" \"female\" \"female\" \"female\" ...\n##  $ age_at_index          : int  78 87 78 63 41 59 60 39 54 51 ...\nclass(brca_clin)     # 数据类型\n## [1] \"data.frame\"\ncolnames(brca_clin)  # 查看列名\n## [1] \"barcode\"                \"patient\"                \"sample\"                \n## [4] \"sample_type\"            \"initial_weight\"         \"ajcc_pathologic_stage\" \n## [7] \"days_to_last_follow_up\" \"gender\"                 \"age_at_index\"\nnames(brca_clin)     # 查看列名\n## [1] \"barcode\"                \"patient\"                \"sample\"                \n## [4] \"sample_type\"            \"initial_weight\"         \"ajcc_pathologic_stage\" \n## [7] \"days_to_last_follow_up\" \"gender\"                 \"age_at_index\"\nrownames(brca_clin)  # 查看行名\n##  [1] \"TCGA-BH-A1FC-11A-32R-A13Q-07\" \"TCGA-AC-A2FM-11B-32R-A19W-07\"\n##  [3] \"TCGA-BH-A0DO-11A-22R-A12D-07\" \"TCGA-E2-A1BC-11A-32R-A12P-07\"\n##  [5] \"TCGA-BH-A0BJ-11A-23R-A089-07\" \"TCGA-E2-A1LH-11A-22R-A14D-07\"\n##  [7] \"TCGA-BH-A1FB-11A-33R-A13Q-07\" \"TCGA-BH-A18M-11A-33R-A12D-07\"\n##  [9] \"TCGA-BH-A0BM-11A-12R-A089-07\" \"TCGA-E2-A153-11A-31R-A12D-07\"\n## [11] \"TCGA-B6-A0RH-01A-21R-A115-07\" \"TCGA-BH-A1FU-01A-11R-A14D-07\"\n## [13] \"TCGA-AR-A0TX-01A-11R-A084-07\" \"TCGA-A1-A0SE-01A-11R-A084-07\"\n## [15] \"TCGA-OL-A5D6-01A-21R-A27Q-07\" \"TCGA-E2-A1IK-01A-11R-A144-07\"\n## [17] \"TCGA-AN-A0FT-01A-11R-A034-07\" \"TCGA-A2-A3KD-01A-12R-A213-07\"\n## [19] \"TCGA-A2-A0EO-01A-11R-A034-07\" \"TCGA-A2-A04P-01A-31R-A034-07\"\nhead(brca_clin)      # 查看前6行数据\n##                                                   barcode      patient\n## TCGA-BH-A1FC-11A-32R-A13Q-07 TCGA-BH-A1FC-11A-32R-A13Q-07 TCGA-BH-A1FC\n## TCGA-AC-A2FM-11B-32R-A19W-07 TCGA-AC-A2FM-11B-32R-A19W-07 TCGA-AC-A2FM\n## TCGA-BH-A0DO-11A-22R-A12D-07 TCGA-BH-A0DO-11A-22R-A12D-07 TCGA-BH-A0DO\n## TCGA-E2-A1BC-11A-32R-A12P-07 TCGA-E2-A1BC-11A-32R-A12P-07 TCGA-E2-A1BC\n## TCGA-BH-A0BJ-11A-23R-A089-07 TCGA-BH-A0BJ-11A-23R-A089-07 TCGA-BH-A0BJ\n## TCGA-E2-A1LH-11A-22R-A14D-07 TCGA-E2-A1LH-11A-22R-A14D-07 TCGA-E2-A1LH\n##                                        sample         sample_type\n## TCGA-BH-A1FC-11A-32R-A13Q-07 TCGA-BH-A1FC-11A Solid Tissue Normal\n## TCGA-AC-A2FM-11B-32R-A19W-07 TCGA-AC-A2FM-11B Solid Tissue Normal\n## TCGA-BH-A0DO-11A-22R-A12D-07 TCGA-BH-A0DO-11A Solid Tissue Normal\n## TCGA-E2-A1BC-11A-32R-A12P-07 TCGA-E2-A1BC-11A Solid Tissue Normal\n## TCGA-BH-A0BJ-11A-23R-A089-07 TCGA-BH-A0BJ-11A Solid Tissue Normal\n## TCGA-E2-A1LH-11A-22R-A14D-07 TCGA-E2-A1LH-11A Solid Tissue Normal\n##                              initial_weight ajcc_pathologic_stage\n## TCGA-BH-A1FC-11A-32R-A13Q-07            260             Stage IIA\n## TCGA-AC-A2FM-11B-32R-A19W-07            220             Stage IIB\n## TCGA-BH-A0DO-11A-22R-A12D-07            130               Stage I\n## TCGA-E2-A1BC-11A-32R-A12P-07            260              Stage IA\n## TCGA-BH-A0BJ-11A-23R-A089-07            200             Stage IIB\n## TCGA-E2-A1LH-11A-22R-A14D-07             60               Stage I\n##                              days_to_last_follow_up gender age_at_index\n## TCGA-BH-A1FC-11A-32R-A13Q-07                     NA female           78\n## TCGA-AC-A2FM-11B-32R-A19W-07                     NA female           87\n## TCGA-BH-A0DO-11A-22R-A12D-07                   1644 female           78\n## TCGA-E2-A1BC-11A-32R-A12P-07                    501 female           63\n## TCGA-BH-A0BJ-11A-23R-A089-07                    660 female           41\n## TCGA-E2-A1LH-11A-22R-A14D-07                   3247 female           59\ntail(brca_clin)      # 查看最后6行数据\n##                                                   barcode      patient\n## TCGA-OL-A5D6-01A-21R-A27Q-07 TCGA-OL-A5D6-01A-21R-A27Q-07 TCGA-OL-A5D6\n## TCGA-E2-A1IK-01A-11R-A144-07 TCGA-E2-A1IK-01A-11R-A144-07 TCGA-E2-A1IK\n## TCGA-AN-A0FT-01A-11R-A034-07 TCGA-AN-A0FT-01A-11R-A034-07 TCGA-AN-A0FT\n## TCGA-A2-A3KD-01A-12R-A213-07 TCGA-A2-A3KD-01A-12R-A213-07 TCGA-A2-A3KD\n## TCGA-A2-A0EO-01A-11R-A034-07 TCGA-A2-A0EO-01A-11R-A034-07 TCGA-A2-A0EO\n## TCGA-A2-A04P-01A-31R-A034-07 TCGA-A2-A04P-01A-31R-A034-07 TCGA-A2-A04P\n##                                        sample   sample_type initial_weight\n## TCGA-OL-A5D6-01A-21R-A27Q-07 TCGA-OL-A5D6-01A Primary Tumor            200\n## TCGA-E2-A1IK-01A-11R-A144-07 TCGA-E2-A1IK-01A Primary Tumor             70\n## TCGA-AN-A0FT-01A-11R-A034-07 TCGA-AN-A0FT-01A Primary Tumor            130\n## TCGA-A2-A3KD-01A-12R-A213-07 TCGA-A2-A3KD-01A Primary Tumor            770\n## TCGA-A2-A0EO-01A-11R-A034-07 TCGA-A2-A0EO-01A Primary Tumor            200\n## TCGA-A2-A04P-01A-31R-A034-07 TCGA-A2-A04P-01A Primary Tumor            250\n##                              ajcc_pathologic_stage days_to_last_follow_up\n## TCGA-OL-A5D6-01A-21R-A27Q-07             Stage IIA                    385\n## TCGA-E2-A1IK-01A-11R-A144-07             Stage IIA                   1800\n## TCGA-AN-A0FT-01A-11R-A034-07             Stage IIB                    214\n## TCGA-A2-A3KD-01A-12R-A213-07            Stage IIIA                   1206\n## TCGA-A2-A0EO-01A-11R-A034-07              Stage IA                   2442\n## TCGA-A2-A04P-01A-31R-A034-07            Stage IIIC                     NA\n##                              gender age_at_index\n## TCGA-OL-A5D6-01A-21R-A27Q-07 female           71\n## TCGA-E2-A1IK-01A-11R-A144-07 female           71\n## TCGA-AN-A0FT-01A-11R-A034-07 female           63\n## TCGA-A2-A3KD-01A-12R-A213-07 female           47\n## TCGA-A2-A0EO-01A-11R-A034-07 female           54\n## TCGA-A2-A04P-01A-31R-A034-07 female           36\nrm(brca_clin)        # 从当前环境（environment）中清除对象",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>导入导出文件</span>"
    ]
  },
  {
    "objectID": "05-导入导出文件.html#保存文件",
    "href": "05-导入导出文件.html#保存文件",
    "title": "5  导入导出文件",
    "section": "5.4 保存文件",
    "text": "5.4 保存文件\n保存文件我觉得比读取文件要简单一点，如果你实在不知道怎么保存，有个简便方法，在Environment面板中有个保存按钮，点击即可保存所有对象到RData文件中：\n\n\n\n一键保存所有\n\n\n直接点击保存，就会在你当前工作目录产生一个RData文件，下次直接load或者双击即可快速打开你的所有东西！不过不建议这么做，因为这个RData文件可能会很大。\n不太推荐直接保存为excel格式，建议使用csv格式。\n如果是想把tmp这个对象保存为csv文件，可以使用write.csv()或者write.table()，write.table()和read.table()类似，也是可以把文件保存为多种格式，只需要指定分隔符即可。\n\n# 把tmp这个数据框保存为csv\nwrite.csv(tmp, # 要保存的对象\n          file = \"datasets/111.csv\", #保存到哪里？格式？ .csv不要忘记！\n          quote = F, # 不加引号\n          row.names = F # 有没有行名\n          )\n\n# 或者使用write.table\nwrite.table(tmp,\n            file = \"datasets/111.csv\", #保存到哪里，保存为什么格式，.csv不要忘记！\n            sep = \",\",  # 必须指定分隔符！\n            quote = F, # 不加引号\n            row.names = F, # 行名\n            col.names = T # 列名\n            )\n\n如果要保存为或者txt文件，也可以使用write.table()：\n\nwrite.table(tmp,\n            file = \"datasets/222.txt\",\n            sep = \"\\t\", # 千万别忘记指定分隔符！\n            quote = F, # 不加引号\n            row.names = F, # 行名\n            col.names = T # 列名\n            )\n\n如果要保存为rdata/Rdata/RData文件，直接用save()函数，简单方便，下次直接load即可，还可以同时保存多个对象！！\n推荐大家平时保存时选择rdata/Rdata/RData/rds，方便，官方！\n\nsave(tmp,csv, # 同时保存多个对象\n     file = \"datasets/tmp1.rdata\") # 保存文件的位置和名字\n\n保存为rds格式：\n\n# rds格式不能同时保存多个对象\nsaveRDS(tmp, file = \"datasets/tmp.rds\")\n\n以上就是常见的数据读取和保存，最后再说一遍注意点：\n\n输入法需要是英文状态下的标点符号！\n文件路径必须写对！\n注意不同文件的分隔符！\n不同文件使用不同函数读取/写出！不要所有的格式都用一个函数！\n如果碰到不知道的格式读取，直接百度！99.999%能解决你的问题！\n\n希望大家以后再也不要碰到数据读取问题！\n数据读取之后，下一步就是对数据进行各种各样的操作，这也是R语言中最重要的基础知识。不过在学习数据操作之前，我们先学习一下R语言中的数据类型和数据结构。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>导入导出文件</span>"
    ]
  },
  {
    "objectID": "06-R中的数据类型.html",
    "href": "06-R中的数据类型.html",
    "title": "6  数据类型",
    "section": "",
    "text": "6.1 双精度型\n其实就是小数型：\n# 把一个数字存储到变量my_integer中\nmy_integer &lt;- 5\n\n# 查看数据类型\ntypeof(my_integer)\n## [1] \"double\"\n\n# 把一个小数存储到变量my_float中\nmy_float &lt;- 3.14\ntypeof(my_float) # 查看数据类型\n## [1] \"double\"\n虽然数字5没有小数点，但是它此时依然是double类型。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据类型</span>"
    ]
  },
  {
    "objectID": "06-R中的数据类型.html#整数型",
    "href": "06-R中的数据类型.html#整数型",
    "title": "6  数据类型",
    "section": "6.2 整数型",
    "text": "6.2 整数型\n整数型也是表示数字的，没有小数点，但是需要在结尾添加L才行：\n\ninteger_variable &lt;- 186L\ntypeof((integer_variable))\n## [1] \"integer\"\n\n其中double和integer被统称为数值型（numeric）。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据类型</span>"
    ]
  },
  {
    "objectID": "06-R中的数据类型.html#字符型",
    "href": "06-R中的数据类型.html#字符型",
    "title": "6  数据类型",
    "section": "6.3 字符型",
    "text": "6.3 字符型\n是表示文本的一种方式，通常用引号引起来的都是字符型，双引号或者单引号都可以，但必须是英文状态下的引号：\n\n# 把一段文字存储到变量中\nmy_string &lt;- \"Hello, R!\"\n\n# 打印结果\nprint(my_string)\n## [1] \"Hello, R!\"\n\n# 查看类型\ntypeof(my_string)\n## [1] \"character\"",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据类型</span>"
    ]
  },
  {
    "objectID": "06-R中的数据类型.html#逻辑型",
    "href": "06-R中的数据类型.html#逻辑型",
    "title": "6  数据类型",
    "section": "6.4 逻辑型",
    "text": "6.4 逻辑型\n又称为布尔型（boolean），用来表示是或否，只能是TRUE（是）或FALSE（否），而且不能加引号，加了引号就变成字符型了，TRUE可以简写为T，FALSE可以简写为F。\n\n# 把一个逻辑值存储到变量中\nmy_logical &lt;- TRUE\ntypeof(my_logical)\n## [1] \"logical\"\n\n逻辑值是可以运算的，高中都学过的：\n\nTRUE + TRUE # 当成加减运算时，TRUE是1，FALSE是0！\n## [1] 2\nTRUE - FALSE\n## [1] 1\n\n还有一些逻辑运算符：与，或，非：\n与：&\n或：|\n非：!\n等于：==  # 这个要特别注意，R语言中的等于是两个等号！！！\n不等于：!= # 很少用\n大于：&gt;\n大于等于：&gt;=\n小于：&lt;\n小于等于：&lt;=\n这些逻辑运算和高中学过的内容是完全一样的，比如：\n\nTRUE | FALSE\n## [1] TRUE\nTRUE & FALSE\n## [1] FALSE",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据类型</span>"
    ]
  },
  {
    "objectID": "06-R中的数据类型.html#类型判断",
    "href": "06-R中的数据类型.html#类型判断",
    "title": "6  数据类型",
    "section": "6.5 类型判断",
    "text": "6.5 类型判断\nis.numeric()   # 是不是数值型\nis.character() # 是不是字符型\nis.double()    # 是不是双精度型\nis.integer()   # 是不是整数型\n#is.factor()    # 是不是因子型\nis.complex()   # 是不是复数性\nis.logical()   # 是不是逻辑型",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据类型</span>"
    ]
  },
  {
    "objectID": "06-R中的数据类型.html#数据集",
    "href": "06-R中的数据类型.html#数据集",
    "title": "6  数据类型",
    "section": "6.6 数据集",
    "text": "6.6 数据集\n数据集通常是由不同类型的数据构成的一个矩形格式，每一行表示一个观测（observation），每一列表示一个变量（variable），我们用的最多的数据集是表格型（tabular）的结构，下表是一个医学中常见的病例数据集演示：\n\n不同的行业对于数据集的行和列叫法不同（观测和变量的叫法是最常用的，大家一定要记住）。统计学家称它们为观测（observation）和变量（variable），数据库分析师则称其为记录（record）和字段（field），数据挖掘和机器学习的研究者则把它们叫作示例（example）和属性（attribute）。\n在上表所示的数据集中，PatientID是行标识符（row-identifier）（或者叫“行名”），行名是不能有重复的；AdmDate是日期型变量，Age是连续型变量，Diabetes是名义型变量，Status是有序型变量。\nR中有许多用于存储数据的结构，包括标量、向量、数组、数据框和列表等。上表的结构实际上是R中的数据框（data.frame）。多样化的数据结构赋予了R极其灵活的数据处理能力。\n在上表中，AdmDate和Age为数值型（numeric）变量，而Diabetes和Status则为字符型（character）变量。R将实例标识符称为rowmames（行名），将类别型（包括名义型和有序型）变量称为因子（factors）。我们会在下一章中讲解这些内容。",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>数据类型</span>"
    ]
  },
  {
    "objectID": "07-数据结构.html",
    "href": "07-数据结构.html",
    "title": "7  数据结构",
    "section": "",
    "text": "7.1 向量\n向量，vector，就是同一类型的多个元素构成的序列，可以是数值型、字符型、逻辑型等。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "07-数据结构.html#向量",
    "href": "07-数据结构.html#向量",
    "title": "7  数据结构",
    "section": "",
    "text": "7.1.1 创建向量\n在R中，最基本的创建向量的方法是使用函数c()：\n\n# 创建一个名字是a的向量\na &lt;- c(1, 2, 5, 3, 6, -2, 4)\nclass(a) # 查看类型\n## [1] \"numeric\"\n\n# 创建一个名字是b的向量，字符型一定要加引号！\nb &lt;- c(\"one\", \"two\", \"three\")\n\n# 创建一个名字是d的向量，不用c是为了避免和函数 c() 混淆\nd &lt;- c(TRUE, TRUE, TRUE, FALSE, TRUE, FALSE)\n\n这里，a是数值型向量，b是字符型向量，而d是逻辑型向量。向量中的值被称为元素（element），比如向量a的第一个元素是1，向量b的第一个元素是\"one\"。\n\n\n\n\n\n\n注释\n\n\n\n在给对象命名时要注意不要和一些函数或者表示特定意义的字符用相同的名字，比如c/T/F/TRUE/FALSE等等，并且最好不要使用-，因为-在R语言中表示减号，容易引起报错，更推荐大家使用_。\n除此之外还有一个初学者经常会遇到的报错是：Error: unexpected xxx（中文报错：错误：意外的xxx），多数情况下是由于标点符号导致的，比如：标点符号不是英文状态下的、没有配对，或者名字拼错、大小写拼错等原因，需认真仔细检查自己的代码。\n\n\n注意，单个向量中的数据有相同的类型或模式（数值型、字符型或逻辑型）。同一向量中无法混杂不同类型的数据。比如：\n\n# 会都变成字符型\na &lt;- c(\"a\",1,TRUE)\na\n## [1] \"a\"    \"1\"    \"TRUE\"\n\n除了通过c()创建向量，还可以使用seq()（sequence的缩写）创建数值型的向量，比如，创建一个从1~20的向量，并且步长设置为2：\n\n# 从1到20，中间间隔2\nseq(1, 20, 2)\n##  [1]  1  3  5  7  9 11 13 15 17 19\n\n重复某个值也可以得到一个向量：\n\n# rep是replicate的缩写\nrep(1:2, times = 3) # 重复1 2 三次\n## [1] 1 2 1 2 1 2\nrep(1:2, each = 3)  # 重复1三次，重复2三次\n## [1] 1 1 1 2 2 2\n\n或者最简单的方法，使用数字和冒号，生成连续的数字：\n\n1:5\n## [1] 1 2 3 4 5\n\n\n\n\n\n\n\n提示\n\n\n\n标量是只含一个元素的向量，例如f &lt;- 3、g &lt;- “US”和h &lt;- TRUE。它们用于保存常量。\n\n\n\n\n7.1.2 探索向量\n查看向量长度：\n\nlength(d)\n## [1] 6\n\n查看前6行/后6行：\n\nhead(seq(1, 20, 2))\n## [1]  1  3  5  7  9 11\ntail(seq(1, 20, 2))\n## [1]  9 11 13 15 17 19\n\n查看唯一元素：\n\na &lt;- c(1,2,2,3,4,4,4)\n\n# 查看唯一元素\nunique(a)\n## [1] 1 2 3 4\n\n查看一共有几种不同的元素，以及每个元素的个数，也就是计数：\n\ntable(a)\n## a\n## 1 2 3 4 \n## 1 2 1 3\n\n\n\n7.1.3 根据位置选择向量元素\n通过在方括号中指定元素的位置，我们可以访问（或者叫提取、查看）向量中的某个元素。例如：a[c(2, 4)]用于提取向量a中的第二个和第四个元素。更多示例如下：\n\n# 创建一个向量，取名为a\na &lt;- c(1, 2, 5, 3, 6, -2, 4)\n\na[3] # 取第3个元素\n## [1] 5\na[c(1,3,5)] # 取第1，3，5个元素\n## [1] 1 5 6\n\na[c(1:3)] # 取第1到第3个元素\n## [1] 1 2 5\na[c(1, 2, 3)] # 和上面结果相同，也是取第1到第3个元素\n## [1] 1 2 5\n\n如果提取不存在的位置，则会返回NA，比如我们提取第10个元素：\n\na[10]\n## [1] NA\n\nNA表示“Not Available”，NA是R语言中一种特殊的类型，常用来表示数据缺失。\n如何把提取出来的元素保存为另一个变量呢？比如把a里面的第一个元素保存为变量b？直接赋值即可：\n\n# 提取，赋值，即可\nb &lt;- a[1]\nb\n## [1] 1\n\n\n\n7.1.4 替换、删除、增加\n如果要替换某个元素，直接提取这个元素并赋予要替换的值即可：\n\na &lt;- c(1, 2, 5, 3, 6, -2, 4)\n\n# 把向量a的第1个元素换成 m\na[1] &lt;- \"m\"\na # 注意，此时全部变成字符型了哦！\n## [1] \"m\"  \"2\"  \"5\"  \"3\"  \"6\"  \"-2\" \"4\"\n\n# 同时替换多个元素，注意长度要相同，并且要使用c()放在一个向量中\na[c(1,3,4)] &lt;- c(\"d\",\"e\",\"f\")\na\n## [1] \"d\"  \"2\"  \"e\"  \"f\"  \"6\"  \"-2\" \"4\"\n\n如果要删除某个元素，直接在位置前加负号即可：\n\na &lt;- c(1, 2, 5, 3, 6, -2, 4)\n\n# 删除a的第一个元素，结果中第一个元素 1 就被删掉了\na[-1]\n## [1]  2  5  3  6 -2  4\n\n# 但此时你打印a会发现a还是1, 2, 5, 3, 6, -2, 4，\na\n## [1]  1  2  5  3  6 -2  4\n\n# 如果要获得修改后的a，一定要重新赋值！\na &lt;- a[-1]\na # 此时a就是修改后的了\n## [1]  2  5  3  6 -2  4\n\n# 同时删除多个元素\na &lt;- c(1, 2, 5, 3, 6, -2, 4)\n\n# 直接把要删除的元素位置放在c()中即可\na[c(-1,-2,-3)]\n## [1]  3  6 -2  4\n\n# 如果要获得修改后的a，一定要重新赋值！\na &lt;- a[c(-1,-2,-3)]\na\n## [1]  3  6 -2  4\n\n如果要继续增加元素，直接使用c()即可：\n\n# 在向量a中添加3个元素，并赋值给a1\n# 注意由于\"80\", \"89\", \"90\"都加了引号，所以修改后的a都变成了字符型\na1 &lt;- c(a, \"80\", \"89\", \"90\")\na1\n## [1] \"3\"  \"6\"  \"-2\" \"4\"  \"80\" \"89\" \"90\"\n\n\n\n7.1.5 根据名字选择向量元素\n还可以对向量中的每一个元素取一个名字，比如：\n\n# 创建一个命名向量，别用-，更推荐用_\nnamed_a &lt;- c(age = 18, bmi = 22, weight = 65)\nnamed_a\n##    age    bmi weight \n##     18     22     65\n\n此时，向量named_a中的3个元素，都有一个独一无二的名字，此时我们还可以通过向量的名字来访问对应的元素：\n\nnamed_a[\"age\"]\n## age \n##  18\n\nnamed_a[\"bmi\"]\n## bmi \n##  22\n\n查看每个元素的名字（如果这是一个命名向量的话）：\n\nnames(named_a)\n## [1] \"age\"    \"bmi\"    \"weight\"\n\n替换元素的名字：\n\n# 替换第一个元素的名字，从age变为height\nnames(named_a)[1] &lt;- \"height\"\nnamed_a\n## height    bmi weight \n##     18     22     65\n\n# 同时替换多个元素的名字\nnames(named_a)[c(1,2)] &lt;- c(\"height\",\"gg\")\n#names(named_a)[1:2] &lt;- c(\"height\",\"gg\")\nnamed_a\n## height     gg weight \n##     18     22     65\n\n# 同时替换所有元素的名字\nnames(named_a) &lt;- c(\"aa\",\"bb\",\"cc\")\nnamed_a\n## aa bb cc \n## 18 22 65\n\n移除元素的名字：\n\n# 移除元素的名字，注意不能只移除某个元素的名字，要一起移除\nnames(named_a) &lt;- NULL\nnamed_a\n## [1] 18 22 65\n\n\n\n7.1.6 根据表达式选择向量元素\n除了通过位置和名字选择元素外，还可以通过表达式（也就是TRUE或者FALSE）：\n\na &lt;- c(1,2,3,10,11)\n\na[a==10] # 选择等于10的元素\n## [1] 10\na[a&lt;5]   # 选择小于5的元素\n## [1] 1 2 3\na[a %in% c(2,3,11)]  # 选择在(2,3,11)里面的元素，很常用\n## [1]  2  3 11\n\n\n\n7.1.7 向量排序\n如果要对向量排序：\n\n# 创建一个向量a\na &lt;- c(4,1,2,3)\na\n## [1] 4 1 2 3\n\n# 排序，默认按照从小到大\nsort(a)\n## [1] 1 2 3 4\n\n# 按照从大到小的顺序排列\nsort(a, decreasing = T)\n## [1] 4 3 2 1\n\n# 反转顺序\nrev(a)\n## [1] 3 2 1 4\n\norder函数返回的是向量元素的一个排列索引，它不是直接对数据进行排序，而是告诉你如何对数据进行排序。\n\na &lt;- c(4,1,2,3)\na\n## [1] 4 1 2 3\norder(a)\n## [1] 2 3 4 1\n\norder(a)的结果中，第一个数字是2，意思是：原向量a中的第2个元素（也就是1）应该放在第1位，第2个数字是3，意思是：原向量中的第3个元素（也就是2）应该放在第2位…\n所以order返回的是原始向量排序后的位置，我们就可以使用这些位置对向量进行排序：\n\n# 默认从小到大\na[order(a)] # 等价于sort(a)\n## [1] 1 2 3 4\n\n也可以从大到小：\n\na[order(a, decreasing = T)]\n## [1] 4 3 2 1\n\n\n\n7.1.8 去重复\n\na &lt;- c(1,2,2,3,4,4,4)\n\n# 查看是否有重复\nduplicated(a)\n## [1] FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE\n\n!表示“非”，也就是反向选择：\n\n!duplicated(a)\n## [1]  TRUE  TRUE FALSE  TRUE  TRUE FALSE FALSE\n\n通过反向选择的方式去重，非常重要的方法：\n\n# 通过反选的方式去重，很重要,!表示反选\na[!duplicated(a)]\n## [1] 1 2 3 4\n\n\n\n7.1.9 两个向量的操作\n取两个向量的交集、并集、差集。\n假设有两个向量如下：\n\na &lt;- c(1,2,3,4)\nb &lt;- c(1,2,3,5,6)\n\n取两个向量中共有的元素（交集）：\n\nintersect(a,b)\n## [1] 1 2 3\n\n取并集：\n\nunion(a,b)\n## [1] 1 2 3 4 5 6\n\n取向量a有但是b没有的元素（差集）：\n\nsetdiff(a,b)\n## [1] 4\n\n取向量b有但是a没有的元素（差集）：\n\nsetdiff(b,a)\n## [1] 5 6",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "07-数据结构.html#数据框",
    "href": "07-数据结构.html#数据框",
    "title": "7  数据结构",
    "section": "7.2 数据框",
    "text": "7.2 数据框\n数据框，data.frame，可能是大家最常用的数据结构了。我们的excel数据读进来一般默认都是数据框结构。\n数据框由不同的行和列构成，不同的列可以是不同类型（数值型、字符型、逻辑型等）的数据，比如可以其中一列是数值型，另一列是逻辑型，另一列是字符型，等。但是同一列中必须是相同的类型。\n\n7.2.1 创建数据框\n数据框可通过函数data.frame()创建，使用方式如下：\n\nmydata &lt;- data.frame(col1, col2, col3,...)\n\n其中的列向量col1、col2、col3等可为任何类型（如字符型、数值型或逻辑型）。\n以下代码会创建一个数据框，这个数据框有4列，第一列的名字是patientID，是数值型；第二列的名字是age，也是数值型；第三列的名字是diabetes，是字符型；第4列的名字是status，也是字符型：\n\n# 创建4个向量\npatientID &lt;- c(1, 2, 3, 4)\nage &lt;- c(25, 34, 28, 52)\ndiabetes &lt;- c(\"Type1\", \"Type2\", \"Type1\", \"Type1\")\nstatus &lt;- c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\")\n\n# 把4个向量放到一个数据框中\npatientdata &lt;- data.frame(patientID, age, diabetes, status)\npatientdata\n##   patientID age diabetes    status\n## 1         1  25    Type1      Poor\n## 2         2  34    Type2  Improved\n## 3         3  28    Type1 Excellent\n## 4         4  52    Type1      Poor\n\n我们首先建立了4个向量，然后使用函数data.frame()将4个向量组合在一起，就变成了一个数据框data.frame，所以你也可以把数据框看成是多个向量的组合。\n当你对这个操作足够熟悉后，你也可以直接这样写：\n\npatientdata &lt;- data.frame(\n  patientID = c(1, 2, 3, 4), \n  age = c(25, 34, 28, 52), \n  diabetes = c(\"Type1\", \"Type2\", \"Type1\", \"Type1\"), \n  status = c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\")\n  )\n\npatientdata\n##   patientID age diabetes    status\n## 1         1  25    Type1      Poor\n## 2         2  34    Type2  Improved\n## 3         3  28    Type1 Excellent\n## 4         4  52    Type1      Poor\nclass(patientdata)\n## [1] \"data.frame\"\n\n上一章中从外部读取的数据，默认就是数据框结构：\n\nlibrary(readxl)\nbrca_expr &lt;- read_xlsx(\"datasets/brca_expr.xlsx\", col_names = T)\n\nclass(brca_expr)\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\n\n\n\n注释\n\n\n\nreadxl是tidyverse系列R包的一员，如果你使用了这个系列的R包，那么默认的数据框就不再单单是data.frame类型，还会增加tbl_df和tbl类型，这会在某些操作中报错，千万要注意。\n\n\n如何变成单纯的data.frame类型？只需要使用as.data.frame()函数即可：\n\n# 转换类型\nbrca_expr &lt;- as.data.frame(brca_expr)\nclass(brca_expr) # 查看类型\n## [1] \"data.frame\"\n\n\n\n7.2.2 探索数据框\n查看数据框的基本信息，比如，有几行几列？每一列是什么类型？列名是什么？\n\n# 像Excel一样查看数据框，注意，数据太大会直接卡死\nView(patientdata) # 或者在环境面板中直接点击数据框名字\n\n# 查看类型\nclass(patientdata) # 数据框\n## [1] \"data.frame\"\n\n# 查看数据框的维度，dim是dimension的缩写\ndim(patientdata)\n## [1] 4 4\n\n# 查看几行几列\nncol(patientdata)\n## [1] 4\nnrow(patientdata)\n## [1] 4\n\n# 查看数据框的结构：str是structure的缩写\nstr(patientdata)\n## 'data.frame':    4 obs. of  4 variables:\n##  $ patientID: num  1 2 3 4\n##  $ age      : num  25 34 28 52\n##  $ diabetes : chr  \"Type1\" \"Type2\" \"Type1\" \"Type1\"\n##  $ status   : chr  \"Poor\" \"Improved\" \"Excellent\" \"Poor\"\n\n# 查看前6行和最后6行\nhead(patientdata)\n##   patientID age diabetes    status\n## 1         1  25    Type1      Poor\n## 2         2  34    Type2  Improved\n## 3         3  28    Type1 Excellent\n## 4         4  52    Type1      Poor\ntail(patientdata)\n##   patientID age diabetes    status\n## 1         1  25    Type1      Poor\n## 2         2  34    Type2  Improved\n## 3         3  28    Type1 Excellent\n## 4         4  52    Type1      Poor\n\n# 默认是6行，可以更改，比如改成2行\nhead(patientdata, 2)\n##   patientID age diabetes   status\n## 1         1  25    Type1     Poor\n## 2         2  34    Type2 Improved\n\n# 查看数据框的列名\nnames(patientdata)\n## [1] \"patientID\" \"age\"       \"diabetes\"  \"status\"\n\n# 或者使用以下方法查看列名\ncolnames(patientdata)\n## [1] \"patientID\" \"age\"       \"diabetes\"  \"status\"\n\n# 查看行名\nrownames(patientdata)  \n## [1] \"1\" \"2\" \"3\" \"4\"\n\n# 总结数据信息，摘要\nsummary(patientdata)\n##    patientID         age          diabetes            status         \n##  Min.   :1.00   Min.   :25.00   Length:4           Length:4          \n##  1st Qu.:1.75   1st Qu.:27.25   Class :character   Class :character  \n##  Median :2.50   Median :31.00   Mode  :character   Mode  :character  \n##  Mean   :2.50   Mean   :34.75                                        \n##  3rd Qu.:3.25   3rd Qu.:38.50                                        \n##  Max.   :4.00   Max.   :52.00\n\n\n\n7.2.3 行列选择\n如果我们要选择其中的某些行或者某些列，或者某个元素（比如，第2行第3列的值），有多种不同的方法实现。\n可以通过方括号实现，就像访问向量的元素一样。\n数据框和向量不一样，向量是一维的，数据框既有行也有列，数据框是二维的，所以在使用方括号时，我们也要指定行和列，行和列之间用,隔开，,前面表示行，后面表示列。\n以下是常见方法，必须要记住：\n\npatientdata[1, 2] # 取第1行第2列的值 \n## [1] 25\n\npatientdata[1:2,] # 取第1行到第2行，以及所有列，省略数字就是取所有\n##   patientID age diabetes   status\n## 1         1  25    Type1     Poor\n## 2         2  34    Type2 Improved\n\npatientdata[, 1:3] # 取所有行，以及第1列到第3列\n##   patientID age diabetes\n## 1         1  25    Type1\n## 2         2  34    Type2\n## 3         3  28    Type1\n## 4         4  52    Type1\n\npatientdata[c(1,4), c(1,3)] # 取第1行和第4行，以及第1列和第3列\n##   patientID diabetes\n## 1         1    Type1\n## 4         4    Type1\n\n如果你在方括号中不写,，那么默认是选取其中的列和所有行：\n\npatientdata[c(1,3)] # 取第1列和第3列，所有的行\n##   patientID diabetes\n## 1         1    Type1\n## 2         2    Type2\n## 3         3    Type1\n## 4         4    Type1\n\n除了使用数字序号这种，也可以直接使用列名进行选取（是不是和向量操作非常像？）：\n\npatientdata[, \"patientID\"] # 取patientID这一列和所有的行 ,可省略，下面的也是\n## [1] 1 2 3 4\npatientdata[, c(\"patientID\", \"diabetes\")] # 取patientID和diabetes两列及所有行\n##   patientID diabetes\n## 1         1    Type1\n## 2         2    Type2\n## 3         3    Type1\n## 4         4    Type1\n\n除了使用方括号，还可以使用美元符号$选取列：\n\n# 选取patientID这一列\npatientdata$patientID\n## [1] 1 2 3 4\n\n如果要同时选择部分行和列，还有一个专门的函数subset()：\n\nsubset(patientdata, # 数据\n       age &gt; 30, # 选择行，age&gt;30的行\n       select = c(\"patientID\",\"diabetes\",\"age\") # 选择列\n       )\n##   patientID diabetes age\n## 2         2    Type2  34\n## 4         4    Type1  52\n\npatientdata这个数据集有4列，每一列都有一个列名，我们可以通过列名很轻松的选取其中的列，但是这个数据集没有行名，我们可以给它添加行名，这个数据共有4行，所以我们要准备4个名字，然后使用rownames()添加行名：\n\n# 准备4个名字\nrws &lt;- c(\"第一行\", \"第二行\", \"第三行\", \"第四行\")\n\n# 添加行名：\nrownames(patientdata) &lt;- rws\npatientdata\n##        patientID age diabetes    status\n## 第一行         1  25    Type1      Poor\n## 第二行         2  34    Type2  Improved\n## 第三行         3  28    Type1 Excellent\n## 第四行         4  52    Type1      Poor\n\n这样就可以通过行名选择你想要的行了，比如选择第1行和第3行，所有的列：\n\npatientdata[c(\"第一行\", \"第三行\"), ]\n##        patientID age diabetes    status\n## 第一行         1  25    Type1      Poor\n## 第三行         3  28    Type1 Excellent\n\n选择年龄大于30岁的行以及第2列和第3列：\n\npatientdata[patientdata$age &gt; 30, c(2,3)]\n##        age diabetes\n## 第二行  34    Type2\n## 第四行  52    Type1\n\n此时其实是通过TRUE/FALSE进行选择，首先看patientdata$age &gt; 30：\n\n# 第2个和第4个是TRUE，所以就是选择第2行和第4行\npatientdata$age &gt; 30\n## [1] FALSE  TRUE FALSE  TRUE\n\n这种方法非常有用，大家一定要记住。\n\n\n7.2.4 增加/删除行列\n增加行列，删除行列：\n\n# 增加1列weight\npatientdata$weight &lt;- c(20,30,40,50)\npatientdata\n##        patientID age diabetes    status weight\n## 第一行         1  25    Type1      Poor     20\n## 第二行         2  34    Type2  Improved     30\n## 第三行         3  28    Type1 Excellent     40\n## 第四行         4  52    Type1      Poor     50\n\n# 删除第2列，\n# 注意，此时不重新赋值的话其实patientdata是没有变化的，和向量一样\npatientdata[,-2]\n##        patientID diabetes    status weight\n## 第一行         1    Type1      Poor     20\n## 第二行         2    Type2  Improved     30\n## 第三行         3    Type1 Excellent     40\n## 第四行         4    Type1      Poor     50\n\n# 或者使用以下方法删除列，这种方法不用重新赋值\npatientdata$weight &lt;- NULL\npatientdata\n##        patientID age diabetes    status\n## 第一行         1  25    Type1      Poor\n## 第二行         2  34    Type2  Improved\n## 第三行         3  28    Type1 Excellent\n## 第四行         4  52    Type1      Poor\n\n#patientdata[,- \"age\"] # 这种写法是错误的\n\n\n\n7.2.5 修改和重编码\n\npatientdata &lt;- data.frame(\n  patientID = c(1, 2, 3, 4), \n  age = c(25, 34, 28, 52), \n  diabetes = c(\"Type1\", \"Type2\", \"Type1\", \"Type1\"), \n  status = c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\")\n  )\n\npatientdata\n##   patientID age diabetes    status\n## 1         1  25    Type1      Poor\n## 2         2  34    Type2  Improved\n## 3         3  28    Type1 Excellent\n## 4         4  52    Type1      Poor\n\n比如，把diabetes这一列中的Type1变成类型1：\n\n# 选择要修改的列，选择要修改的值，重新赋值即可\npatientdata$diabetes[patientdata$diabetes == \"Type1\"] &lt;- \"类型1\"\npatientdata\n##   patientID age diabetes    status\n## 1         1  25    类型1      Poor\n## 2         2  34    Type2  Improved\n## 3         3  28    类型1 Excellent\n## 4         4  52    类型1      Poor\n\n把age这一列中大于30岁的变成中年人，小于等于30岁的变成青年人：\n\npatientdata$age[patientdata$age &gt; 30] &lt;- \"中年人\"\npatientdata$age[patientdata$age &lt;= 30] &lt;- \"青年人\"\npatientdata\n##   patientID    age diabetes    status\n## 1         1 青年人    类型1      Poor\n## 2         2 中年人    Type2  Improved\n## 3         3 青年人    类型1 Excellent\n## 4         4 中年人    类型1      Poor\n\n\n\n7.2.6 行列转置\n行变成列，列变成行，也就是旋转90°：\n\npatientdata\n##   patientID    age diabetes    status\n## 1         1 青年人    类型1      Poor\n## 2         2 中年人    Type2  Improved\n## 3         3 青年人    类型1 Excellent\n## 4         4 中年人    类型1      Poor\n\npdt &lt;- t(patientdata) # transpose缩写\npdt\n##           [,1]     [,2]       [,3]        [,4]    \n## patientID \"1\"      \"2\"        \"3\"         \"4\"     \n## age       \"青年人\" \"中年人\"   \"青年人\"    \"中年人\"\n## diabetes  \"类型1\"  \"Type2\"    \"类型1\"     \"类型1\" \n## status    \"Poor\"   \"Improved\" \"Excellent\" \"Poor\"\nclass(pdt)\n## [1] \"matrix\" \"array\"\n\n数据框转置后会变成矩阵，如果要变成数据框，使用as.data.frame()即可：\n\npdt &lt;- as.data.frame(t(patientdata))\npdt\n##               V1       V2        V3     V4\n## patientID      1        2         3      4\n## age       青年人   中年人    青年人 中年人\n## diabetes   类型1    Type2     类型1  类型1\n## status      Poor Improved Excellent   Poor\nclass(pdt)\n## [1] \"data.frame\"\n\n\n\n7.2.7 行列拼接\n可以分为:\n\n拼接列：把列拼起来，也就是对多个数据框水平堆叠，也就是在一个数据框的右侧添加另一个数据框，要求行数相同\n拼接行：把行拼起来，也就是对多个数据框垂直堆叠，也就是在一个数据框的下方添加另一个数据框，要求列数相同\n\n\n比如现在如下两个数据框df1和df2：\n\ndf1 # 3行4列\n## # A tibble: 3 × 4\n##   barcode                      patient      sample           sample_type        \n##   &lt;chr&gt;                        &lt;chr&gt;        &lt;chr&gt;            &lt;chr&gt;              \n## 1 TCGA-BH-A1FC-11A-32R-A13Q-07 TCGA-BH-A1FC TCGA-BH-A1FC-11A Solid Tissue Normal\n## 2 TCGA-AC-A2FM-11B-32R-A19W-07 TCGA-AC-A2FM TCGA-AC-A2FM-11B Solid Tissue Normal\n## 3 TCGA-BH-A0DO-11A-22R-A12D-07 TCGA-BH-A0DO TCGA-BH-A0DO-11A Solid Tissue Normal\ndf2 # 3行5列\n## # A tibble: 3 × 5\n##   initial_weight ajcc_pathologic_stage days_to_last_follow_up gender\n##            &lt;dbl&gt; &lt;chr&gt;                 &lt;chr&gt;                  &lt;chr&gt; \n## 1            260 Stage IIA             NA                     female\n## 2            220 Stage IIB             NA                     female\n## 3            130 Stage I               1644                   female\n## # ℹ 1 more variable: age_at_index &lt;dbl&gt;\n\n现在我们把两个数据框按列拼接：\n\ncbind(df1, df2) # column bind，变成3行9列\n##                        barcode      patient           sample\n## 1 TCGA-BH-A1FC-11A-32R-A13Q-07 TCGA-BH-A1FC TCGA-BH-A1FC-11A\n## 2 TCGA-AC-A2FM-11B-32R-A19W-07 TCGA-AC-A2FM TCGA-AC-A2FM-11B\n## 3 TCGA-BH-A0DO-11A-22R-A12D-07 TCGA-BH-A0DO TCGA-BH-A0DO-11A\n##           sample_type initial_weight ajcc_pathologic_stage\n## 1 Solid Tissue Normal            260             Stage IIA\n## 2 Solid Tissue Normal            220             Stage IIB\n## 3 Solid Tissue Normal            130               Stage I\n##   days_to_last_follow_up gender age_at_index\n## 1                     NA female           78\n## 2                     NA female           87\n## 3                   1644 female           78\n\n假如还有两个数据框df3和df4：\n\ndf3 # 3行2列\n## # A tibble: 3 × 2\n##   barcode                      patient     \n##   &lt;chr&gt;                        &lt;chr&gt;       \n## 1 TCGA-BH-A1FC-11A-32R-A13Q-07 TCGA-BH-A1FC\n## 2 TCGA-AC-A2FM-11B-32R-A19W-07 TCGA-AC-A2FM\n## 3 TCGA-BH-A0DO-11A-22R-A12D-07 TCGA-BH-A0DO\ndf4 # 2行2列\n## # A tibble: 2 × 2\n##   barcode                      patient     \n##   &lt;chr&gt;                        &lt;chr&gt;       \n## 1 TCGA-E2-A1BC-11A-32R-A12P-07 TCGA-E2-A1BC\n## 2 TCGA-BH-A0BJ-11A-23R-A089-07 TCGA-BH-A0BJ\n\n进行按行拼接：\n\nrbind(df3,df4) # row bind，变成5行2列\n## # A tibble: 5 × 2\n##   barcode                      patient     \n##   &lt;chr&gt;                        &lt;chr&gt;       \n## 1 TCGA-BH-A1FC-11A-32R-A13Q-07 TCGA-BH-A1FC\n## 2 TCGA-AC-A2FM-11B-32R-A19W-07 TCGA-AC-A2FM\n## 3 TCGA-BH-A0DO-11A-22R-A12D-07 TCGA-BH-A0DO\n## 4 TCGA-E2-A1BC-11A-32R-A12P-07 TCGA-E2-A1BC\n## 5 TCGA-BH-A0BJ-11A-23R-A089-07 TCGA-BH-A0BJ\n\n\n\n7.2.8 数据框合并\n具有共同信息的两个数据框可以合并到一个数据框中。比如表格1中包含甲乙丙丁4个病人的年龄和性别信息，表格2中包含甲乙丙丁4个病人的生化指标，那么这样的两个表格就可以合并到一个表格中。\n\ndf1 &lt;- data.frame(\n  patientID = c(\"甲\",\"乙\",\"丙\",\"丁\"),\n  age = c(23,43,45,34),\n  gender = c(\"男\",\"女\",\"女\",\"男\")\n)\ndf2 &lt;- data.frame(\n  patientID = c(\"甲\",\"乙\",\"丙\",\"丁\"),\n  hb = c(110,124,138,142),\n  wbc = c(3.7,4.6,6.4,4.2)\n)\n\ndf1\n##   patientID age gender\n## 1        甲  23     男\n## 2        乙  43     女\n## 3        丙  45     女\n## 4        丁  34     男\ndf2\n##   patientID  hb wbc\n## 1        甲 110 3.7\n## 2        乙 124 4.6\n## 3        丙 138 6.4\n## 4        丁 142 4.2\n\n这两个数据框储存着同一批病人（都是甲乙丙丁4个人）的不同信息，直接拼接起来不是我们想要的结果，因为patientID会出现两次：\n\ncbind(df1,df2)\n##   patientID age gender patientID  hb wbc\n## 1        甲  23     男        甲 110 3.7\n## 2        乙  43     女        乙 124 4.6\n## 3        丙  45     女        丙 138 6.4\n## 4        丁  34     男        丁 142 4.2\n\n正确的方法是根据两个数据框共有的信息把它们合并起来。这两个数据框共有的信息是patientID这一列，表示的都是甲乙丙丁4个病人，这种情况的正确做法是使用merge函数。\n\n# 根据共有信息合并2个数据框\ndf3 &lt;- merge(df1, df2, by = \"patientID\")\ndf3\n##   patientID age gender  hb wbc\n## 1        丙  45     女 138 6.4\n## 2        丁  34     男 142 4.2\n## 3        甲  23     男 110 3.7\n## 4        乙  43     女 124 4.6\n\n顺序不一样也没有影响，会自动对应好。比如下面这个数据框，它的顺序不是甲乙丙丁，而是甲丁乙丙：\n\ndf4 &lt;- df2[order(df2$wbc),]\ndf4\n##   patientID  hb wbc\n## 1        甲 110 3.7\n## 4        丁 142 4.2\n## 2        乙 124 4.6\n## 3        丙 138 6.4\n\n这个数据框和df1也可以直接合并，不会出错：\n\nmerge(df1, df4)\n##   patientID age gender  hb wbc\n## 1        丙  45     女 138 6.4\n## 2        丁  34     男 142 4.2\n## 3        甲  23     男 110 3.7\n## 4        乙  43     女 124 4.6\n\n两个数据框共有信息的名字不一样也可以！\n\n# 这个数据框表示病人ID的列名是id，不是patientID\nnames(df4)[1] &lt;- \"id\"\ndf4\n##   id  hb wbc\n## 1 甲 110 3.7\n## 4 丁 142 4.2\n## 2 乙 124 4.6\n## 3 丙 138 6.4\ndf1\n##   patientID age gender\n## 1        甲  23     男\n## 2        乙  43     女\n## 3        丙  45     女\n## 4        丁  34     男\n\n也可以直接合并，只要指定各自的列名即可：\n\nmerge(df1,df4, by.x = \"patientID\", by.y = \"id\")\n##   patientID age gender  hb wbc\n## 1        丙  45     女 138 6.4\n## 2        丁  34     男 142 4.2\n## 3        甲  23     男 110 3.7\n## 4        乙  43     女 124 4.6\n\n这就是表格的合并，也就是把存储相同信息的多个表格合并到一个表格中，注意共同的列(上面的例子是patientID，可以列名不同，但是必须是相同的一类信息或者标识符)不能有重复的观测（比如不能有多个“甲”，只能有一个）。\n根据具体情况不同，可以分为以下几类：\n\n内连接：保留两个表格中共有的观测。\n左连接：保留表1中的所有观测。\n右连接：保留表2中的所有观测。\n全连接：保留表1和表2中的所有观测。\n\n\n假设两个数据框存储了病人的不同信息，如下所示：\n\ndf1 &lt;- data.frame(\n  patientID = c(\"甲\",\"乙\",\"丙\",\"丁\"),\n  age = c(23,43,45,34),\n  gender = c(\"男\",\"女\",\"女\",\"男\")\n)\ndf2 &lt;- data.frame(\n  patientID = c(\"甲\",\"乙\",\"戊\",\"几\",\"庚\"),\n  hb = c(110,124,138,142,108),\n  wbc = c(3.7,4.6,6.4,4.2,5.6)\n)\n\ndf1\n##   patientID age gender\n## 1        甲  23     男\n## 2        乙  43     女\n## 3        丙  45     女\n## 4        丁  34     男\ndf2\n##   patientID  hb wbc\n## 1        甲 110 3.7\n## 2        乙 124 4.6\n## 3        戊 138 6.4\n## 4        几 142 4.2\n## 5        庚 108 5.6\n\n内连接，即保留两个表格中共有的观测（相当于取交集）：\n\nmerge(df1, df2, by = \"patientID\")\n##   patientID age gender  hb wbc\n## 1        甲  23     男 110 3.7\n## 2        乙  43     女 124 4.6\n\n左连接，即保留表1中的所有观测，表2中没有的信息自动填充NA：\n\nmerge(df1, df2, all.x = T)\n##   patientID age gender  hb wbc\n## 1        丙  45     女  NA  NA\n## 2        丁  34     男  NA  NA\n## 3        甲  23     男 110 3.7\n## 4        乙  43     女 124 4.6\n\n右连接，和左连接刚好相反，保留表2中的所有观测：\n\nmerge(df1, df2, all.y = T)\n##   patientID age gender  hb wbc\n## 1        庚  NA   &lt;NA&gt; 108 5.6\n## 2        几  NA   &lt;NA&gt; 142 4.2\n## 3        甲  23     男 110 3.7\n## 4        戊  NA   &lt;NA&gt; 138 6.4\n## 5        乙  43     女 124 4.6\n\n#等价于\nmerge(df2, df1, all.x = T)\n##   patientID  hb wbc age gender\n## 1        庚 108 5.6  NA   &lt;NA&gt;\n## 2        几 142 4.2  NA   &lt;NA&gt;\n## 3        甲 110 3.7  23     男\n## 4        戊 138 6.4  NA   &lt;NA&gt;\n## 5        乙 124 4.6  43     女\n\n全连接，即保留表1和表2中的所有观测（相当于取并集）：\n\nmerge(df1, df2, all = T)\n##   patientID age gender  hb wbc\n## 1        丙  45     女  NA  NA\n## 2        丁  34     男  NA  NA\n## 3        庚  NA   &lt;NA&gt; 108 5.6\n## 4        几  NA   &lt;NA&gt; 142 4.2\n## 5        甲  23     男 110 3.7\n## 6        戊  NA   &lt;NA&gt; 138 6.4\n## 7        乙  43     女 124 4.6\n\n上面4种连接是最常见的，其实还有半连接和反连接，暂不介绍，感兴趣的可以自己学习一下。\n\n\n7.2.9 排序\n\npatientdata &lt;- data.frame(\n  patientID = c(1, 2, 3, 4), \n  age = c(25, 34, 28, 52), \n  diabetes = c(\"Type1\", \"Type2\", \"Type1\", \"Type1\"), \n  status = c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\")\n  )\n\npatientdata\n##   patientID age diabetes    status\n## 1         1  25    Type1      Poor\n## 2         2  34    Type2  Improved\n## 3         3  28    Type1 Excellent\n## 4         4  52    Type1      Poor\n\n根据某一列进行排序，比如根据age从小到大对数据框重新排序：\n\n# 注意，此时不重新赋值的话其实patientdata的顺序是没有变的，和向量一样\npatientdata[order(patientdata$age),]\n##   patientID age diabetes    status\n## 1         1  25    Type1      Poor\n## 3         3  28    Type1 Excellent\n## 2         2  34    Type2  Improved\n## 4         4  52    Type1      Poor\n\n根据age从大到小对数据框重新排序：\n\n# 注意，此时不重新赋值的话其实patientdata的顺序是没有变的，和向量一样\npatientdata[order(patientdata$age, decreasing = T),]\n##   patientID age diabetes    status\n## 4         4  52    Type1      Poor\n## 2         2  34    Type2  Improved\n## 3         3  28    Type1 Excellent\n## 1         1  25    Type1      Poor\n\n# 或者\n# 注意，此时不重新赋值的话其实patientdata的顺序是没有变的，和向量一样\npatientdata[order(- patientdata$age),]\n##   patientID age diabetes    status\n## 4         4  52    Type1      Poor\n## 2         2  34    Type2  Improved\n## 3         3  28    Type1 Excellent\n## 1         1  25    Type1      Poor\n\n还可以根据多个变量进行排序，比如，按照年龄从小到大，并且diabetes从1型到2型的顺序排序：\n\n# 注意，此时不重新赋值的话其实patientdata的顺序是没有变的，和向量一样\npatientdata[order(patientdata$age, patientdata$diabetes),]\n##   patientID age diabetes    status\n## 1         1  25    Type1      Poor\n## 3         3  28    Type1 Excellent\n## 2         2  34    Type2  Improved\n## 4         4  52    Type1      Poor\n\n\n\n7.2.10 计数\n如果要查看某一列有几个类别及数量：\n\ntable(patientdata$status)\n## \n## Excellent  Improved      Poor \n##         1         1         2\n\n如果你想生成diabetes和status的列联表，可以使用table()函数：\n\ntable(patientdata$diabetes, patientdata$status)\n##        \n##         Excellent Improved Poor\n##   Type1         1        0    2\n##   Type2         0        1    0\n\n医学生应该都能看懂这个结果什么意思吧？\n在每个变量名前都键入一次patientdata$的写法是不符合编程思想的，是很繁琐的，所以给大家介绍一个with()函数，在with()函数内部，你可以不用写数据集的名字：\n\nwith(patientdata,\n     table(diabetes, status)\n     )\n##         status\n## diabetes Excellent Improved Poor\n##    Type1         1        0    2\n##    Type2         0        1    0\n\n\n\n7.2.11 数据框实战\n这个数据是我从TCGA官网下载的乳腺癌患者的临床信息，包含：患者ID、样本ID、样本类型（normal还是tumor？）、年龄、性别等。\n\n# 读取文件\nlibrary(readxl)\nbrca_clin &lt;- read_xlsx(\"F:/R_books/R_beginners/brca_clin.xlsx\", col_names = T)\n\n# 查看数据基本情况\ndim(brca_clin)\n## [1] 20  9\nhead(brca_clin)\n## # A tibble: 6 × 9\n##   barcode        patient sample sample_type initial_weight ajcc_pathologic_stage\n##   &lt;chr&gt;          &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;                &lt;dbl&gt; &lt;chr&gt;                \n## 1 TCGA-BH-A1FC-… TCGA-B… TCGA-… Solid Tiss…            260 Stage IIA            \n## 2 TCGA-AC-A2FM-… TCGA-A… TCGA-… Solid Tiss…            220 Stage IIB            \n## 3 TCGA-BH-A0DO-… TCGA-B… TCGA-… Solid Tiss…            130 Stage I              \n## 4 TCGA-E2-A1BC-… TCGA-E… TCGA-… Solid Tiss…            260 Stage IA             \n## 5 TCGA-BH-A0BJ-… TCGA-B… TCGA-… Solid Tiss…            200 Stage IIB            \n## 6 TCGA-E2-A1LH-… TCGA-E… TCGA-… Solid Tiss…             60 Stage I              \n## # ℹ 3 more variables: days_to_last_follow_up &lt;chr&gt;, gender &lt;chr&gt;,\n## #   age_at_index &lt;dbl&gt;\ncolnames(brca_clin)\n## [1] \"barcode\"                \"patient\"                \"sample\"                \n## [4] \"sample_type\"            \"initial_weight\"         \"ajcc_pathologic_stage\" \n## [7] \"days_to_last_follow_up\" \"gender\"                 \"age_at_index\"\n\n变量名修改：\n\ncolnames(brca_clin)[c(5,6,7,9)] &lt;- c(\"weight\",\"stage\",\"days\",\"age\")\ncolnames(brca_clin)\n## [1] \"barcode\"     \"patient\"     \"sample\"      \"sample_type\" \"weight\"     \n## [6] \"stage\"       \"days\"        \"gender\"      \"age\"\n\n选择第5~9列：\n\nbrca_clin &lt;- brca_clin[,c(5:9)]\nbrca_clin\n## # A tibble: 20 × 5\n##    weight stage      days  gender   age\n##     &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;\n##  1    260 Stage IIA  NA    female    78\n##  2    220 Stage IIB  NA    female    87\n##  3    130 Stage I    1644  female    78\n##  4    260 Stage IA   501   female    63\n##  5    200 Stage IIB  660   female    41\n##  6     60 Stage I    3247  female    59\n##  7    320 Stage IIB  NA    female    60\n##  8    310 Stage IIIA NA    female    39\n##  9    100 Stage IIB  1876  female    54\n## 10    250 Stage IIB  707   female    51\n## 11    130 Stage IIA  5749  female    51\n## 12    110 Stage IA   NA    female    44\n## 13    470 Stage IIA  1972  female    64\n## 14     90 Stage I    1321  female    56\n## 15    200 Stage IIA  385   female    71\n## 16     70 Stage IIA  1800  female    71\n## 17    130 Stage IIB  214   female    63\n## 18    770 Stage IIIA 1206  female    47\n## 19    200 Stage IA   2442  female    54\n## 20    250 Stage IIIC NA    female    36\n\n按照age从小到大排序数据框：\n\nbrca_clin[order(brca_clin$age),]\n## # A tibble: 20 × 5\n##    weight stage      days  gender   age\n##     &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;\n##  1    250 Stage IIIC NA    female    36\n##  2    310 Stage IIIA NA    female    39\n##  3    200 Stage IIB  660   female    41\n##  4    110 Stage IA   NA    female    44\n##  5    770 Stage IIIA 1206  female    47\n##  6    250 Stage IIB  707   female    51\n##  7    130 Stage IIA  5749  female    51\n##  8    100 Stage IIB  1876  female    54\n##  9    200 Stage IA   2442  female    54\n## 10     90 Stage I    1321  female    56\n## 11     60 Stage I    3247  female    59\n## 12    320 Stage IIB  NA    female    60\n## 13    260 Stage IA   501   female    63\n## 14    130 Stage IIB  214   female    63\n## 15    470 Stage IIA  1972  female    64\n## 16    200 Stage IIA  385   female    71\n## 17     70 Stage IIA  1800  female    71\n## 18    260 Stage IIA  NA    female    78\n## 19    130 Stage I    1644  female    78\n## 20    220 Stage IIB  NA    female    87\n\n按照从大到小的顺序排列：\n\nbrca_clin[order(brca_clin$age, decreasing = T),]\n## # A tibble: 20 × 5\n##    weight stage      days  gender   age\n##     &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;\n##  1    220 Stage IIB  NA    female    87\n##  2    260 Stage IIA  NA    female    78\n##  3    130 Stage I    1644  female    78\n##  4    200 Stage IIA  385   female    71\n##  5     70 Stage IIA  1800  female    71\n##  6    470 Stage IIA  1972  female    64\n##  7    260 Stage IA   501   female    63\n##  8    130 Stage IIB  214   female    63\n##  9    320 Stage IIB  NA    female    60\n## 10     60 Stage I    3247  female    59\n## 11     90 Stage I    1321  female    56\n## 12    100 Stage IIB  1876  female    54\n## 13    200 Stage IA   2442  female    54\n## 14    250 Stage IIB  707   female    51\n## 15    130 Stage IIA  5749  female    51\n## 16    770 Stage IIIA 1206  female    47\n## 17    110 Stage IA   NA    female    44\n## 18    200 Stage IIB  660   female    41\n## 19    310 Stage IIIA NA    female    39\n## 20    250 Stage IIIC NA    female    36\n\n查看有几个类别，以及每个类别的数量：\n\ntable(brca_clin$stage)\n## \n##    Stage I   Stage IA  Stage IIA  Stage IIB Stage IIIA Stage IIIC \n##          3          3          5          6          2          1\n\n变量重编码和修改：\n\nbrca_clin$stage[brca_clin$stage == \"Stage IIB\"] &lt;- \"Stage_2\"\nbrca_clin\n## # A tibble: 20 × 5\n##    weight stage      days  gender   age\n##     &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;\n##  1    260 Stage IIA  NA    female    78\n##  2    220 Stage_2    NA    female    87\n##  3    130 Stage I    1644  female    78\n##  4    260 Stage IA   501   female    63\n##  5    200 Stage_2    660   female    41\n##  6     60 Stage I    3247  female    59\n##  7    320 Stage_2    NA    female    60\n##  8    310 Stage IIIA NA    female    39\n##  9    100 Stage_2    1876  female    54\n## 10    250 Stage_2    707   female    51\n## 11    130 Stage IIA  5749  female    51\n## 12    110 Stage IA   NA    female    44\n## 13    470 Stage IIA  1972  female    64\n## 14     90 Stage I    1321  female    56\n## 15    200 Stage IIA  385   female    71\n## 16     70 Stage IIA  1800  female    71\n## 17    130 Stage_2    214   female    63\n## 18    770 Stage IIIA 1206  female    47\n## 19    200 Stage IA   2442  female    54\n## 20    250 Stage IIIC NA    female    36\n\n全部修改：\n\nbrca_clin$stage[brca_clin$stage == \"Stage IIA\"] &lt;- \"Stage_2\"\nbrca_clin$stage[brca_clin$stage == \"Stage IA\"] &lt;- \"Stage_1\"\nbrca_clin$stage[brca_clin$stage == \"Stage I\"] &lt;- \"Stage_1\"\nbrca_clin$stage[brca_clin$stage == \"Stage IIIA\"] &lt;- \"Stage_3\"\nbrca_clin$stage[brca_clin$stage == \"Stage IIIC\"] &lt;- \"Stage_3\"\n\nbrca_clin\n## # A tibble: 20 × 5\n##    weight stage   days  gender   age\n##     &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt;\n##  1    260 Stage_2 NA    female    78\n##  2    220 Stage_2 NA    female    87\n##  3    130 Stage_1 1644  female    78\n##  4    260 Stage_1 501   female    63\n##  5    200 Stage_2 660   female    41\n##  6     60 Stage_1 3247  female    59\n##  7    320 Stage_2 NA    female    60\n##  8    310 Stage_3 NA    female    39\n##  9    100 Stage_2 1876  female    54\n## 10    250 Stage_2 707   female    51\n## 11    130 Stage_2 5749  female    51\n## 12    110 Stage_1 NA    female    44\n## 13    470 Stage_2 1972  female    64\n## 14     90 Stage_1 1321  female    56\n## 15    200 Stage_2 385   female    71\n## 16     70 Stage_2 1800  female    71\n## 17    130 Stage_2 214   female    63\n## 18    770 Stage_3 1206  female    47\n## 19    200 Stage_1 2442  female    54\n## 20    250 Stage_3 NA    female    36\n\n查看修改后的stage:\n\ntable(brca_clin$stage)\n## \n## Stage_1 Stage_2 Stage_3 \n##       6      11       3\n\n根据年龄进行分组，大于60岁是old，小于等于60岁是young:\n\n# 先看下年龄是不是数值型\nstr(brca_clin)\n## tibble [20 × 5] (S3: tbl_df/tbl/data.frame)\n##  $ weight: num [1:20] 260 220 130 260 200 60 320 310 100 250 ...\n##  $ stage : chr [1:20] \"Stage_2\" \"Stage_2\" \"Stage_1\" \"Stage_1\" ...\n##  $ days  : chr [1:20] \"NA\" \"NA\" \"1644\" \"501\" ...\n##  $ gender: chr [1:20] \"female\" \"female\" \"female\" \"female\" ...\n##  $ age   : num [1:20] 78 87 78 63 41 59 60 39 54 51 ...\nis.numeric(brca_clin$age)\n## [1] TRUE\n\n开始修改：\n\nbrca_clin$age[brca_clin$age &gt; 60] &lt;- \"old\"\nbrca_clin$age[brca_clin$age &lt;= 60] &lt;- \"young\"\nbrca_clin\n## # A tibble: 20 × 5\n##    weight stage   days  gender age  \n##     &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;\n##  1    260 Stage_2 NA    female old  \n##  2    220 Stage_2 NA    female old  \n##  3    130 Stage_1 1644  female old  \n##  4    260 Stage_1 501   female old  \n##  5    200 Stage_2 660   female young\n##  6     60 Stage_1 3247  female young\n##  7    320 Stage_2 NA    female young\n##  8    310 Stage_3 NA    female young\n##  9    100 Stage_2 1876  female young\n## 10    250 Stage_2 707   female young\n## 11    130 Stage_2 5749  female young\n## 12    110 Stage_1 NA    female young\n## 13    470 Stage_2 1972  female old  \n## 14     90 Stage_1 1321  female young\n## 15    200 Stage_2 385   female old  \n## 16     70 Stage_2 1800  female old  \n## 17    130 Stage_2 214   female old  \n## 18    770 Stage_3 1206  female young\n## 19    200 Stage_1 2442  female young\n## 20    250 Stage_3 NA    female young\n\nNA修改(这个数据框里的NA是字符型，并不是真正的NA)：\n\nbrca_clin$days_1 &lt;- ifelse(brca_clin$days == \"NA\", NA, brca_clin$days)\nbrca_clin\n## # A tibble: 20 × 6\n##    weight stage   days  gender age   days_1\n##     &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; \n##  1    260 Stage_2 NA    female old   &lt;NA&gt;  \n##  2    220 Stage_2 NA    female old   &lt;NA&gt;  \n##  3    130 Stage_1 1644  female old   1644  \n##  4    260 Stage_1 501   female old   501   \n##  5    200 Stage_2 660   female young 660   \n##  6     60 Stage_1 3247  female young 3247  \n##  7    320 Stage_2 NA    female young &lt;NA&gt;  \n##  8    310 Stage_3 NA    female young &lt;NA&gt;  \n##  9    100 Stage_2 1876  female young 1876  \n## 10    250 Stage_2 707   female young 707   \n## 11    130 Stage_2 5749  female young 5749  \n## 12    110 Stage_1 NA    female young &lt;NA&gt;  \n## 13    470 Stage_2 1972  female old   1972  \n## 14     90 Stage_1 1321  female young 1321  \n## 15    200 Stage_2 385   female old   385   \n## 16     70 Stage_2 1800  female old   1800  \n## 17    130 Stage_2 214   female old   214   \n## 18    770 Stage_3 1206  female young 1206  \n## 19    200 Stage_1 2442  female young 2442  \n## 20    250 Stage_3 NA    female young &lt;NA&gt;",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "07-数据结构.html#因子",
    "href": "07-数据结构.html#因子",
    "title": "7  数据结构",
    "section": "7.3 因子",
    "text": "7.3 因子\n多数变量可归为名义型、有序型或连续型变量。\n名义型变量（nominal-variable）是没有顺序之分的类别变量。糖尿病类型diabetes（Type1、Type2）是名义型变量的一例。即使在数据中Type1编码为1而Type2编码为2`，这也并不意味着二者是有序的。\n有序型变量（ordinal-variable）表示一种顺序关系，而非数量关系。病情status（poor、improved、excellent）是有序型变量的一个示例。很明显病情为poor（较差）病人的状态不如improved（病情好转）的病人，但并不知道相差多少。\n连续型变量（continuous-variable）可以呈现为某个范围内的任意值，并同时表示了顺序和数量。年龄Age就是一个连续型变量，它能够表示像14.5或22.8这样的值以及其间的其他任意值。\n类别（名义型）变量和有序类别（有序型）变量在R中称为因子（factor）。因子在R中非常重要，因为它决定了数据的分析方式以及如何进行视觉呈现。\n\n7.3.1 创建因子\n因子可以通过函数factor()创建。比如用以下代码即可创建一个名为status的因子型向量：\n\nstatus &lt;- factor(c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\"))\nstatus\n## [1] Poor      Improved  Excellent Poor     \n## Levels: Excellent Improved Poor\n\n此时的status是一个因子型向量，也是没有顺序之分的名义型变量，虽然给出了Levels，但是并不能表示它们之间有高低顺序，默认的水平顺序是按照首字母排列的。\n\n\n7.3.2 因子水平和标签\n如果要更改不同水平的顺序，可以直接在factor()中使用levels参数指定：\n\nstatus &lt;- factor(c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\"),\n                 levels = c(\"Poor\", \"Excellent\", \"Improved\")\n                 )\nstatus\n## [1] Poor      Improved  Excellent Poor     \n## Levels: Poor Excellent Improved\n\n\n\n\n\n\n\n注意\n\n\n\nlevles函数（函数，不是参数）也可以修改因子水平的顺序，但是levels函数在改变顺序的同时也会把因子水平的内容也替换掉，所以会导致向量的内容也会变！举个例子：\n\naa &lt;- c(\"a\",\"b\",\"c\",\"d\")\naa # 记住aa的内容\n## [1] \"a\" \"b\" \"c\" \"d\"\n#变成因子型\ntest1 &lt;- factor(aa)\ntest1 # 记住test1的内容\n## [1] a b c d\n## Levels: a b c d\n# 更改因子水平\nlevels(test1) &lt;- c(\"b\",\"a\",\"c\",\"d\")\ntest1 # 水平是变了，内容也变了！\n## [1] b a c d\n## Levels: b a c d\n\n\n\n对于不同的水平，你也可以修改它的显示标签：\n\nstatus &lt;- factor(c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\"),\n                 levels = c(\"Poor\", \"Excellent\", \"Improved\"),\n                 labels = c(\"第一水平\", \"第二水平\", \"第三水平\")\n                 )\nstatus\n## [1] 第一水平 第三水平 第二水平 第一水平\n## Levels: 第一水平 第二水平 第三水平\n\n如果想要把某个变量变成有序型变量，可以使用ordered=TRUE参数：\n\nstatus &lt;- factor(c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\"),\n                 ordered = T\n                 )\nstatus\n## [1] Poor      Improved  Excellent Poor     \n## Levels: Excellent &lt; Improved &lt; Poor\n\n可以看到此时结果中的Levels有了小于号，用来表示高低顺序。\n\n\n\n\n\n\n注释\n\n\n\n名义型变量和有序型变量在进行统计分析时会使用完全不同的方法，比如在进行线性回归或者cox回归分析时，名义型变量的默认方法是哑变量编码，而有序型变量的编码方式是正交多项式编码。相关内容可参考：分类变量进行回归分析时的编码方案\n\n\n\n\n7.3.3 计数\ntable()函数可用于查看每个水平的数量：\n\ntable(status)\n## status\n## Excellent  Improved      Poor \n##         1         1         2\n\n如果和length()同用则可以快速计算有几个水平（或类别，在分类变量中很常用）：\n\n# 查看有几个类别\nlength(table(status))\n## [1] 3\n\n因子类型是R语言中处理分类变量非常有用的类型，在画图的时候也可以使用因子规定好顺序，方便对图形进行排列。\nforcats包提供了一套专门用于处理因子的函数，非常实用，大家可以阅读以下文章进一步了解：\n\nR语言处理因子之forcats包介绍（1）\nR语言处理因子之forcats包介绍（2）\nR语言处理因子之forcats包介绍（3）\nR语言处理因子之forcats包介绍（4）",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "07-数据结构.html#矩阵",
    "href": "07-数据结构.html#矩阵",
    "title": "7  数据结构",
    "section": "7.4 矩阵",
    "text": "7.4 矩阵\n矩阵，matrix，表面看起来像一个数据框，有行和列，也是二维的，但是矩阵里面的所有元素都必须是同一类型的，比如必须都是数值型，或者必须都是字符型，或者必须都是逻辑型，等。\n可通过函数matrix()创建矩阵。一般使用格式为：\n\nmyymatrix &lt;- matrix(vector, nrow = 多少行？, ncol = 多少列？,\n                    byrow = 是不是按行进行填充？,\n                    dimnames = list(行名, 列名))\n\n其中vector是矩阵所需要的元素，nrow和ncol用以指定行和列的数量，dimnames包含了以字符型向量表示的行名和列名（这个参数可以省略不写）。选项byrow则表明矩阵应当按行填充（byrow=TRUE）还是按列填充（byrow=FALSE），默认情况下按列填充。\n以下代码创建了一个5行、4列的矩阵，用1~20这20个数字进行填充，并且定义了行的名字和列的名字，并且是按列进行填充：\n\ny &lt;- matrix(1:20, nrow=5, ncol=4,\n            dimnames = list(c(\"行1\",\"行2\",\"行3\",\"行4\",\"行5\"),\n                            c(\"列1\",\"列2\",\"列3\",\"列4\"))\n            ) \ny\n##     列1 列2 列3 列4\n## 行1   1   6  11  16\n## 行2   2   7  12  17\n## 行3   3   8  13  18\n## 行4   4   9  14  19\n## 行5   5  10  15  20\n\n对矩阵取行和列的语法和数据框完全一样，使用方括号即可，这里就不重复了。\n\ny[1,2]\n## [1] 6",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "07-数据结构.html#数组",
    "href": "07-数据结构.html#数组",
    "title": "7  数据结构",
    "section": "7.5 数组",
    "text": "7.5 数组\n数组，array，类似矩阵，但可以有更多的维度（行、列以外的方向），比如可以有3维甚至更多，这种结构可能是你无法想象的（超过3维的东西你能想象出来吗？），但是幸好这个结构我们用的不多。\n数组可通过array函数创建，形式如下：\n\nmyarray &lt;- array(vector, dimensions, dimnames)\n\n其中vector包含了数组中的数据，dimensions是一个数值型向量，给出了各个维度下标的最大值，而dimnames是可选的、各维度名称标签的列表。\n以下代码创建一个三维数组（234）：\n\ndim1 &lt;- c(\"A1\", \"A2\")\ndim2 &lt;- c(\"B1\", \"B2\", \"B3\")\ndim3 &lt;- c(\"C1\", \"C2\", \"C3\", \"C4\")\n\nz &lt;- array(1:24, c(2, 3, 4), dimnames=list(dim1, dim2, dim3))\nz\n## , , C1\n## \n##    B1 B2 B3\n## A1  1  3  5\n## A2  2  4  6\n## \n## , , C2\n## \n##    B1 B2 B3\n## A1  7  9 11\n## A2  8 10 12\n## \n## , , C3\n## \n##    B1 B2 B3\n## A1 13 15 17\n## A2 14 16 18\n## \n## , , C4\n## \n##    B1 B2 B3\n## A1 19 21 23\n## A2 20 22 24",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "07-数据结构.html#列表",
    "href": "07-数据结构.html#列表",
    "title": "7  数据结构",
    "section": "7.6 列表",
    "text": "7.6 列表\n列表，list，是除了数据框之外第二重要的数据结构，甚至可以说是最重要的数据结构，但同时也是最复杂的一种结构。\n列表是一个大型的存储结构，里面啥都能放。比如，可以包含不同类型的数据，也可以包含其他数据结构，如向量、矩阵或数据框等，列表中也可以包含列表。\n\n7.6.1 创建列表\n可以使用函数list()创建列表，使用语法为：\n\nmylist &lt;- list(object1, object2, ...)\n\n其中的对象可以是目前为止讲到的任何结构。你还可以为列表中的对象命名：\n\nmylist &lt;- list(name1=object1, name2=object2, ...)\n\n以下是一个创建列表的示例，我们先创建了5个不同类型的对象，然后把这些对象全部放到1个列表中：\n\ng &lt;- \"My First List\" # 字符串\nh &lt;- c(25, 26, 18, 39) # 数值型向量\nj &lt;- matrix(1:10, nrow=5) # 矩阵\nk &lt;- c(\"one\", \"two\", \"three\") # 字符型向量\nl &lt;- list(\"apple\",1,TRUE) # 列表\n\n# 放到1个列表中\nmylist &lt;- list(title=g, ages=h, j, k, l)\nmylist\n## $title\n## [1] \"My First List\"\n## \n## $ages\n## [1] 25 26 18 39\n## \n## [[3]]\n##      [,1] [,2]\n## [1,]    1    6\n## [2,]    2    7\n## [3,]    3    8\n## [4,]    4    9\n## [5,]    5   10\n## \n## [[4]]\n## [1] \"one\"   \"two\"   \"three\"\n## \n## [[5]]\n## [[5]][[1]]\n## [1] \"apple\"\n## \n## [[5]][[2]]\n## [1] 1\n## \n## [[5]][[3]]\n## [1] TRUE\n\n可以看出列表的成分非常复杂，上面的列表mylist的长度为5，因为有5个成分：\n\n# 查看长度\nlength(mylist)\n## [1] 5\n\n前两个成分是有名字的：title和ages，后三个成分没有名字，但是有序号，分别是[[3]]、[[4]]、[[5]]。\n\n\n7.6.2 列表取子集\n如果你要提取列表中的成分（或者叫对列表取子集），可以直接使用序号或者名字：\n\nmylist[2] # 取第2个成分\n## $ages\n## [1] 25 26 18 39\nmylist[\"title\"] # 取第一个成分\n## $title\n## [1] \"My First List\"\n\n注意此时得到的对象仍然是list：\n\nclass(mylist[2])\n## [1] \"list\"\nclass(mylist[\"title\"])\n## [1] \"list\"\n\n列表中还有一个特殊的操作，也就是[[]]，两个中括号，这样可以直接提取到具体的内容：\n\n# 直接提取具体的内容\nmylist[[\"title\"]]\n## [1] \"My First List\"\n\n# 此时得到的是字符型向量\nclass(mylist[[\"title\"]])\n## [1] \"character\"\n\n或者可以使用$，也可以直接得到具体的内容，但是这种方法只能用于有名字的时候：\n\nmylist$title\n## [1] \"My First List\"\n\n如果使用了[[]]或者$符号取子集后，得到的是具体的内容，我们可以继续通过[]选择其中的元素：\n\n# 取第2个对象中的第1个元素\nmylist[[2]][1]\n## [1] 25\n\n\n\n7.6.3 修改名字\n如果要给列表中的成分添加/修改/删除名字，也是使用names()：\n\n# 给第3-5个对象添加名字\nnames(mylist)[3:5] &lt;- c(\"名字3\",\"名字4\",\"名字5\")\n\n# 或者：\nnames(mylist)[c(3:5)] &lt;- c(\"名字3\",\"名字4\",\"名字5\")\n\n# 查看结果\nnames(mylist)\n## [1] \"title\" \"ages\"  \"名字3\" \"名字4\" \"名字5\"\n\n\n#修改第一个成分的名字：\nnames(mylist)[1] &lt;- \"改个名字\"\nnames(mylist)\n## [1] \"改个名字\" \"ages\"     \"名字3\"    \"名字4\"    \"名字5\"\n\n删除名字：\n\n# 删除所有名字\nnames(mylist) &lt;- NULL\nnames(mylist) # 此时再查看名字已经没有了\n## NULL\n\n\n\n7.6.4 添加/删除列表元素\n如果要向列表中添加新的成分：\n\nmylist[[\"新的元素\"]] &lt;- c(1,2,3)\nmylist\n## [[1]]\n## [1] \"My First List\"\n## \n## [[2]]\n## [1] 25 26 18 39\n## \n## [[3]]\n##      [,1] [,2]\n## [1,]    1    6\n## [2,]    2    7\n## [3,]    3    8\n## [4,]    4    9\n## [5,]    5   10\n## \n## [[4]]\n## [1] \"one\"   \"two\"   \"three\"\n## \n## [[5]]\n## [[5]][[1]]\n## [1] \"apple\"\n## \n## [[5]][[2]]\n## [1] 1\n## \n## [[5]][[3]]\n## [1] TRUE\n## \n## \n## $新的元素\n## [1] 1 2 3\n\n删除列表中的成分：\n\n# 删除第一个成分\nmylist &lt;- mylist[-1]\nmylist\n## [[1]]\n## [1] 25 26 18 39\n## \n## [[2]]\n##      [,1] [,2]\n## [1,]    1    6\n## [2,]    2    7\n## [3,]    3    8\n## [4,]    4    9\n## [5,]    5   10\n## \n## [[3]]\n## [1] \"one\"   \"two\"   \"three\"\n## \n## [[4]]\n## [[4]][[1]]\n## [1] \"apple\"\n## \n## [[4]][[2]]\n## [1] 1\n## \n## [[4]][[3]]\n## [1] TRUE\n## \n## \n## $新的元素\n## [1] 1 2 3\n\n# 或者\nmylist$新的元素 &lt;- NULL\nmylist\n## [[1]]\n## [1] 25 26 18 39\n## \n## [[2]]\n##      [,1] [,2]\n## [1,]    1    6\n## [2,]    2    7\n## [3,]    3    8\n## [4,]    4    9\n## [5,]    5   10\n## \n## [[3]]\n## [1] \"one\"   \"two\"   \"three\"\n## \n## [[4]]\n## [[4]][[1]]\n## [1] \"apple\"\n## \n## [[4]][[2]]\n## [1] 1\n## \n## [[4]][[3]]\n## [1] TRUE\n\n\n\n7.6.5 列表展开\n把列表展开成向量：\n\nunlist(mylist)\n##                                                                                 \n##    \"25\"    \"26\"    \"18\"    \"39\"     \"1\"     \"2\"     \"3\"     \"4\"     \"5\"     \"6\" \n##                                                                                 \n##     \"7\"     \"8\"     \"9\"    \"10\"   \"one\"   \"two\" \"three\" \"apple\"     \"1\"  \"TRUE\"\nclass(unlist(mylist))\n## [1] \"character\"\nstr(unlist(mylist)) # 命名字符型向量\n##  Named chr [1:20] \"25\" \"26\" \"18\" \"39\" \"1\" \"2\" \"3\" \"4\" \"5\" \"6\" \"7\" \"8\" \"9\" ...\n##  - attr(*, \"names\")= chr [1:20] \"\" \"\" \"\" \"\" ...\n\n掌握了这些基本的数据结构和常用操作后，就算是正式入门R语言了，后面的章节会继续一些常用的数据处理操作。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>数据结构</span>"
    ]
  },
  {
    "objectID": "08-类型判断和转换.html",
    "href": "08-类型判断和转换.html",
    "title": "8  类型判断和转换",
    "section": "",
    "text": "8.1 类型判断\n每种类型都有一个判断类型的函数，以下是常见的几个：\n创建几个变量用于演示：\n# 把一个数字存储到变量my_integer中\nmy_integer &lt;- 5\n\ninteger_variable &lt;- 186L\n\n# 把一段文字存储到变量中\nmy_string &lt;- \"Hello, R!\"\n可以直接用class()或者typeof()：\n# 查看变量的类型\nclass(my_integer)\n## [1] \"numeric\"\nclass(integer_variable)\n## [1] \"integer\"\nclass(my_string)\n## [1] \"character\"\n还可以使用is.xxx()判断是不是属于某种类型，比如查看my_integer的类型：\nis.numeric(my_integer) # 是数值型吗？是的，返回TRUE\n## [1] TRUE\nis.logical(my_integer)  # 是逻辑型吗？不是，返回FLASE\n## [1] FALSE\na &lt;- c(1,2,3)\nis.numeric(a)\n## [1] TRUE\nNA表示缺失值，注意不要加引号，加了引号就变成字符型了：\ndd &lt;- NA\nis.na(dd)\n## [1] TRUE\n\ndd &lt;- \"NA\"\nis.na(dd)\n## [1] FALSE\nis.character(dd)\n## [1] TRUE\n创建一个数据框用于演示：\npatientdata &lt;- data.frame(\n  patientID = c(1, 2, 3, 4), \n  age = c(25, 34, 28, 52), \n  diabetes = c(\"Type1\", \"Type2\", \"Type1\", \"Type1\"), \n  status = c(\"Poor\", \"Improved\", \"Excellent\", \"Poor\")\n  )\n\nis.data.frame(patientdata)\n## [1] TRUE\n创建一个矩阵用于演示：\ny &lt;- matrix(1:20, nrow=5, ncol=4,\n            dimnames = list(c(\"行1\",\"行2\",\"行3\",\"行4\",\"行5\"),\n                            c(\"列1\",\"列2\",\"列3\",\"列4\"))\n            ) \nis.matrix(y)\n## [1] TRUE\n创建一个列表用于演示：\ng &lt;- \"My First List\" # 字符串\nh &lt;- c(25, 26, 18, 39) # 数值型向量\nj &lt;- matrix(1:10, nrow=5) # 矩阵\nk &lt;- c(\"one\", \"two\", \"three\") # 字符型向量\nl &lt;- list(\"apple\",1,TRUE) # 列表\n\n# 放到1个列表中\nmylist &lt;- list(title=g, ages=h, j, k, l)\n\nis.list(mylist)\n## [1] TRUE\n#is.vector(mylist)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>类型判断和转换</span>"
    ]
  },
  {
    "objectID": "08-类型判断和转换.html#类型判断",
    "href": "08-类型判断和转换.html#类型判断",
    "title": "8  类型判断和转换",
    "section": "",
    "text": "is.numeric()   # 是不是数值型？\nis.character()\nis.double()\nis.integer()\nis.factor()\nis.complex()\nis.logical()\nis.na() \n\nis.data.frame() # 是不是data.frame\nis.array()\nis.matrix()\nis.list()",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>类型判断和转换</span>"
    ]
  },
  {
    "objectID": "08-类型判断和转换.html#类型转换",
    "href": "08-类型判断和转换.html#类型转换",
    "title": "8  类型判断和转换",
    "section": "8.2 类型转换",
    "text": "8.2 类型转换\n不同的变量之间可以相互转换。常见的类型转换函数：\nas.numeric()   # 变成数值型\nas.character()\nas.double()\nas.integer()\nas.factor()\nas.complex()\nas.logical()\n\nas.data.frame() # 变成数据框\nas.array()\nas.matrix()\nas.list()\n数值型向量转换为字符型/因子型/逻辑型：\n\na &lt;- c(1,2,3)\na\n## [1] 1 2 3\n\nas.character(a) # 变成字符型\n## [1] \"1\" \"2\" \"3\"\nas.factor(a)    # 变成因子型\n## [1] 1 2 3\n## Levels: 1 2 3\nas.logical(a)   # 变成逻辑型，无意义\n## [1] TRUE TRUE TRUE\n\n字符型向量转换：\n\nd &lt;- c(\"你好\",\"我是\",\"阿越\")\nd\n## [1] \"你好\" \"我是\" \"阿越\"\n\nas.numeric(d) # 错误用法，字符怎么能直接变数字呢？\n## Warning: NAs introduced by coercion\n## [1] NA NA NA\nas.factor(d) # 但是可以变因子\n## [1] 你好 我是 阿越\n## Levels: 阿越 你好 我是\n\n因子转换：\n\nf &lt;- factor(c(\"你好\",\"我是\",\"阿越\"))\nf\n## [1] 你好 我是 阿越\n## Levels: 阿越 你好 我是\n\nas.numeric(f) # 直接变数字\n## [1] 2 3 1\nas.character(f)\n## [1] \"你好\" \"我是\" \"阿越\"\n\n矩阵转换：\n\nas.data.frame(y)\n##     列1 列2 列3 列4\n## 行1   1   6  11  16\n## 行2   2   7  12  17\n## 行3   3   8  13  18\n## 行4   4   9  14  19\n## 行5   5  10  15  20\n#as.list(y) # 太长不演示\nas.numeric(y)\n##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20\nas.factor(y)\n##  [1] 1  2  3  4  5  6  7  8  9  10 11 12 13 14 15 16 17 18 19 20\n## Levels: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\nas.character(y)\n##  [1] \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\" \"11\" \"12\" \"13\" \"14\" \"15\"\n## [16] \"16\" \"17\" \"18\" \"19\" \"20\"\n\n数据框转换：\n\nas.matrix(patientdata)\n##      patientID age  diabetes status     \n## [1,] \"1\"       \"25\" \"Type1\"  \"Poor\"     \n## [2,] \"2\"       \"34\" \"Type2\"  \"Improved\" \n## [3,] \"3\"       \"28\" \"Type1\"  \"Excellent\"\n## [4,] \"4\"       \"52\" \"Type1\"  \"Poor\"\nas.list(patientdata)\n## $patientID\n## [1] 1 2 3 4\n## \n## $age\n## [1] 25 34 28 52\n## \n## $diabetes\n## [1] \"Type1\" \"Type2\" \"Type1\" \"Type1\"\n## \n## $status\n## [1] \"Poor\"      \"Improved\"  \"Excellent\" \"Poor\"\nas.character(patientdata)\n## [1] \"c(1, 2, 3, 4)\"                                     \n## [2] \"c(25, 34, 28, 52)\"                                 \n## [3] \"c(\\\"Type1\\\", \\\"Type2\\\", \\\"Type1\\\", \\\"Type1\\\")\"     \n## [4] \"c(\\\"Poor\\\", \\\"Improved\\\", \\\"Excellent\\\", \\\"Poor\\\")\"\n# as.numeric(patientdata) # 错误\n# as.factor(patientdata) # 错误\n\n列表转换：\n\n# as.data.frame(mylist) # 报错\nas.matrix(mylist)\n##       [,1]           \n## title \"My First List\"\n## ages  numeric,4      \n##       integer,10     \n##       character,3    \n##       list,3",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>类型判断和转换</span>"
    ]
  },
  {
    "objectID": "09-数值和字符串处理.html",
    "href": "09-数值和字符串处理.html",
    "title": "9  数值和字符串处理",
    "section": "",
    "text": "9.1 数值处理",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>数值和字符串处理</span>"
    ]
  },
  {
    "objectID": "09-数值和字符串处理.html#数值处理",
    "href": "09-数值和字符串处理.html#数值处理",
    "title": "9  数值和字符串处理",
    "section": "",
    "text": "9.1.1 计算函数\n常见的计算函数：\n\nx &lt;- c(1,2,3,4,5)\n\nsum(x)         # 求和\n## [1] 15\nmean(x)        # 平均数\n## [1] 3\nmedian(x)      # 中位数\n## [1] 3\nsd(x)          # 标准差\n## [1] 1.581139\nvar(x)         # 方差\n## [1] 2.5\nmad(x)         # 绝对中位差 median absolute deviation\n## [1] 1.4826\nquantile(x,probs = c(0.05,0.95)) # 分位数\n##  5% 95% \n## 1.2 4.8\nrange(x)       # 范围\n## [1] 1 5\nmin(x)         # 最小值\n## [1] 1\nmax(x)         # 最大值\n## [1] 5\nscale(x)       # 中心化，标准化\n##            [,1]\n## [1,] -1.2649111\n## [2,] -0.6324555\n## [3,]  0.0000000\n## [4,]  0.6324555\n## [5,]  1.2649111\n## attr(,\"scaled:center\")\n## [1] 3\n## attr(,\"scaled:scale\")\n## [1] 1.581139\n# ?scale\n\n\n\n9.1.2 概率函数(选学)\n由两部分组成：\n\nd：密度函数（density）\np：分布函数（distribution）\nq：分位数函数（quantile）\nr：随机函数（random）\n\n\n随机正态分布：\n\nrnorm(20, mean = 0, sd = 1)\n##  [1]  0.06606979  0.11218606 -0.18664296  0.59302758  0.29447994 -0.58199673\n##  [7]  0.18075259  0.27129457  0.43043429  0.74492802 -2.18811032  1.99239747\n## [13] -0.26223215 -1.05084826 -0.70869772  0.30332293  1.75578519  0.35965006\n## [19] -1.07090020  1.32196111\n\n密度正态分布：\n\ndnorm(20, mean = 0, sd = 1)\n## [1] 5.520948e-88\n\n随机均匀分布：\n\nrunif(20, min = 10, max = 80)\n##  [1] 77.94637 78.53499 78.09488 71.23386 23.10702 72.58297 12.17442 11.60296\n##  [9] 57.25120 39.39330 34.53350 45.26676 65.05557 39.84087 71.70525 22.89368\n## [17] 37.59473 33.98279 48.12517 16.30688\n\n随机过程无法复现，但是可以通过设置随机种子数复现（所以计算机里面的随机是伪随机）：\n\n# 设置随机种子数，你的结果就能和我一样了\nset.seed(123)\nrnorm(20, mean = 0, sd = 1)\n##  [1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774  1.71506499\n##  [7]  0.46091621 -1.26506123 -0.68685285 -0.44566197  1.22408180  0.35981383\n## [13]  0.40077145  0.11068272 -0.55584113  1.78691314  0.49785048 -1.96661716\n## [19]  0.70135590 -0.47279141",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>数值和字符串处理</span>"
    ]
  },
  {
    "objectID": "09-数值和字符串处理.html#字符串处理",
    "href": "09-数值和字符串处理.html#字符串处理",
    "title": "9  数值和字符串处理",
    "section": "9.2 字符串处理",
    "text": "9.2 字符串处理\n常用的字符处理函数：\n\n以第5章导入的TCGA乳腺癌数据为例。先读取数据：\n\ndf &lt;- read.csv(\"datasets/brca_clin.csv\", header = T)\n\n# 检查下数据的基本结构\ndim(df)\n## [1] 20  9\nstr(df)\n## 'data.frame':    20 obs. of  9 variables:\n##  $ barcode               : chr  \"TCGA-BH-A1FC-11A-32R-A13Q-07\" \"TCGA-AC-A2FM-11B-32R-A19W-07\" \"TCGA-BH-A0DO-11A-22R-A12D-07\" \"TCGA-E2-A1BC-11A-32R-A12P-07\" ...\n##  $ patient               : chr  \"TCGA-BH-A1FC\" \"TCGA-AC-A2FM\" \"TCGA-BH-A0DO\" \"TCGA-E2-A1BC\" ...\n##  $ sample                : chr  \"TCGA-BH-A1FC-11A\" \"TCGA-AC-A2FM-11B\" \"TCGA-BH-A0DO-11A\" \"TCGA-E2-A1BC-11A\" ...\n##  $ sample_type           : chr  \"Solid Tissue Normal\" \"Solid Tissue Normal\" \"Solid Tissue Normal\" \"Solid Tissue Normal\" ...\n##  $ initial_weight        : int  260 220 130 260 200 60 320 310 100 250 ...\n##  $ ajcc_pathologic_stage : chr  \"Stage IIA\" \"Stage IIB\" \"Stage I\" \"Stage IA\" ...\n##  $ days_to_last_follow_up: int  NA NA 1644 501 660 3247 NA NA 1876 707 ...\n##  $ gender                : chr  \"female\" \"female\" \"female\" \"female\" ...\n##  $ age_at_index          : int  78 87 78 63 41 59 60 39 54 51 ...\nhead(df)\n##                        barcode      patient           sample\n## 1 TCGA-BH-A1FC-11A-32R-A13Q-07 TCGA-BH-A1FC TCGA-BH-A1FC-11A\n## 2 TCGA-AC-A2FM-11B-32R-A19W-07 TCGA-AC-A2FM TCGA-AC-A2FM-11B\n## 3 TCGA-BH-A0DO-11A-22R-A12D-07 TCGA-BH-A0DO TCGA-BH-A0DO-11A\n## 4 TCGA-E2-A1BC-11A-32R-A12P-07 TCGA-E2-A1BC TCGA-E2-A1BC-11A\n## 5 TCGA-BH-A0BJ-11A-23R-A089-07 TCGA-BH-A0BJ TCGA-BH-A0BJ-11A\n## 6 TCGA-E2-A1LH-11A-22R-A14D-07 TCGA-E2-A1LH TCGA-E2-A1LH-11A\n##           sample_type initial_weight ajcc_pathologic_stage\n## 1 Solid Tissue Normal            260             Stage IIA\n## 2 Solid Tissue Normal            220             Stage IIB\n## 3 Solid Tissue Normal            130               Stage I\n## 4 Solid Tissue Normal            260              Stage IA\n## 5 Solid Tissue Normal            200             Stage IIB\n## 6 Solid Tissue Normal             60               Stage I\n##   days_to_last_follow_up gender age_at_index\n## 1                     NA female           78\n## 2                     NA female           87\n## 3                   1644 female           78\n## 4                    501 female           63\n## 5                    660 female           41\n## 6                   3247 female           59\n\n计算字符数量：\n\nx &lt;- df$barcode[1:3]\nx\n## [1] \"TCGA-BH-A1FC-11A-32R-A13Q-07\" \"TCGA-AC-A2FM-11B-32R-A19W-07\"\n## [3] \"TCGA-BH-A0DO-11A-22R-A12D-07\"\n\nnchar(x)\n## [1] 28 28 28\n\n截取字符串、替换字符串：\n\nx &lt;- df$barcode[1]\nx\n## [1] \"TCGA-BH-A1FC-11A-32R-A13Q-07\"\n\nsubstr(x, start = 1, stop = 15)\n## [1] \"TCGA-BH-A1FC-11\"\nsubstr(x, start = 1, stop = 3) &lt;- \"ggg\"\nx\n## [1] \"gggA-BH-A1FC-11A-32R-A13Q-07\"\n\n查找字符串：\n\nx &lt;- c(df$barcode[1:3], \"hahahaha\")\nx\n## [1] \"TCGA-BH-A1FC-11A-32R-A13Q-07\" \"TCGA-AC-A2FM-11B-32R-A19W-07\"\n## [3] \"TCGA-BH-A0DO-11A-22R-A12D-07\" \"hahahaha\"\n\ngrep(\"TCGA\", x)\n## [1] 1 2 3\n\ngrepl(\"TCGA\", x)\n## [1]  TRUE  TRUE  TRUE FALSE\n\n搜索替换，横岗变成下划线：\n\nx &lt;- df$barcode[1:5]\nx\n## [1] \"TCGA-BH-A1FC-11A-32R-A13Q-07\" \"TCGA-AC-A2FM-11B-32R-A19W-07\"\n## [3] \"TCGA-BH-A0DO-11A-22R-A12D-07\" \"TCGA-E2-A1BC-11A-32R-A12P-07\"\n## [5] \"TCGA-BH-A0BJ-11A-23R-A089-07\"\n\nsub(\"-\",\"_\",x)\n## [1] \"TCGA_BH-A1FC-11A-32R-A13Q-07\" \"TCGA_AC-A2FM-11B-32R-A19W-07\"\n## [3] \"TCGA_BH-A0DO-11A-22R-A12D-07\" \"TCGA_E2-A1BC-11A-32R-A12P-07\"\n## [5] \"TCGA_BH-A0BJ-11A-23R-A089-07\"\ngsub(\"-\",\"_\",x)\n## [1] \"TCGA_BH_A1FC_11A_32R_A13Q_07\" \"TCGA_AC_A2FM_11B_32R_A19W_07\"\n## [3] \"TCGA_BH_A0DO_11A_22R_A12D_07\" \"TCGA_E2_A1BC_11A_32R_A12P_07\"\n## [5] \"TCGA_BH_A0BJ_11A_23R_A089_07\"\n\n分割字符串：\n\nx &lt;- df$barcode[1]\nx\n## [1] \"TCGA-BH-A1FC-11A-32R-A13Q-07\"\n\nstrsplit(x, split = \"-\")\n## [[1]]\n## [1] \"TCGA\" \"BH\"   \"A1FC\" \"11A\"  \"32R\"  \"A13Q\" \"07\"\n\n连接字符串：\n\npaste(\"haha\",1:3,sep = \"\")\n## [1] \"haha1\" \"haha2\" \"haha3\"\npaste(\"haha\",1:3,sep = \" \")\n## [1] \"haha 1\" \"haha 2\" \"haha 3\"\npaste(\"haha\",1:3,sep = \"OOO\")\n## [1] \"hahaOOO1\" \"hahaOOO2\" \"hahaOOO3\"\npaste(\"今天是\",date())\n## [1] \"今天是 Sun Nov 17 10:31:52 2024\"\n\npaste0(\"haha\",1:3)\n## [1] \"haha1\" \"haha2\" \"haha3\"\n\n大小写转换：\n\nx &lt;- c(\"asdf\",\"asdf\",\"ghb\")\ntoupper(x)\n## [1] \"ASDF\" \"ASDF\" \"GHB\"\n\nx &lt;- c(\"SADFf\",\"FAFFaa\")\ntolower(x)\n## [1] \"sadff\"  \"faffaa\"\n\n\n\n\n\n\n\n注释\n\n\n\n更高级的字符处理技术请学习R包stringr和正则表达式，非常强大！",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>数值和字符串处理</span>"
    ]
  },
  {
    "objectID": "10-控制结构和自编函数.html",
    "href": "10-控制结构和自编函数.html",
    "title": "10  控制结构和自编函数",
    "section": "",
    "text": "10.1 循环结构\n在处理实际问题时，我们经常会遇到以下问题，比如：重复执行某个操作，这时候就要用到一些常见的控制语句，比如：for循环、while循环等。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>控制结构和自编函数</span>"
    ]
  },
  {
    "objectID": "10-控制结构和自编函数.html#循环结构",
    "href": "10-控制结构和自编函数.html#循环结构",
    "title": "10  控制结构和自编函数",
    "section": "",
    "text": "10.1.1 for循环\n重复执行某个操作，直到变量的值不再包含在序列seq中为止。基本语法：\nfor (var in seq) { statment }\n举个简单的例子，对于1-5中的每个数字，都打印你好：\n\n# i会从1开始一直取到5\nfor(i in 1:5) { \n  print(\"你好\")\n}\n## [1] \"你好\"\n## [1] \"你好\"\n## [1] \"你好\"\n## [1] \"你好\"\n## [1] \"你好\"\n\n在实际使用时，最好先准备一个容器，用来存放for循环的输出，这样可以加快运行速度。\n假如我们有一个数据框如下：\n\nset.seed(123)\ndf &lt;- data.frame(a = rnorm(10),\n                 b = rnorm(10),\n                 c = rnorm(10),\n                 d = rnorm(10)\n                 )\ndf\n##              a          b          c           d\n## 1  -0.56047565  1.2240818 -1.0678237  0.42646422\n## 2  -0.23017749  0.3598138 -0.2179749 -0.29507148\n## 3   1.55870831  0.4007715 -1.0260044  0.89512566\n## 4   0.07050839  0.1106827 -0.7288912  0.87813349\n## 5   0.12928774 -0.5558411 -0.6250393  0.82158108\n## 6   1.71506499  1.7869131 -1.6866933  0.68864025\n## 7   0.46091621  0.4978505  0.8377870  0.55391765\n## 8  -1.26506123 -1.9666172  0.1533731 -0.06191171\n## 9  -0.68685285  0.7013559 -1.1381369 -0.30596266\n## 10 -0.44566197 -0.4727914  1.2538149 -0.38047100\n\n现在我们要计算每列的中位数，我们可以使用for循环实现：\n\n准备容器：结果是4个中位数，所以是double类型，数量是4个，所以容器是一个double型的向量，长度为4；\nfor循环本体\n\n\noutput &lt;- vector(\"double\", ncol(df)) # 准备容器\n\nfor(i in 1:ncol(df)){                # 此时的i表示1，2，3，4\n  output[i] &lt;- median(df[,i])\n}\n\noutput\n## [1] -0.07983455  0.38029264 -0.67696525  0.49019094\n\n以上也是最常见的for循环的结构，主要包括3个部分：\n\n输出：output &lt;- vector(\"double\", ncol(df))。在开始循环之前就要给输出分配足够的空间，这样做可以提高运行速度；\n迭代器：i in 1:ncol(df)。\n循环体：output[i] &lt;- median(df[,i])。这部分是具体运行的操作，每次运行都会使用一个不同的i值，第1次是output[1] &lt;- median(df[,1])，第2次是output[2] &lt;- median(df[,2])，以此类推。\n\n\n\n\n\n\n\n注意\n\n\n\n用seq_along(xx)代替1:length(xx)是更好的选择，这样可以避免向量长度为0时报错。所以上面的代码也可以写成for(i in seq_along(df)){statment}\n\n\n除了直接使用数字序号（索引）作为迭代器，也可以使用列名作为迭代器：\n\noutput &lt;- vector(\"double\", ncol(df)) # 准备容器\nnames(output) &lt;- colnames(df) # 给容器也准备好名字\n\nfor(i in colnames(df)){                # 此时的i表示列名\n  output[i] &lt;- median(df[,i])\n}\n\noutput\n##           a           b           c           d \n## -0.07983455  0.38029264 -0.67696525  0.49019094\n\n可以单独把循环体拿出来运行一下看看：\n\noutput[\"a\"] &lt;- median(df[,\"a\"])\n\n\n\n10.1.2 while循环\nwhile循环也是重复执行某个操作，直到条件不再满足为止，适用于不知道循环几次的情况。\nwhile (cond) { statment }\nwhile循环比for循环简单，for循环总是可以改写成while循环，但是while循环不一定能改写成for循环：\nfor( i in seq_along(x)){\n  statment\n}\n\n# 等价于\ni = 1\nwhile(i &lt;= length(x)){\n  statment\n  i = i +1\n}\nwhile循环不如for循环常见，大家感兴趣可以自己学习。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>控制结构和自编函数</span>"
    ]
  },
  {
    "objectID": "10-控制结构和自编函数.html#分支结构",
    "href": "10-控制结构和自编函数.html#分支结构",
    "title": "10  控制结构和自编函数",
    "section": "10.2 分支结构",
    "text": "10.2 分支结构\n如果符合条件（必须返回逻辑值，即TRUE或者FALSE），就执行某个操作。是大家中学数学中都学过的if-else结构。if-else经常和for循环连用。\n\n10.2.1 if-else\n1个分支的情况比较少见，但是也有，基本语法如下：\nif(条件) {\n  操作\n}\n举个简单例子，如果x&gt;5，就打印“大于5”：\n\nx &lt;- 5\n\nif(x &gt; 5){print(\"大于5\")}\n\n# 可以简写成\nif(x &gt; 5) print(\"大于5\")\n\n两个分支是最常见的操作，如果符合条件，就执行某个操作，如果不符合，就执行另一个操作。基本语法为：\nif(条件){\n  操作1\n} else {\n  操作2\n}\n这种结构由于比较常见，也可以简写为：\n# 这种写法使用很频繁\nifelse(条件, 操作1, 操作2)\n使用第5章开头用的TCGA的乳腺癌数据为例。\nTCGA每个样本的barcode是有明确含义的，它的第14位和第15位数字如果小于10，说明这个样本是tumor，否则就是normal。\n我们可以根据此特点，创建一个新的变量用来表示样本类型（tumor还是normal）。\n\n# 读取数据\ndf &lt;- read.csv(\"datasets/brca_clin.csv\", header = T)\n\n# 展示下第一个样本的barcode\ndf$barcode[1]\n## [1] \"TCGA-BH-A1FC-11A-32R-A13Q-07\"\n\n# 新建一个变量，用来表示样本类型\ngroup &lt;- ifelse(as.numeric(substr(df$barcode,14,15))&lt;10,\"tumor\", \"normal\")\ngroup\n##  [1] \"normal\" \"normal\" \"normal\" \"normal\" \"normal\" \"normal\" \"normal\" \"normal\"\n##  [9] \"normal\" \"normal\" \"tumor\"  \"tumor\"  \"tumor\"  \"tumor\"  \"tumor\"  \"tumor\" \n## [17] \"tumor\"  \"tumor\"  \"tumor\"  \"tumor\"\n\n如果一个表达式函数太多，你看不懂，那你就从最里面一层开始看。比如上面的最后1行代码，我们从最里面的一层开始看：\n\ndf$barcode：取df的barcode这一列\nsubstr(df$barcode,14,15)：截取barcode的第14位和第15位\nas.numeric(substr(df$barcode,14,15)：把第14位和第15位转换为数值型，以便和10比较\nas.numeric(substr(df$barcode,14,15))&lt;10：判断是不是小于10，返回TRUE或者FALSE\nifelse(xxx, \"tumor\", \"normal\")：根据条件执行操作\n\n多个分支也是常见操作，基本语法如下：\nif(条件1) {\n  操作1\n} else if(条件2) {\n  操作2\n} else if(条件n) {\n  操作n\n} else {\n  操作x\n}\n中间可以有任意多个条件和操作。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>控制结构和自编函数</span>"
    ]
  },
  {
    "objectID": "10-控制结构和自编函数.html#自编函数",
    "href": "10-控制结构和自编函数.html#自编函数",
    "title": "10  控制结构和自编函数",
    "section": "10.3 自编函数",
    "text": "10.3 自编函数\n有时可能并没有合适的、可直接使用的R包能满足我们个性化的需求，这时候就需要自己写函数实现。\n在使用代码实现自己的需求前，首先你自己得搞清楚解决这个问题的逻辑，也就是你脑海中要知道，为了解决这个问题，第一步需要做什么？第二步需要做什么？第三步需要做什么？要明确定义解决这个问题的逻辑，然后再通过代码实现你的这几个步骤。\n一个函数的结构如下所示：\nmyfunction &lt;- function(参数1, 参数2, ... ){\n  操作\n  return(返回值)\n}\n假如你想编写一个函数，用来计算一个数值型向量的集中趋势（均值和标准差）或者离散趋势（中位数和绝对中位差），默认是计算均值和标准差，但是也可以通过修改参数，让函数计算中位数和绝对中位差。\n为了写出这个函数，我们首先确定，这个函数需要哪些参数？它的最终返回结果是什么？\n对于这个问题来说，第一个参数就是一个数值型向量；除此之外，还需要第2个参数，用来控制到底是计算集中趋势还是计算离散趋势。\n函数的输出结果就是两个值，要么是均值和标准差，要么是中位数和绝对中位差。\n然后是确定具体的执行步骤，对于这个问题也就是计算均值和标准差（或者中位数和绝对中位差），如何实现呢？这个问题当然是通过if-else了，如果满足条件就计算集中趋势，不满足就计算离散趋势。\n确定好具体的步骤之后，我们就可以开始写这个函数了。\n\nmystats &lt;- function(v, center=TRUE){ # 2个参数，第2个参数默认值是TRUE\n  if(center == TRUE){          # 满足条件则...\n    均值 &lt;- mean(v)\n    标准差 &lt;- sd(v)\n    res &lt;- c(均值,标准差)\n  } else {                     # 不满足条件则...\n    中位数 &lt;- median(v)\n    绝对中位差 &lt;- mad(v)\n    res &lt;- c(中位数, 绝对中位差)\n  }\n  return(res) # 不写这句也可以\n}\n\n写好之后，要使用这个函数，你可以直接全选这个函数，然后Run一下，就可以在Environment面板中看到这个函数了：\n\n然后就可以使用了。\n随机创建一个数值型向量用于演示：\n\nset.seed(1234)\nx &lt;- rnorm(500)\n\n用编写的函数计算：\n\n# center=TRUE 可以不写，不写就是默认TRUE，计算集中趋势\ny &lt;- mystats(v = x)\ny\n## [1] 0.001838821 1.034813946\n\n# 或者计算离散趋势\ny &lt;- mystats(v = x, center = F)\ny\n## [1] -0.02070734  1.00098385\n\n除了选中运行外，还可以把这个函数保存为一个R脚本文件，要使用前先source一下即可。\n我们把上面的函数保存为mystats.R，然后source一（注意路径问题）下：\n\nsource(\"mystats.R\") # 注意路径\n\n看看Environment面板中是不是出现了这个函数？",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>控制结构和自编函数</span>"
    ]
  },
  {
    "objectID": "10-控制结构和自编函数.html#实战1",
    "href": "10-控制结构和自编函数.html#实战1",
    "title": "10  控制结构和自编函数",
    "section": "10.4 实战1",
    "text": "10.4 实战1\n再来一个实战。for循环和if-else连用。\n我们根据年龄将TCGA中的样本分为老年、中年、青年，如果年龄小于40岁，就是“青年”，如果大于等于40且小于60，就是“中年”，否则就是“老年”。\n先在脑海中想一下，怎么用计算机语言实现这一过程。\n因为有条件（如果xxx就xxx，如果不xxx就zzz），所以肯定要用到if-else；然后对于每一个年龄，都要判断是不是满足条件，所以要用到for循环。\n先定义一个容器，然后准备序列，然后根据条件判断。\n\n# 定义一个容器\nage_groups &lt;- vector(\"character\", length(df$age_at_index))\n\nfor (i in 1:length(df$age_at_index)) {  # 序列\n  if(df$age_at_index[i] &lt; 40) {         # 判断条件\n    age_groups[i] &lt;- \"青年\"\n  } else if (df$age_at_index[i] &gt;= 40 & df$age_at_index[i] &lt;= 60) {\n    age_groups[i] &lt;- \"中年\"\n  } else if (df$age_at_index[i] &gt; 60) {\n    age_groups[i] &lt;- \"老年\"\n  }\n}\n\nage_groups\n##  [1] \"老年\" \"老年\" \"老年\" \"老年\" \"中年\" \"中年\" \"中年\" \"青年\" \"中年\" \"中年\"\n## [11] \"中年\" \"中年\" \"老年\" \"中年\" \"老年\" \"老年\" \"老年\" \"中年\" \"中年\" \"青年\"\n\n是不是还算简单，并没有想象中的难。\n这个函数还有很多可以改进的地方，当你学习深入后可以尝试一下。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>控制结构和自编函数</span>"
    ]
  },
  {
    "objectID": "10-控制结构和自编函数.html#实战2",
    "href": "10-控制结构和自编函数.html#实战2",
    "title": "10  控制结构和自编函数",
    "section": "10.5 实战2",
    "text": "10.5 实战2\n批量把多个数据框保存到不同的csv文件中，或者批量读取多个文件。这里是以csv文件为例进行演示，其他类型的文件同理。\n假设有以下6个数据框：\n\ndf1 &lt;- data.frame(\n  patientID = c(\"甲\",\"乙\",\"丙\",\"丁\"),\n  age = c(23,43,45,34),\n  gender = c(\"男\",\"女\",\"女\",\"男\")\n)\n\ndf2 &lt;- data.frame(\n  patientID = c(\"甲\",\"乙\",\"戊\",\"几\",\"庚\",\"丁\"),\n  hb = c(110,124,138,142,108,120),\n  wbc = c(3.7,4.6,6.4,4.2,5.6,5.2)\n)\n\ndf3 &lt;- data.frame(\n  patientID = c(\"丙\",\"乙\",\"几\",\"庚\",\"丁\"),\n  rbc = c(4.5,4.3,4.5,3.4,4.2),\n  plt = c(180,250,360,120,220))\n\ndf4 &lt;- data.frame(\n  patientID = c(\"丙\",\"乙\",\"几\",\"庚\",\"丁\",\"甲\",\"戊\"),\n  a = rnorm(7, 20),\n  b = rnorm(7,10)\n)\n\ndf5 &lt;- data.frame(\n  patientID = c(\"丙\",\"乙\",\"甲\",\"戊\"),\n  d = rnorm(4, 2),\n  e = rnorm(4,1)\n)\n\ndf6 &lt;- data.frame(\n  patientID = c(\"乙\",\"几\",\"庚\",\"丁\"),\n  f = rnorm(4, 2),\n  g = rnorm(4,1)\n)\n\n\n10.5.1 批量保存多个文件\n把这6个数据框单独保存为6个csv文件。\n首先把这6个数据框放到一起，一般选择放到一个列表中，然后使用for循环批量保存：\n\n# 放到1个列表中\ndataframes &lt;- list(df1,df2,df3,df4,df5,df6)\n\nfor(i in 1:length(dataframes)){    # 对于列表中的每一个，都执行一个操作\n  write.csv(dataframes[[i]],  # 使用数字序号选择列表中的对象\n            file = paste0(\"datasets/csvs/\",\"df\",i,\".csv\"),\n            quote = F,row.names = F)\n}\n\n打开电脑看看是不是已经保存好了6个csv文件？\n不懂的话先看看最里面的输出内容：\n\n# 此时的i表示1，2，3，4，5，6\npaste0(\"datasets/csvs/\",\"df\",1,\".csv\")\n## [1] \"datasets/csvs/df1.csv\"\n\n如果这个列表中的对象都有名字的话：\n\ndataframes &lt;- list(df1,df2,df3,df4,df5,df6)  # 放到1个列表中\nnames(dataframes) &lt;- c(\"df1\",\"df2\",\"df3\",\"df4\",\"df5\",\"df6\") # 添加名字\nnames(dataframes) # 查看名字\n## [1] \"df1\" \"df2\" \"df3\" \"df4\" \"df5\" \"df6\"\n\nfor(i in names(dataframes)){\n  write.csv(dataframes[[i]],  # 使用对象名字选择对象\n            file = paste0(\"datasets/csvs/\",i,\".csv\"),\n            quote = F,row.names = F)\n}\n\n不懂的话还是可以先看以下最里面的输出内容：\n\n# 第1个i就是\"df1\"\npaste0(\"datasets/csvs/\",\"df1\",\".csv\")\n## [1] \"datasets/csvs/df1.csv\"\n\n对于for循环来说，比较常见的迭代器就是数字序号（索引）或者名字，二者在使用中基本相同，注意序列中具体指代的东西，使用数字序号的方法更加常见。\n\n\n10.5.2 批量读取多个文件\n多个表格的批量读取。\n首先查看（获取）要读取的文件名：\n\nallfiles &lt;- list.files(\"datasets/csvs\")\nallfiles\n## [1] \"df1.csv\" \"df2.csv\" \"df3.csv\" \"df4.csv\" \"df5.csv\" \"df6.csv\"\n\n批量读取：\n\n# 先设置容器\ndfs &lt;- vector(\"list\", length(allfiles))\n\nfor(i in 1:length(allfiles)){\n  dfs[[i]] &lt;- read.csv(file = paste0(\"datasets/csvs/\",\"df\",i,\".csv\"))\n}\n\n查看第1个：\n\ndfs[[1]]\n##   patientID age gender\n## 1        甲  23     男\n## 2        乙  43     女\n## 3        丙  45     女\n## 4        丁  34     男\n\n如果你不会用paste0，没关系，可以直接使用路径名+文件名：\n\nallfiles &lt;- list.files(\"datasets/csvs\",full.names = T)\nallfiles\n## [1] \"datasets/csvs/df1.csv\" \"datasets/csvs/df2.csv\" \"datasets/csvs/df3.csv\"\n## [4] \"datasets/csvs/df4.csv\" \"datasets/csvs/df5.csv\" \"datasets/csvs/df6.csv\"\n\n\n# 先设置容器\ndfs &lt;- vector(\"list\", length(allfiles))\n\nfor(i in 1:length(allfiles)){\n  dfs[[i]] &lt;- read.csv(file = allfiles[[i]])\n}\n\ndfs[[1]]\n##   patientID age gender\n## 1        甲  23     男\n## 2        乙  43     女\n## 3        丙  45     女\n## 4        丁  34     男",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>控制结构和自编函数</span>"
    ]
  },
  {
    "objectID": "11-apply系列.html",
    "href": "11-apply系列.html",
    "title": "11  apply系列",
    "section": "",
    "text": "11.1 apply\n对数据框（或矩阵）按行或者按列执行某个操作。\n下面使用一个例子演示。示例数据是从TCGA官网下载的COAD的mrna的表达矩阵，一共有1000行，100列，每一行表示一个基因，每一列表示一个样本。\nload(file = \"datasets/coad_mran_df.rdata\")\n\ndim(coad_mrna_df)\n## [1] 1000  100\nclass(coad_mrna_df)\n## [1] \"data.frame\"\ncoad_mrna_df[1:4,1:3]\n##        TCGA-5M-AAT6-01A-11R-A41B-07 TCGA-AA-3552-01A-01R-0821-07\n## MT-CO2                     28026.23                     32915.04\n## MT-CO3                     29725.85                     30837.60\n## MT-ND4                     19509.82                     22026.42\n## MT-CO1                     23193.16                     20924.84\n##        TCGA-AA-3867-01A-01R-1022-07\n## MT-CO2                     21030.00\n## MT-CO3                     21997.99\n## MT-ND4                     17171.58\n## MT-CO1                     15485.43\n如果要对表达矩阵进行log2转换，无需单独对每个元素进行log2，直接对整个数据框进行log2即可：\ncoad_mrna_df &lt;- log2(coad_mrna_df + 1)\n如果要计算每一个基因在所有样本中的平均表达量，也就是计算每一行的平均值，使用apply就非常简单：\n# apply主要是3个参数\n# 第1个是你的数据框\n# 第2个是选择行或者列，1表示行，2表示列\n# 第3个是要执行的操作，可以是R自带函数，也可以是自编函数\n# 自带函数不用加括号，直接写名字即可\ntmp &lt;- apply(coad_mrna_df, 1, mean)\nhead(tmp)\n##   MT-CO2   MT-CO3   MT-ND4   MT-CO1  MT-ATP6   MT-ND3 \n## 14.59276 14.43845 14.01330 14.04316 13.57397 13.40406\n如果使用for循环，就会显得很麻烦，运行时间也会长一点：\ntmp &lt;- vector(\"numeric\", nrow(coad_mrna_df))\nfor(i in 1:nrow(coad_mrna_df)){\n  tmp[i] &lt;- mean(as.numeric(coad_mrna_df[i,]))\n}\nhead(tmp)\n## [1] 14.59276 14.43845 14.01330 14.04316 13.57397 13.40406\n除了3个主要的参数，apply还有一个...参数，它表示：如果你要执行的操作中还有其他参数，可以直接往后写。比如mean()这个函数有一个na.rm参数，表示要不要在计算时去除缺失值，你可以直接把这个参数写在后面：\ntmp &lt;- apply(coad_mrna_df, 1, mean, na.rm = TRUE) # na.rm是mean的参数\nhead(tmp)\n##   MT-CO2   MT-CO3   MT-ND4   MT-CO1  MT-ATP6   MT-ND3 \n## 14.59276 14.43845 14.01330 14.04316 13.57397 13.40406\n如果要计算每一列的平均值，第2个参数就写2即可：\n# 1是行，2是列\ntmp &lt;- apply(coad_mrna_df, 2, mean, na.rm = TRUE)\nhead(tmp)\n## TCGA-5M-AAT6-01A-11R-A41B-07 TCGA-AA-3552-01A-01R-0821-07 \n##                     7.754459                     7.921157 \n## TCGA-AA-3867-01A-01R-1022-07 TCGA-AD-6895-01A-11R-1928-07 \n##                     8.131564                     8.198273 \n## TCGA-AA-3560-01A-01R-0821-07 TCGA-CM-6676-01A-11R-1839-07 \n##                     7.917137                     8.056527\n上面的示例只是为了演示apply的用法，实际上在计算某一行/列的均值/加和时，R自带了几个函数，比如计算每一行的均值：\ntmp &lt;- rowMeans(coad_mrna_df)\nhead(tmp)\n##   MT-CO2   MT-CO3   MT-ND4   MT-CO1  MT-ATP6   MT-ND3 \n## 14.59276 14.43845 14.01330 14.04316 13.57397 13.40406\n其他几个类似函数：\n下面比较一下3种方法的运行时间：\nsystem.time({  # 最慢\n  tmp &lt;- vector(\"numeric\", nrow(coad_mrna_df))\n  for(i in 1:nrow(coad_mrna_df)){\n    tmp[i] &lt;- mean(as.numeric(coad_mrna_df[i,]))\n    }\n})\n##    user  system elapsed \n##    0.38    0.00    0.39\nsystem.time(tmp &lt;- apply(coad_mrna_df, 1, mean))\n##    user  system elapsed \n##    0.00    0.00    0.02\nsystem.time(tmp &lt;- rowMeans(coad_mrna_df)) # 最快\n##    user  system elapsed \n##       0       0       0\n要执行的操作除了可以是R自带的函数外，还可以是自编函数。比如：筛选在所有样本中的表达量的加和大于800的基因：\n# 对每一行执行1个操作\n# 计算每一行的加和，并和800进行比较 \ntmp &lt;- apply(coad_mrna_df, 1, function(x){sum(x)&gt;800})\nhead(tmp)\n##  MT-CO2  MT-CO3  MT-ND4  MT-CO1 MT-ATP6  MT-ND3 \n##    TRUE    TRUE    TRUE    TRUE    TRUE    TRUE\ntable(tmp)\n## tmp\n## FALSE  TRUE \n##   650   350\n#coad_mrna_df[tmp,]\n当然上面只是为了演示如何在apply中使用自编函数，实际使用时还是用rowSums更快更简单：\ntmp &lt;- rowSums(coad_mrna_df) &gt; 800\nhead(tmp)\n##  MT-CO2  MT-CO3  MT-ND4  MT-CO1 MT-ATP6  MT-ND3 \n##    TRUE    TRUE    TRUE    TRUE    TRUE    TRUE\ntable(tmp)\n## tmp\n## FALSE  TRUE \n##   650   350\n再举个例子，选择方差大于1的行（方差小说明这个基因在所有样本中表达量都很接近，这种基因没有意义）\ntmp &lt;- coad_mrna_df[apply(coad_mrna_df,1,function(x){var(x)&gt;1}),]\ndim(tmp)\n## [1] 178 100",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>apply系列</span>"
    ]
  },
  {
    "objectID": "11-apply系列.html#apply",
    "href": "11-apply系列.html#apply",
    "title": "11  apply系列",
    "section": "",
    "text": "rowMeans()\nrowSums()\ncolMeans()\ncolSums()",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>apply系列</span>"
    ]
  },
  {
    "objectID": "11-apply系列.html#lapply",
    "href": "11-apply系列.html#lapply",
    "title": "11  apply系列",
    "section": "11.2 lapply",
    "text": "11.2 lapply\n对list的每一个对象执行某个操作，或者对data.frame的每一列执行某个操作，输出结果是list。lapply的首字母就是list的首字母。\n使用方法：\nlapply(X, FUN, ...)\n\n# x是你的数据框或者列表\n# FUN是你要执行的操作\n# ...和apply中的...一样\n比如，选择方差大于1的列：\n\n# ?lapply\n# 和apply非常像，但是不用选择行或列，默认就是列\ntmp &lt;- lapply(coad_mrna_df, function(x){var(x)&gt;1})\n\nclass(tmp)\n## [1] \"list\"\nlength(tmp)\n## [1] 100\n\n# coad_mrna_df[tmp,]\n\n计算每一列的中位数：\n\ntmp &lt;- lapply(coad_mrna_df, median)\nclass(tmp)\n## [1] \"list\"\nlength(tmp)\n## [1] 100\n\n展开列表：\n\nclass(unlist(tmp))\n## [1] \"numeric\"\n\n查看列表中每个对象的长度：\n\n# 创建一个列表\ng &lt;- \"My First List\" # 字符串\nh &lt;- c(25, 26, 18, 39) # 数值型向量\nj &lt;- matrix(1:10, nrow=5) # 矩阵\nk &lt;- c(\"one\", \"two\", \"three\") # 字符型向量\nl &lt;- list(\"apple\",1,TRUE) # 列表\n\nmylist &lt;- list(title=g, ages=h, j, k, l)\n\n查看每个对象的长度：\n\nlapply(mylist, length)\n## $title\n## [1] 1\n## \n## $ages\n## [1] 4\n## \n## [[3]]\n## [1] 10\n## \n## [[4]]\n## [1] 3\n## \n## [[5]]\n## [1] 3\nunlist(lapply(mylist, length))\n## title  ages                   \n##     1     4    10     3     3\n\n多个数据框的批量保存，lapply版本：\n\ndf1 &lt;- data.frame(\n  patientID = c(\"甲\",\"乙\",\"丙\",\"丁\"),\n  age = c(23,43,45,34),\n  gender = c(\"男\",\"女\",\"女\",\"男\")\n)\n\ndf2 &lt;- data.frame(\n  patientID = c(\"甲\",\"乙\",\"戊\",\"几\",\"庚\",\"丁\"),\n  hb = c(110,124,138,142,108,120),\n  wbc = c(3.7,4.6,6.4,4.2,5.6,5.2)\n)\n\ndf3 &lt;- data.frame(\n  patientID = c(\"丙\",\"乙\",\"几\",\"庚\",\"丁\"),\n  rbc = c(4.5,4.3,4.5,3.4,4.2),\n  plt = c(180,250,360,120,220))\n\ndf4 &lt;- data.frame(\n  patientID = c(\"丙\",\"乙\",\"几\",\"庚\",\"丁\",\"甲\",\"戊\"),\n  a = rnorm(7, 20),\n  b = rnorm(7,10)\n)\n\ndf5 &lt;- data.frame(\n  patientID = c(\"丙\",\"乙\",\"甲\",\"戊\"),\n  d = rnorm(4, 2),\n  e = rnorm(4,1)\n)\n\ndf6 &lt;- data.frame(\n  patientID = c(\"乙\",\"几\",\"庚\",\"丁\"),\n  f = rnorm(4, 2),\n  g = rnorm(4,1)\n)\n\n使用lapply的方式和for循环非常像。\n先把这些数据框放到一个列表中：\n\ndataframes &lt;- list(df1,df2,df3,df4,df5,df6)\n\n然后批量保存，和前面的for循环比较一下，是不是基本一样？\n\nlapply(1:length(dataframes), function(x){ \n  write.csv(dataframes[[x]],\n            file = paste0(\"datasets/csvs/\",\"df\",x,\".csv\"),\n            quote = F,row.names = F)\n})\n## [[1]]\n## NULL\n## \n## [[2]]\n## NULL\n## \n## [[3]]\n## NULL\n## \n## [[4]]\n## NULL\n## \n## [[5]]\n## NULL\n## \n## [[6]]\n## NULL\n\n如果列表中的对象有名字，也可以像下面这样实现，还是和for循环基本一样：\n\ndataframes &lt;- list(df1,df2,df3,df4,df5,df6)  # 放到1个列表中\nnames(dataframes) &lt;- c(\"df1\",\"df2\",\"df3\",\"df4\",\"df5\",\"df6\") # 添加名字\nnames(dataframes) # 查看名字\n## [1] \"df1\" \"df2\" \"df3\" \"df4\" \"df5\" \"df6\"\n\nlapply(names(dataframes), function(x){\n    write.csv(dataframes[[x]],\n            file = paste0(\"datasets/csvs/\",x,\".csv\"),\n            quote = F,row.names = F)\n})\n## [[1]]\n## NULL\n## \n## [[2]]\n## NULL\n## \n## [[3]]\n## NULL\n## \n## [[4]]\n## NULL\n## \n## [[5]]\n## NULL\n## \n## [[6]]\n## NULL\n\n多个数据框的批量读取：\n\nallfiles &lt;- list.files(\"datasets/csvs\",full.names = T)\nallfiles\n## [1] \"datasets/csvs/df1.csv\" \"datasets/csvs/df2.csv\" \"datasets/csvs/df3.csv\"\n## [4] \"datasets/csvs/df4.csv\" \"datasets/csvs/df5.csv\" \"datasets/csvs/df6.csv\"\n\n# 1行代码解决，可以和前面的for循环对比下\ndfs &lt;- lapply(allfiles, read.csv)\n\ndfs[[1]]\n##   patientID age gender\n## 1        甲  23     男\n## 2        乙  43     女\n## 3        丙  45     女\n## 4        丁  34     男\n\n如果你没有使用全名，需要自己构建文件路径+文件名，借助paste0即可：\n\nallfiles &lt;- list.files(\"datasets/csvs\")\nallfiles\n## [1] \"df1.csv\" \"df2.csv\" \"df3.csv\" \"df4.csv\" \"df5.csv\" \"df6.csv\"\n\n# 自己写个函数即可\ndfs &lt;- lapply(allfiles,\n              function(x){read.csv(paste0(\"datasets/csvs/\",x))})\n\ndfs[[1]]\n##   patientID age gender\n## 1        甲  23     男\n## 2        乙  43     女\n## 3        丙  45     女\n## 4        丁  34     男\n\n此时的x就代指df1.csv、df2.csv这些名字。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>apply系列</span>"
    ]
  },
  {
    "objectID": "11-apply系列.html#sapply",
    "href": "11-apply系列.html#sapply",
    "title": "11  apply系列",
    "section": "11.3 sapply",
    "text": "11.3 sapply\nlapply的简化版本，输出结果不是list。如果simplify=FALSE和USE.NAMES=FALSE，那么sapply函数就等于lapply函数了。不如lapply使用广泛。\n选择方差大于1的列：\n\ntmp &lt;- sapply(coad_mrna_df, function(x){var(x)&gt;1})\n\n# coad_mrna_df[tmp,]\n\n计算每一列的中位数：\n\ntmp &lt;- sapply(coad_mrna_df, median)\nclass(tmp)\n## [1] \"numeric\"\nlength(tmp)\n## [1] 100\n\nhead(tmp)\n## TCGA-5M-AAT6-01A-11R-A41B-07 TCGA-AA-3552-01A-01R-0821-07 \n##                     7.632902                     7.631332 \n## TCGA-AA-3867-01A-01R-1022-07 TCGA-AD-6895-01A-11R-1928-07 \n##                     7.882883                     8.042666 \n## TCGA-AA-3560-01A-01R-0821-07 TCGA-CM-6676-01A-11R-1839-07 \n##                     7.730625                     7.873826",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>apply系列</span>"
    ]
  },
  {
    "objectID": "11-apply系列.html#tapply",
    "href": "11-apply系列.html#tapply",
    "title": "11  apply系列",
    "section": "11.4 tapply",
    "text": "11.4 tapply\n分组操作。根据某一个条件进行分组，然后对每一个组进行某种操作，最后进行汇总。这种数据处理思想是非常出名的：split-apply-combine。\n\nbrca_clin &lt;- read.csv(\"datasets/brca_clin.csv\",header = T)\ndim(brca_clin)\n## [1] 20  9\nbrca_clin[,4:5]\n##            sample_type initial_weight\n## 1  Solid Tissue Normal            260\n## 2  Solid Tissue Normal            220\n## 3  Solid Tissue Normal            130\n## 4  Solid Tissue Normal            260\n## 5  Solid Tissue Normal            200\n## 6  Solid Tissue Normal             60\n## 7  Solid Tissue Normal            320\n## 8  Solid Tissue Normal            310\n## 9  Solid Tissue Normal            100\n## 10 Solid Tissue Normal            250\n## 11       Primary Tumor            130\n## 12       Primary Tumor            110\n## 13       Primary Tumor            470\n## 14       Primary Tumor             90\n## 15       Primary Tumor            200\n## 16       Primary Tumor             70\n## 17       Primary Tumor            130\n## 18       Primary Tumor            770\n## 19       Primary Tumor            200\n## 20       Primary Tumor            250\n\n分别计算normal组和tumor组的weight的平均值：\n\n# 主要是3个参数\ntapply(X = brca_clin$initial_weight, \n       INDEX = brca_clin$sample_type, #组别是分类变量，不能数值型\n       FUN = mean)\n##       Primary Tumor Solid Tissue Normal \n##                 242                 211\n\n分别计算normal组和tumor组的age的中位数：\n\ntapply(brca_clin$age_at_index, \n       brca_clin$sample_type, \n       median)\n##       Primary Tumor Solid Tissue Normal \n##                55.0                59.5\n\n还有几个类似的函数，比如：aggregate和by。\n\n# 和tapply基本一样，但是第2个参数必须是list\n# 并支持根据多个变量进行分组\naggregate(brca_clin$age_at_index, \n          list(brca_clin$sample_type), \n          median)\n##               Group.1    x\n## 1       Primary Tumor 55.0\n## 2 Solid Tissue Normal 59.5\n\naggregate(brca_clin$age_at_index, \n          list(brca_clin$sample_type\n               ,brca_clin$ajcc_pathologic_stage), \n          median)\n##                Group.1    Group.2    x\n## 1        Primary Tumor    Stage I 56.0\n## 2  Solid Tissue Normal    Stage I 68.5\n## 3        Primary Tumor   Stage IA 49.0\n## 4  Solid Tissue Normal   Stage IA 63.0\n## 5        Primary Tumor  Stage IIA 67.5\n## 6  Solid Tissue Normal  Stage IIA 78.0\n## 7        Primary Tumor  Stage IIB 63.0\n## 8  Solid Tissue Normal  Stage IIB 54.0\n## 9        Primary Tumor Stage IIIA 47.0\n## 10 Solid Tissue Normal Stage IIIA 39.0\n## 11       Primary Tumor Stage IIIC 36.0\n\nby也是一样的用法：组别需要是因子型或者列表：\n\nby(brca_clin$age_at_index, \n   list(brca_clin$sample_type), \n   median)\n## : Primary Tumor\n## [1] 55\n## ------------------------------------------------------------ \n## : Solid Tissue Normal\n## [1] 59.5\n\nby(brca_clin$age_at_index, \n   list(brca_clin$sample_type\n        ,brca_clin$ajcc_pathologic_stage), \n   median)\n## : Primary Tumor\n## : Stage I\n## [1] 56\n## ------------------------------------------------------------ \n## : Solid Tissue Normal\n## : Stage I\n## [1] 68.5\n## ------------------------------------------------------------ \n## : Primary Tumor\n## : Stage IA\n## [1] 49\n## ------------------------------------------------------------ \n## : Solid Tissue Normal\n## : Stage IA\n## [1] 63\n## ------------------------------------------------------------ \n## : Primary Tumor\n## : Stage IIA\n## [1] 67.5\n## ------------------------------------------------------------ \n## : Solid Tissue Normal\n## : Stage IIA\n## [1] 78\n## ------------------------------------------------------------ \n## : Primary Tumor\n## : Stage IIB\n## [1] 63\n## ------------------------------------------------------------ \n## : Solid Tissue Normal\n## : Stage IIB\n## [1] 54\n## ------------------------------------------------------------ \n## : Primary Tumor\n## : Stage IIIA\n## [1] 47\n## ------------------------------------------------------------ \n## : Solid Tissue Normal\n## : Stage IIIA\n## [1] 39\n## ------------------------------------------------------------ \n## : Primary Tumor\n## : Stage IIIC\n## [1] 36\n## ------------------------------------------------------------ \n## : Solid Tissue Normal\n## : Stage IIIC\n## [1] NA\n\n组别是因子型也可以（实测字符型也可以），比如：\n\n# 可以看到sample_type是字符型\nstr(brca_clin)\n## 'data.frame':    20 obs. of  9 variables:\n##  $ barcode               : chr  \"TCGA-BH-A1FC-11A-32R-A13Q-07\" \"TCGA-AC-A2FM-11B-32R-A19W-07\" \"TCGA-BH-A0DO-11A-22R-A12D-07\" \"TCGA-E2-A1BC-11A-32R-A12P-07\" ...\n##  $ patient               : chr  \"TCGA-BH-A1FC\" \"TCGA-AC-A2FM\" \"TCGA-BH-A0DO\" \"TCGA-E2-A1BC\" ...\n##  $ sample                : chr  \"TCGA-BH-A1FC-11A\" \"TCGA-AC-A2FM-11B\" \"TCGA-BH-A0DO-11A\" \"TCGA-E2-A1BC-11A\" ...\n##  $ sample_type           : chr  \"Solid Tissue Normal\" \"Solid Tissue Normal\" \"Solid Tissue Normal\" \"Solid Tissue Normal\" ...\n##  $ initial_weight        : int  260 220 130 260 200 60 320 310 100 250 ...\n##  $ ajcc_pathologic_stage : chr  \"Stage IIA\" \"Stage IIB\" \"Stage I\" \"Stage IA\" ...\n##  $ days_to_last_follow_up: int  NA NA 1644 501 660 3247 NA NA 1876 707 ...\n##  $ gender                : chr  \"female\" \"female\" \"female\" \"female\" ...\n##  $ age_at_index          : int  78 87 78 63 41 59 60 39 54 51 ...\nclass(brca_clin$sample_type)\n## [1] \"character\"\n\nby(brca_clin$age_at_index, \n   brca_clin$sample_type, # 字符型也可以\n   median)\n## brca_clin$sample_type: Primary Tumor\n## [1] 55\n## ------------------------------------------------------------ \n## brca_clin$sample_type: Solid Tissue Normal\n## [1] 59.5\n\n先把sample_type变成因子型也可以：\n\nbrca_clin$sample_type &lt;- factor(brca_clin$sample_type)\nclass(brca_clin$sample_type) # 变成因子型了\n## [1] \"factor\"\n\n# 也OK\nby(brca_clin$age_at_index, \n   brca_clin$sample_type, # 字符型也可以\n   median)\n## brca_clin$sample_type: Primary Tumor\n## [1] 55\n## ------------------------------------------------------------ \n## brca_clin$sample_type: Solid Tissue Normal\n## [1] 59.5",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>apply系列</span>"
    ]
  },
  {
    "objectID": "11-apply系列.html#其他apply函数",
    "href": "11-apply系列.html#其他apply函数",
    "title": "11  apply系列",
    "section": "11.5 其他apply函数",
    "text": "11.5 其他apply函数\n还有vapply、mapply、rapply、eapply，用的很少，不再介绍。\nvapply类似于sapply，提供了FUN.VALUE参数，用来控制返回值的行名，这样可以让程序更清晰易懂。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>apply系列</span>"
    ]
  },
  {
    "objectID": "11-apply系列.html#reduce和do.call",
    "href": "11-apply系列.html#reduce和do.call",
    "title": "11  apply系列",
    "section": "11.6 Reduce和do.call",
    "text": "11.6 Reduce和do.call\n\n11.6.1 Reduce\n对多个对象进行累积操作。\n比如，累加：\n\nReduce(\"+\", 1:100)\n## [1] 5050\n\n再比如，多个数据框的merge，merge函数只能对两个数据框进行合并，但是如果有多个数据框需要合并怎么办？有100个怎么办？\n批量读取多个数据框：\n\n# 6个数据框\nallfiles &lt;- list.files(\"datasets/csvs\",full.names = T)\nallfiles\n## [1] \"datasets/csvs/df1.csv\" \"datasets/csvs/df2.csv\" \"datasets/csvs/df3.csv\"\n## [4] \"datasets/csvs/df4.csv\" \"datasets/csvs/df5.csv\" \"datasets/csvs/df6.csv\"\n\n# 1行代码解决\ndfs &lt;- lapply(allfiles, read.csv)\n\n# 查看其中1个\ndfs[[2]]\n##   patientID  hb wbc\n## 1        甲 110 3.7\n## 2        乙 124 4.6\n## 3        戊 138 6.4\n## 4        几 142 4.2\n## 5        庚 108 5.6\n## 6        丁 120 5.2\n\n6个数据框的merge：\n\nReduce(merge, dfs)\n##   patientID age gender  hb wbc rbc plt        a       b        d        e\n## 1        乙  43     女 124 4.6 4.3 250 19.87349 10.6802 2.021362 1.265671\n##          f        g\n## 1 1.692041 0.102916\n\n如果想要使用merge里面的参数怎么办？自己写函数即可：\n\n# 这个函数只能有两个参数\nReduce(function(x,y){merge(x,y, by = \"patientID\")},\n       dfs)\n##   patientID age gender  hb wbc rbc plt        a       b        d        e\n## 1        乙  43     女 124 4.6 4.3 250 19.87349 10.6802 2.021362 1.265671\n##          f        g\n## 1 1.692041 0.102916\n\n\n\n11.6.2 do.call\n使用场景：你有很多个数据框，而且每个数据框的内容都一样，你想把这些数据框拼接到一起。\n\ndf1 &lt;- data.frame(\n  patientID = 1:4,\n  aa = rnorm(4,10),\n  bb = rnorm(4,16)\n)\ndf2 &lt;- data.frame(\n  patientID = 5:8,\n  aa = rnorm(4,10),\n  bb = rnorm(4,16)\n)\ndf3 &lt;- data.frame(\n  patientID = 9:12,\n  aa = rnorm(4,10),\n  bb = rnorm(4,16)\n)\ndf4 &lt;- data.frame(\n  patientID = 13:16,\n  aa = rnorm(4,10),\n  bb = rnorm(4,16)\n)\n\n如果是单独的几个数据框的拼接，可以直接使用rbind()：\n\nrbind(df1,df2,df3,df4)\n##    patientID        aa       bb\n## 1          1  9.419064 15.40452\n## 2          2  9.777584 13.90634\n## 3          3 11.355702 15.47427\n## 4          4 10.436605 17.19299\n## 5          5 10.948403 13.30538\n## 6          6  9.530653 16.22847\n## 7          7  8.257859 15.12947\n## 8          8  9.723001 16.27681\n## 9          9  9.575754 18.03990\n## 10        10 10.225661 16.78379\n## 11        11 10.043380 17.83934\n## 12        12 11.085845 15.25737\n## 13        13 11.213415 15.50688\n## 14        14 10.008885 16.33870\n## 15        15  9.820569 13.93490\n## 16        16  8.486443 16.32318\n\n但是通常我们在进行数据分析时，经常会使用循环或者向量化运行，这样得到的结果是列表，数据框可能是列表中的元素，此时直接使用rbind()是不行的：\n\n# 数据框在列表中\nll &lt;- list(df1,df2,df3,df4)\n\n# 再用rbind是不能有同样效果的\n#rbind(ll)\n#lapply(ll, rbind)\n\n不断地重复写rbind？没有必要。\n\nll &lt;- list(df1,df2,df3,df4)\n\ndo.call(rbind, ll)\n##    patientID        aa       bb\n## 1          1  9.419064 15.40452\n## 2          2  9.777584 13.90634\n## 3          3 11.355702 15.47427\n## 4          4 10.436605 17.19299\n## 5          5 10.948403 13.30538\n## 6          6  9.530653 16.22847\n## 7          7  8.257859 15.12947\n## 8          8  9.723001 16.27681\n## 9          9  9.575754 18.03990\n## 10        10 10.225661 16.78379\n## 11        11 10.043380 17.83934\n## 12        12 11.085845 15.25737\n## 13        13 11.213415 15.50688\n## 14        14 10.008885 16.33870\n## 15        15  9.820569 13.93490\n## 16        16  8.486443 16.32318\n\n其实这种场景下使用Reduce也可以，但是数据量比较大的话还是do.call更快。\n\nReduce(rbind, ll)\n##    patientID        aa       bb\n## 1          1  9.419064 15.40452\n## 2          2  9.777584 13.90634\n## 3          3 11.355702 15.47427\n## 4          4 10.436605 17.19299\n## 5          5 10.948403 13.30538\n## 6          6  9.530653 16.22847\n## 7          7  8.257859 15.12947\n## 8          8  9.723001 16.27681\n## 9          9  9.575754 18.03990\n## 10        10 10.225661 16.78379\n## 11        11 10.043380 17.83934\n## 12        12 11.085845 15.25737\n## 13        13 11.213415 15.50688\n## 14        14 10.008885 16.33870\n## 15        15  9.820569 13.93490\n## 16        16  8.486443 16.32318",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>apply系列</span>"
    ]
  },
  {
    "objectID": "12-实用技巧.html",
    "href": "12-实用技巧.html",
    "title": "12  实用技巧",
    "section": "",
    "text": "12.1 Rmarkdown和quarto\n如果你不了解markdown，请跳过这部分内容，先去学习markdown。\nR script 如果要写注释（即一些解释说明的文字）的话，需要在前面加#，但是Rmarkdown不需要。你可以直接在当前界面写各种文字、符号等。\n插入代码块：ctrl+alt+i\nprint(\"rmarkdown演示\")\n## [1] \"rmarkdown演示\"\n括号中可以写各种控制选项。\nquarto和Rmarkdown没有本质区别（只是后缀名不一样而已），各种语法都可以互认，只是posit（rstudio母公司）现在更喜欢quarto而已。",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>实用技巧</span>"
    ]
  },
  {
    "objectID": "12-实用技巧.html#用rproject管理代码",
    "href": "12-实用技巧.html#用rproject管理代码",
    "title": "12  实用技巧",
    "section": "12.2 用Rproject管理代码",
    "text": "12.2 用Rproject管理代码\n.Rproj在哪里，你的当前工作路径就在哪里，只需要双击.Rproj文件打开rstudio即可。\n如何创建.Rproj，点击左上角的那个图标即可：",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>实用技巧</span>"
    ]
  },
  {
    "objectID": "12-实用技巧.html#bioconductor镜像管理",
    "href": "12-实用技巧.html#bioconductor镜像管理",
    "title": "12  实用技巧",
    "section": "12.3 bioconductor镜像管理",
    "text": "12.3 bioconductor镜像管理\n通过修改.Rprofile文件可以实现超多的自定义内容。比如，设置每次打开rstudio时打印“你好，阿越！欢迎你”\n运行以下代码打开.Rprofile文件，并把以下代码粘贴进去，保存，关闭文件即可。\n\nusethis::edit_r_profile()\n\n\nprint(\"你好，阿越！欢迎你\")\n## [1] \"你好，阿越！欢迎你\"\n\n通过这种方法也可以实现永久修改bioconductor镜像，这样就不用每次都运行修改镜像的代码了：\n# 西湖大学的镜像\noptions(BioC_mirror=\"https://mirrors.westlake.edu.cn/bioconductor\")\n或者也可以把你每次都想加载的R包加进去，这样每次在打开rstudio时都会自动帮你加载，不用手动加载。",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>实用技巧</span>"
    ]
  },
  {
    "objectID": "12-实用技巧.html#r包安装和管理",
    "href": "12-实用技巧.html#r包安装和管理",
    "title": "12  实用技巧",
    "section": "12.4 R包安装和管理",
    "text": "12.4 R包安装和管理\n在rstudio中可以通过点点点安装CRAN的R包，可以在packages面板查看安装的R包和版本等\nBiocManager::install()可以安装CRAN、bioconductor、github的R包。\nxxx.db包的安装。",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>实用技巧</span>"
    ]
  },
  {
    "objectID": "12-实用技巧.html#修改默认r包安装路径",
    "href": "12-实用技巧.html#修改默认r包安装路径",
    "title": "12  实用技巧",
    "section": "12.5 修改默认R包安装路径",
    "text": "12.5 修改默认R包安装路径\n如何查看你的R包的默认安装路径：\n\n方法1：在packages面板查看R包默认安装路径\n方法2：使用.libPaths()\n\n\n.libPaths()\n## [1] \"C:/Users/liyue/AppData/Local/R/win-library/4.4\"\n## [2] \"C:/Program Files/R/R-4.4.1/library\"\n\n第1个是你自己安装R包时的默认路径。\n如何更改？直接在.libPaths()中添加即可，记得把你想要的路径放在第一位：\n\n.libPaths(c(\"F:/r_pkg_test\", .libPaths()))\n.libPaths()\n\n但这种方法在你重启rstudio后会失效，可以重启下看看。\n永久修改的方法是把上面的代码加在.Rprofile文件中。运行以下代码打开.Rprofile文件，把上面的代码粘贴进去，保存，关闭即可。你再重启rstudio发现路径没变。\n\nusethis::edit_r_profile()\n\n还可以修改Rprofile.site，较复杂，不演示。\n此时可以安装下R包试试看：\n\nBiocManager::install(\"ggraph\")\n\n看看安装路径，是不是多了这个包。\n加载试试：\n\nlibrary(ggraph)",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>实用技巧</span>"
    ]
  },
  {
    "objectID": "12-实用技巧.html#r自带数据集",
    "href": "12-实用技巧.html#r自带数据集",
    "title": "12  实用技巧",
    "section": "12.6 R自带数据集",
    "text": "12.6 R自带数据集\n自带数据集都在datasets包中，这个是R自带的，不需要自己安装：\n\n# 著名的mtcars数据\ndatasets::mtcars\n##                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n## Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n## Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n## Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n## Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n## Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n## Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n## Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n## Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n## Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n## Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n## Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n## Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n## Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n## Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n## Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n## Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n## Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n## Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n## Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n## Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n## AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n## Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n## Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n## Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n## Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n## Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n## Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n## Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n## Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n## Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n# 或者\ndata(\"mtcars\")\n\n有很多R包都是自带数据集的，不用额外下载，只要安装了这个R包就能用。比如survival包里面，就有很多可用于做生存分析的数据：\n\nlibrary(survival) # 加载这个R包就能用里面的数据了\nstr(lung)\n## 'data.frame':    228 obs. of  10 variables:\n##  $ inst     : num  3 3 3 5 1 12 7 11 1 7 ...\n##  $ time     : num  306 455 1010 210 883 ...\n##  $ status   : num  2 2 1 2 2 1 2 2 2 2 ...\n##  $ age      : num  74 68 56 57 60 74 68 71 53 61 ...\n##  $ sex      : num  1 1 1 1 1 1 2 2 1 1 ...\n##  $ ph.ecog  : num  1 0 0 1 0 1 2 2 1 2 ...\n##  $ ph.karno : num  90 90 90 90 100 50 70 60 70 70 ...\n##  $ pat.karno: num  100 90 90 60 90 80 60 80 80 70 ...\n##  $ meal.cal : num  1175 1225 NA 1150 NA ...\n##  $ wt.loss  : num  NA 15 15 11 0 0 10 1 16 34 ...\nstr(colon)\n## 'data.frame':    1858 obs. of  16 variables:\n##  $ id      : num  1 1 2 2 3 3 4 4 5 5 ...\n##  $ study   : num  1 1 1 1 1 1 1 1 1 1 ...\n##  $ rx      : Factor w/ 3 levels \"Obs\",\"Lev\",\"Lev+5FU\": 3 3 3 3 1 1 3 3 1 1 ...\n##  $ sex     : num  1 1 1 1 0 0 0 0 1 1 ...\n##  $ age     : num  43 43 63 63 71 71 66 66 69 69 ...\n##  $ obstruct: num  0 0 0 0 0 0 1 1 0 0 ...\n##  $ perfor  : num  0 0 0 0 0 0 0 0 0 0 ...\n##  $ adhere  : num  0 0 0 0 1 1 0 0 0 0 ...\n##  $ nodes   : num  5 5 1 1 7 7 6 6 22 22 ...\n##  $ status  : num  1 1 0 0 1 1 1 1 1 1 ...\n##  $ differ  : num  2 2 2 2 2 2 2 2 2 2 ...\n##  $ extent  : num  3 3 3 3 2 2 3 3 3 3 ...\n##  $ surg    : num  0 0 0 0 0 0 1 1 1 1 ...\n##  $ node4   : num  1 1 0 0 1 1 1 1 1 1 ...\n##  $ time    : num  1521 968 3087 3087 963 ...\n##  $ etype   : num  2 1 2 1 2 1 2 1 2 1 ...",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>实用技巧</span>"
    ]
  },
  {
    "objectID": "13-TCGA_mrna表达矩阵整理.html",
    "href": "13-TCGA_mrna表达矩阵整理.html",
    "title": "13  TCGA数据下载和整理",
    "section": "",
    "text": "13.1 从官网下载TCGA数据\n请跟着视频操作。\nTCGA官网：https://portal.gdc.cancer.gov/",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>TCGA数据下载和整理</span>"
    ]
  },
  {
    "objectID": "13-TCGA_mrna表达矩阵整理.html#表达矩阵整理",
    "href": "13-TCGA_mrna表达矩阵整理.html#表达矩阵整理",
    "title": "13  TCGA数据下载和整理",
    "section": "13.2 表达矩阵整理",
    "text": "13.2 表达矩阵整理\n查看所有文件（注意，和视频中的路径不一样，千万要注意你自己的路径！！）：\n\nallfiles &lt;- list.files(\"tcga_meso\", pattern = \".tsv\",\n                       full.names = T,recursive = T) # 查看到最里面一层文件夹\nhead(allfiles)\n## [1] \"tcga_meso/gdc_download_20240915_113923.366242/01d53607-1a69-4ce8-9058-705db14adc4e/853dbd81-9079-4d4f-aa38-05b04b159667.rna_seq.augmented_star_gene_counts.tsv\"\n## [2] \"tcga_meso/gdc_download_20240915_113923.366242/03902ef2-8a01-4d14-ae8b-efd0734e712e/7a1d80d7-d1ee-4fc0-8299-cbf119263b52.rna_seq.augmented_star_gene_counts.tsv\"\n## [3] \"tcga_meso/gdc_download_20240915_113923.366242/0a3a4b5f-6bdd-4839-a4ea-eb3baeeb031f/835763c1-a525-401c-bb56-90db5918a621.rna_seq.augmented_star_gene_counts.tsv\"\n## [4] \"tcga_meso/gdc_download_20240915_113923.366242/0ea8ca4e-505b-469c-806a-eee66288e9fd/f8fae9b4-d6ff-4dc9-9018-15d91a8ed36e.rna_seq.augmented_star_gene_counts.tsv\"\n## [5] \"tcga_meso/gdc_download_20240915_113923.366242/113ff3c8-dddc-4794-acfe-1d024f1be05e/11864629-bce9-4e38-9bd1-432df0a54e5b.rna_seq.augmented_star_gene_counts.tsv\"\n## [6] \"tcga_meso/gdc_download_20240915_113923.366242/138a7897-ddf8-41e4-9555-ce07d62f316d/c46e9df6-eba7-49c3-a339-2dc82e208a04.rna_seq.augmented_star_gene_counts.tsv\"\nlength(allfiles)\n## [1] 87\n\n用文本编辑器打开其中1个看看情况。如果你用Linux就很简单，windows推荐使用VScode，免费下载，大厂软件，质量有保障。\n现在版本的TCGA官网下载的文件，一个文件是1个样本的结果，里面包括60660个mrna(既有编码RNA也有非编码RNA)，同时给出了count/tpm/fpkm3种格式。\n先读取其中1个试试看：\n\ntmp &lt;- read.table(allfiles[1],sep = \"\\t\",header = F,skip = 6)\ndim(tmp)\n## [1] 60660     9\nhead(tmp)\n##                   V1       V2             V3   V4  V5  V6      V7      V8\n## 1 ENSG00000000003.15   TSPAN6 protein_coding  506 247 259  5.6293  1.8997\n## 2  ENSG00000000005.6     TNMD protein_coding    0   0   0  0.0000  0.0000\n## 3 ENSG00000000419.13     DPM1 protein_coding 1763 874 890 73.7093 24.8747\n## 4 ENSG00000000457.14    SCYL3 protein_coding  490 432 422  3.5925  1.2124\n## 5 ENSG00000000460.17 C1orf112 protein_coding  170 280 284  1.4370  0.4849\n## 6 ENSG00000000938.13      FGR protein_coding  876 441 435 13.0710  4.4111\n##        V9\n## 1  2.2155\n## 2  0.0000\n## 3 29.0094\n## 4  1.4139\n## 5  0.5655\n## 6  5.1443\n\n第4列是count值：\n\n# counts\ntmp[1:4,c(1,2,4)]\n##                   V1     V2   V4\n## 1 ENSG00000000003.15 TSPAN6  506\n## 2  ENSG00000000005.6   TNMD    0\n## 3 ENSG00000000419.13   DPM1 1763\n## 4 ENSG00000000457.14  SCYL3  490\n\n前两列是ensembl_id和HGNC_gene_symbol（参考：生信初学者最佳实践）：\n\ngene_ids &lt;- tmp[,1:2]\ncolnames(gene_ids) &lt;- c(\"ensembl_id\",\"gene_name\")\nhead(gene_ids)\n##           ensembl_id gene_name\n## 1 ENSG00000000003.15    TSPAN6\n## 2  ENSG00000000005.6      TNMD\n## 3 ENSG00000000419.13      DPM1\n## 4 ENSG00000000457.14     SCYL3\n## 5 ENSG00000000460.17  C1orf112\n## 6 ENSG00000000938.13       FGR\n\n批量读取，并按列拼接在一起（所有样本的基因顺序都是一样的，每个文件的结构都是一样的，所以才可以直接拼接）：\n\nmeso_expr &lt;- do.call(cbind, lapply(allfiles, function(x){\n  tmp &lt;- read.table(x,sep = \"\\t\",header = F,skip = 6)\n  tmp &lt;- tmp[,4] # 选count，你想要tpm就选tpm那一列\n}))\n\ndim(meso_expr)\n## [1] 60660    87\nmeso_expr[1:4,1:4]\n##      [,1] [,2] [,3] [,4]\n## [1,]  506  332 1055  821\n## [2,]    0    0    1    2\n## [3,] 1763 1034 1999 1337\n## [4,]  490  520  856  344",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>TCGA数据下载和整理</span>"
    ]
  },
  {
    "objectID": "13-TCGA_mrna表达矩阵整理.html#添加行名和列名",
    "href": "13-TCGA_mrna表达矩阵整理.html#添加行名和列名",
    "title": "13  TCGA数据下载和整理",
    "section": "13.3 添加行名和列名",
    "text": "13.3 添加行名和列名\n添加行名，就是基因名，我选择HGNC_gene_symbol：\n\nrownames(meso_expr) &lt;- tmp[,2]\n\n列名比较复杂，我这里就先用文件名作为列名。\n查看下文件和表达矩阵列的对应关系对不对：\n\nallfiles[2]\n## [1] \"tcga_meso/gdc_download_20240915_113923.366242/03902ef2-8a01-4d14-ae8b-efd0734e712e/7a1d80d7-d1ee-4fc0-8299-cbf119263b52.rna_seq.augmented_star_gene_counts.tsv\"\n\n我们不需要前面的路径，只需要xxx.tsv这个名字即可，所以分割字符串：\n\nrow_names &lt;- strsplit(allfiles, \"/\")\nrow_names &lt;- sapply(row_names,function(x){x[4]})\n\nlength(row_names)\n## [1] 87\nhead(row_names)\n## [1] \"853dbd81-9079-4d4f-aa38-05b04b159667.rna_seq.augmented_star_gene_counts.tsv\"\n## [2] \"7a1d80d7-d1ee-4fc0-8299-cbf119263b52.rna_seq.augmented_star_gene_counts.tsv\"\n## [3] \"835763c1-a525-401c-bb56-90db5918a621.rna_seq.augmented_star_gene_counts.tsv\"\n## [4] \"f8fae9b4-d6ff-4dc9-9018-15d91a8ed36e.rna_seq.augmented_star_gene_counts.tsv\"\n## [5] \"11864629-bce9-4e38-9bd1-432df0a54e5b.rna_seq.augmented_star_gene_counts.tsv\"\n## [6] \"c46e9df6-eba7-49c3-a339-2dc82e208a04.rna_seq.augmented_star_gene_counts.tsv\"\n\n添加行名即可：\n\ncolnames(meso_expr) &lt;- row_names\nmeso_expr[1:2,1:2]\n##        853dbd81-9079-4d4f-aa38-05b04b159667.rna_seq.augmented_star_gene_counts.tsv\n## TSPAN6                                                                         506\n## TNMD                                                                             0\n##        7a1d80d7-d1ee-4fc0-8299-cbf119263b52.rna_seq.augmented_star_gene_counts.tsv\n## TSPAN6                                                                         332\n## TNMD                                                                             0\n\n变成数据框结构，并对列排个顺序：\n\nmeso_expr &lt;- as.data.frame(meso_expr)\nmeso_expr &lt;- meso_expr[,order(colnames(meso_expr))]\nhead(colnames(meso_expr))\n## [1] \"02204e67-61ec-4407-a8f4-daab9082498e.rna_seq.augmented_star_gene_counts.tsv\"\n## [2] \"068fb718-0419-4ae0-a4e4-df86e352a0ff.rna_seq.augmented_star_gene_counts.tsv\"\n## [3] \"06923905-91b3-45c0-8c05-67ee1ca1fa65.rna_seq.augmented_star_gene_counts.tsv\"\n## [4] \"0a4a1bec-4376-490b-9abb-cfeb9dd6c74b.rna_seq.augmented_star_gene_counts.tsv\"\n## [5] \"0c7e4640-0092-4931-b84f-fd1bef907348.rna_seq.augmented_star_gene_counts.tsv\"\n## [6] \"0cf30abd-2531-4c1e-998e-3c6b7a89e5b8.rna_seq.augmented_star_gene_counts.tsv\"",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>TCGA数据下载和整理</span>"
    ]
  },
  {
    "objectID": "13-TCGA_mrna表达矩阵整理.html#获取样本名和文件名的对应关系",
    "href": "13-TCGA_mrna表达矩阵整理.html#获取样本名和文件名的对应关系",
    "title": "13  TCGA数据下载和整理",
    "section": "13.4 获取样本名和文件名的对应关系",
    "text": "13.4 获取样本名和文件名的对应关系\n正经的TCGA表达矩阵的列名很明显不是这样的，而是TCGA-XX-XX-XX这种，所以我们需要给它改一下。\n这个名字在哪里呢？就在我们下载的JSON文件里。\n如何读取这种文件呢？搜索一下即可。\n\nlibrary(rjson)\n\n# 读取下试试看\naa &lt;- fromJSON(file = \"tcga_meso/metadata.cart.2024-09-03.json\")\n\n找到文件名和样本名的对应关系：\n\naa[[1]]$file_name\n## [1] \"aed00751-a16b-4452-a69b-af47d910b5b5.rna_seq.augmented_star_gene_counts.tsv\"\naa[[1]]$associated_entities[[1]]$entity_submitter_id\n## [1] \"TCGA-XT-AASU-01A-11R-A40A-07\"\n\n批量提取：\n\nmeta_data &lt;- lapply(aa, function(x){\n  data.frame(file_name = x$file_name,\n             sample_id = x$associated_entities[[1]]$entity_submitter_id)\n})\n\nmeta_data[[1]]\n##                                                                     file_name\n## 1 aed00751-a16b-4452-a69b-af47d910b5b5.rna_seq.augmented_star_gene_counts.tsv\n##                      sample_id\n## 1 TCGA-XT-AASU-01A-11R-A40A-07\n\nmeta_data &lt;- do.call(rbind, meta_data)\nmeta_data[1:2,]\n##                                                                     file_name\n## 1 aed00751-a16b-4452-a69b-af47d910b5b5.rna_seq.augmented_star_gene_counts.tsv\n## 2 f1183765-f532-499a-aed8-fdd39156a67b.rna_seq.augmented_star_gene_counts.tsv\n##                      sample_id\n## 1 TCGA-XT-AASU-01A-11R-A40A-07\n## 2 TCGA-TS-A7P1-01A-41R-A40A-07\n\n也按照文件名排个序：\n\nmeta_data &lt;- meta_data[order(meta_data$file_name),]\nhead(meta_data$file_name)\n## [1] \"02204e67-61ec-4407-a8f4-daab9082498e.rna_seq.augmented_star_gene_counts.tsv\"\n## [2] \"068fb718-0419-4ae0-a4e4-df86e352a0ff.rna_seq.augmented_star_gene_counts.tsv\"\n## [3] \"06923905-91b3-45c0-8c05-67ee1ca1fa65.rna_seq.augmented_star_gene_counts.tsv\"\n## [4] \"0a4a1bec-4376-490b-9abb-cfeb9dd6c74b.rna_seq.augmented_star_gene_counts.tsv\"\n## [5] \"0c7e4640-0092-4931-b84f-fd1bef907348.rna_seq.augmented_star_gene_counts.tsv\"\n## [6] \"0cf30abd-2531-4c1e-998e-3c6b7a89e5b8.rna_seq.augmented_star_gene_counts.tsv\"\n\n查看这个顺序和表达矩阵的列的顺序是否完全一样：\n\nidentical(meta_data$file_name, colnames(meso_expr))\n## [1] TRUE\n\n直接替换列名即可：\n\ncolnames(meso_expr) &lt;- meta_data$sample_id\nmeso_expr[1:4,1:4]\n##        TCGA-ZN-A9VO-01A-11R-A40A-07 TCGA-LK-A4O7-01A-11R-A34F-07\n## TSPAN6                         1068                         1165\n## TNMD                              1                            0\n## DPM1                           2599                         1883\n## SCYL3                           660                          531\n##        TCGA-MQ-A6BL-01A-11R-A34F-07 TCGA-TS-A8AI-01A-11R-A40A-07\n## TSPAN6                         1307                         1242\n## TNMD                              0                            1\n## DPM1                           1924                         2263\n## SCYL3                           336                          520",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>TCGA数据下载和整理</span>"
    ]
  },
  {
    "objectID": "13-TCGA_mrna表达矩阵整理.html#easytcga",
    "href": "13-TCGA_mrna表达矩阵整理.html#easytcga",
    "title": "13  TCGA数据下载和整理",
    "section": "13.5 easyTCGA",
    "text": "13.5 easyTCGA\n后续问题？\n临床信息？ 临床信息和表达矩阵匹配？\n直接用easyTCGA。\n\nlibrary(easyTCGA)\n\n1行代码搞定一切（详细用法请看视频教程）：\n# 对网络有要求\ngetmrnaexpr(\"TCGA-MESO\")\n\n=&gt; Querying data. \n\nRegistered S3 methods overwritten by 'dbplyr':\n  method         from\n  print.tbl_lazy     \n  print.tbl_sql      \n--------------------------------------\no GDCquery: Searching in GDC database\n--------------------------------------\nGenome of reference: hg38\n--------------------------------------------\noo Accessing GDC. This might take a while...\n--------------------------------------------\nooo Project: TCGA-MESO\n--------------------\noo Filtering results\n--------------------\nooo By data.type\nooo By workflow.type\n----------------\noo Checking data\n----------------\nooo Checking if there are duplicated cases\nooo Checking if there are results for the query\n-------------------\no Preparing output\n-------------------\n\n=&gt; Downloading data. \n\nDownloading data for project TCGA-MESO\nGDCdownload will download 87 files. A total of 368.350266 MB\nDownloading chunk 1 of 1 (87 files, size = 368.350266 MB) as Thu_Sep_12_13_36_31_2024_0.tar.gz\nDownloading: 89 MB      \n=&gt; Preparing SummarizedExperiment.\n\n|=================================|100%                      Completed after 8 s \nStarting to add information to samples\n =&gt; Add clinical information to samples\n =&gt; Adding TCGA molecular information from marker papers\n =&gt; Information will have prefix 'paper_' \nAvailable assays in SummarizedExperiment : \n  =&gt; unstranded\n  =&gt; stranded_first\n  =&gt; stranded_second\n  =&gt; tpm_unstrand\n  =&gt; fpkm_unstrand\n  =&gt; fpkm_uq_unstrand\n=&gt; Saving file: output_mRNA_lncRNA_expr/TCGA-MESO_SummarizedExperiment.rdata\n=&gt; File saved\n\n=&gt; Preparing mRNA and lncRNA.\n\n=&gt; Successful.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>TCGA数据下载和整理</span>"
    ]
  },
  {
    "objectID": "14-R绘图入门.html",
    "href": "14-R绘图入门.html",
    "title": "14  R绘图入门",
    "section": "",
    "text": "14.1 base plot\n主要是通过graphics包实现的，这个包是R语言自带的，不需要加载也能直接用。\n基础绘图系统超级无敌繁琐，可以实现对图形细节的超级无敌控制！但是相比于ggplot2来说，使用语法更复杂。\n下面给大家展示部分图形示例。",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>R绘图入门</span>"
    ]
  },
  {
    "objectID": "14-R绘图入门.html#base-plot",
    "href": "14-R绘图入门.html#base-plot",
    "title": "14  R绘图入门",
    "section": "",
    "text": "14.1.1 散点图\nplot(1:10,1:10,\n     type = \"p\",\n     main = \"这是一幅图\",\n     sub = \"这是副标题\",\n     xlab = \"这是横坐标\",\n     ylab = \"这是纵坐标\")\n\nplot(c(2,4,5,6,3),c(1,3,5,3,6))\n\n\n\n\n\n\n\n\n\n\n\n\n14.1.2 折线图\n\nplot(1:10,1:10,\n     type = \"l\",\n     main = \"这是一幅图\",\n     sub = \"这是副标题\",\n     xlab = \"这是横坐标\",\n     ylab = \"这是纵坐标\")\n\n\n\n\n\n\n\n\n\n\n14.1.3 点线图\n\nplot(1:10,1:10,\n     type = \"b\",\n     main = \"这是一幅图\",\n     sub = \"这是副标题\",\n     xlab = \"这是横坐标\",\n     ylab = \"这是纵坐标\")\n\n\n\n\n\n\n\n\n更多用法可参考帮助文档：\n\n?plot\n\n\n\n14.1.4 条形图\ntmp &lt;- data.frame(`人数` = c(23,18,36,27,19),\n                  `类型` = c(\"糖尿病\",\"脑梗死\",\"心肌梗死\",\"支气管炎\",\"肺炎\"))\n\nbarplot(`人数` ~ `类型`, data = tmp)\nbarplot(`人数` ~ `类型`, data = tmp, horiz = T)\n\n\n\n\n\n\n\n\n\n\n\n\n14.1.5 箱线图\nboxplot(Sepal.Length ~ Species, data = iris)\nboxplot(Sepal.Length ~ Species, data = iris, notch = T)\nboxplot(Sepal.Length ~ Species, data = iris, horizontal = T)\nboxplot(Sepal.Length ~ Species, data = iris, col = \"red\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n14.1.6 直方图\nhist(iris$Sepal.Length)\nhist(iris$Sepal.Length, freq = F)\n\n\n\n\n\n\n\n\n\n\n\n\n14.1.7 密度图\n\nplot(density(iris$Sepal.Length))\n\n\n\n\n\n\n\n\n\n\n14.1.8 直方图+密度图\n\nhist(iris$Sepal.Length, freq = F)\nlines(density(iris$Sepal.Length))\n\n\n\n\n\n\n\n\n基础绘图自由度极高，你可以往图形中添加各种元素，可以添加在图形中的任何位置。这种绘图方式非常的“计算机”：\n\n在A位置画一个点\n在B位置画一条线\n在C位置画一个图例\n在D位置添加一段文字\n……\n\n\n\n14.1.9 美图展示\n基础绘图都这么丑吗？当然不是！这还得看个人的审美水平和代码水平。\n下面给大家展示几个大佬用base-plot绘制的图形。以下图形全部都是由base-plot直接绘制的，未经任何PS等软件修改，来自Github\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n给大家展示一下金字塔图的绘制方法。\n\ndata = read.table(\"datasets/02-splitbarplot_PopGermany.csv\", sep = \",\", header = TRUE)\nmax_count = max(data[,c(\"male\", \"female\")]) #Maximum value\n\n# 设置画布\npar(mar = c(2, 3, 2, 1))\nplot( # 确定主体\n  NA,\n  xlim = c(-max_count, max_count),\n  ylim = c(1, nrow(data)),\n  frame.plot = FALSE,\n  axes = FALSE,\n  xlab = NA,\n  ylab = NA\n)\n\naxis( # 添加y轴\n  side = 2,\n  at = 1:nrow(data)+0.4,\n  labels = rev(data$age.span),\n  tick = FALSE,\n  cex.axis = 0.8, las = 2, line = -1, col = \"#34495e\"\n)\n\n# 写循环，一行一行的画\nfor(i in 1:nrow(data)){\n  row_idx = rev(1:nrow(data))[i] #Plot the data from bottom to top\n  # 画左侧灰色背景\n  rect(xleft = -max_count, ybottom = i, xright = -10, ytop = i+0.9, col = \"#ecf0f1\", border = NA)\n  # 画左侧蓝色条形\n  rect(\n    xleft = -data[row_idx, \"male\"],\n    xright = -10,\n    ybottom = i,\n    ytop = i + 0.9, col = \"#2980b9\", border = NA,\n  )\n  pretty_pop_male = ifelse(test = data[row_idx, 2] &lt; 1e6,\n                             yes = paste0(round(data[row_idx, 2] / 1000, 1), \"k\"),\n                             no = paste0(round(data[row_idx, 2] / 1e6, 1), \"m\"))\n  # 加左侧数字\n  if(data[row_idx, 2] &lt; 1e6){\n    text(\n      x = -data[row_idx, \"male\"],\n      y = i + 0.4,\n      labels = pretty_pop_male,\n      pos = 2,\n      xpd = TRUE, cex = 0.7, col = \"black\"\n    )\n  }else{\n    text(\n      x = -500,\n      y = i + 0.4,\n      labels = pretty_pop_male,\n      pos = 2,\n      xpd = TRUE, cex = 0.7, col = \"white\"\n    )\n  }\n  \n  \n  # 画右侧\n  rect(xleft = -10, ybottom = i, xright = max_count, ytop = i+0.9, col = \"#ecf0f1\", border = NA)\n  rect(\n    xleft = data[row_idx, \"female\"],\n    xright = 10,\n    ybottom = i,\n    ytop = i + 0.9, col = \"#c0392b\", border = NA\n  )\n  pretty_pop_female = ifelse(test = data[row_idx, 3] &lt; 1054000, # 1e6我改成1054000\n                           yes = paste0(round(data[row_idx, 3] / 1000, 1), \"k\"),\n                           no = paste0(round(data[row_idx, 3] / 1e6, 1), \"m\"))\n  \n  if(data[row_idx, 3] &lt; 1054000){ # 这里本来是取的第2列，我改成第3列,1e6改成1054000\n    text(\n      x = data[row_idx, \"female\"],\n      y = i + 0.4,\n      labels = pretty_pop_female, # 这里本来是male\n      pos = 4,\n      xpd = TRUE, cex = 0.7, col = \"black\"\n    )\n  }else{\n    text(\n      x = 500,\n      y = i + 0.4,\n      labels = pretty_pop_female,\n      pos = 4,\n      xpd = TRUE, cex = 0.7, col = \"white\"\n    )\n  }\n}\n\ntext(x = -max_count, y = nrow(data)+0.45, labels = \"male\", adj = 0, cex = 0.8, font = 1)\ntext(x = max_count, y = nrow(data)+0.45, labels = \"female\", adj = 1, cex = 0.8, font = 1)\n\ntitle(main = \"Population projection for Germany, 2020\", line = 1, adj = 0, col.main = \"#2c3e50\")\ntitle(main = NA, sub = \"Projection from 2015\\nbased on continued trend with higher immigration\n\", line = 1, font.sub = 3, cex.sub = 0.6, adj = 1, col.sub = \"#7f8c8d\")",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>R绘图入门</span>"
    ]
  },
  {
    "objectID": "14-R绘图入门.html#ggplot2",
    "href": "14-R绘图入门.html#ggplot2",
    "title": "14  R绘图入门",
    "section": "14.2 ggplot2",
    "text": "14.2 ggplot2\n下面这段话很长，但我一定要给大家介绍！！！！\nggplot2的设计理念，也是它相比于base-plot优秀的地方：\n每当我们看到一个新的软件，第一反应会是：为什么又要发明一个新软件？ggplot2是R世界里相对还比较年轻的一个包，在它之前，官方R已经有自己的基础图形系统（graphics包）和网格图形系统（grid包)，并且Deepayan-Sarkar也开发了lattice包，看起来R的世界对图形的支持已经足够强大了。那么我们不禁要问，为什么还要发明一套新的系统？\n打个比方，想想我们小时候怎样学中文的。最开始的时候我们要识字，不认识字就没法阅读和写作，但我们并不是一直按照一个个汉字学习的，而是通过句子和具体的场景故事学习的。为什么不在小学时背六年字典呢？那样可能认识所有的汉字。原因很简单，光有单字，我们不会说话，也无法阅读和写作。我们缺的是什么？答案是对文字的组织能力，或者说语法。\nR的基础图形系统基本上是一个“纸笔模型”，即：一块画布摆在面前，你可以在这里画几个点，在那里画几条线，指哪儿画哪儿。后来lattice包的出现稍微改善了这种情况，你可以说，我要画散点图或直方图，并且按照某个分类变量给图中的元素上色，此时数据才在画图中扮演了一定的中心角色，我们不用去想具体这个点要用什么颜色（颜色会根据变量自动生成)。但是lattice继承了R语言的一个糟糕特征，就是参数设置铺天盖地，足以让人窒息，光是一份xyplot()函数的帮助文档，恐怕就够我们消磨一天时间了，更重要的是,lattice仍然面向特定的统计图形，像基础图形系统一样，有直方图、箱线图、条形图等，它没有一套可以让数据分析者说话的语法。\n那么数据分析者是怎样说话的呢？他们从来不会说这条线用#FEO9BE颜色，那个点用三角形状，他们只会说，把图中的线用数据中的职业类型变量上色，或图中点的形状对应性别变量。有时候他们画了一幅散点图，但马上他们发现这幅图太拥挤，最好是能具体看一下里面不同收入阶层的特征，所以他们会说，把这幅图拆成七幅小图，每幅图对应一个收入阶层。然后发现散点图的趋势不明显最好加上回归直线，看看回归模型反映的趋势是什么，或者发现图中离群点太多最好做一下对数变换，减少大数值对图形的主导性。\n从始至终，数据分析者都在数据层面上思考问题，而不是拿着水彩笔和调色板在那里一笔一划作图，而计算机程序员则倾向于画点画线。Leland-Wilkinson的著作在理论上改善了这种状况，他提出了一套图形语法，让我们在考虑如何构建一幅图形的时候不再陷在具体的图形元素里面，而是把图形拆分为一些互相独立并且可以自由组合的成分。这套语法提出来之后他自己也做了一套软件，但显然这套软件没有被广泛采用；幸运的是，Hadley-Wickham在R语言中把这套想法巧妙地实现了。\n为了说明这种语法的思想，我们考虑图形中的一个成分——坐标系。常见的坐标系有两种：笛卡尔坐标系和极坐标系。在语法中，它们属于一个成分，可自由拆卸替换。笛卡尔坐标系下的条形图实际上可以对应极坐标系下的饼图，因为条形图的高可以对应饼图的角度，本质上没什么区别。因此在ggplot2中，从一幅条形图过渡到饼图，只需要加极少量的代码，把坐标系换一下就可以了。如果我们用纸笔模型，则可以想象，这完全是不同的两幅图，一幅图里面要画的是矩形，另一幅图要画扇形。\n更多的细节请看书，这里我们只是简略说明用语法画图对用纸笔画图来说在思维上的优越性；前者是说话后者是说字。\n\n数就是图，图就是数\n\n\n14.2.1 示例数据\n使用ggplot2自带的数据，这是一个不同汽车的耗油量数据。\n\nlibrary(ggplot2)\nmpg\n## # A tibble: 234 × 11\n##    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n##    &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n##  1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp…\n##  2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp…\n##  3 audi         a4           2    2008     4 manu… f        20    31 p     comp…\n##  4 audi         a4           2    2008     4 auto… f        21    30 p     comp…\n##  5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp…\n##  6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp…\n##  7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp…\n##  8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp…\n##  9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp…\n## 10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp…\n## # ℹ 224 more rows\n\n\ncty：城市\nhwy：耗油量\ndispl：发动机排量\ndrv：驱动系统，前驱、后驱、四驱\nmodel：车辆型号，共38种车型\ncyl：发动机缸数\nclass：车辆类型，双座、SUV、小型汽车等\n\n该数据集包含很多问题，比如引擎大小和油耗量有什么关系？是否有部分制造商更关注油耗问题？过去几年汽车油耗量有没有明显增加？\n\n\n14.2.2 数据、映射、几何对象\nggplot2图形的3个基本构成：\n\n数据；\n图形属性映射：设置变量如何映射到图形属性上，比如：x轴是什么？y轴是什么？颜色表示什么？形状表示什么？大小表示什么？\n几何对象：你要使用的图形元素，点、线条、多边形等\n\n\nggplot(data = mpg, # 数据\n       mapping = aes(x = displ, y = hwy))+ # 图形属性映射\n  geom_point()    # 几何对象\n\n\n\n\n\n\n\n\n通过+添加图层，以ggplot()开头，这是典型的ggplot2使用方法，全都一样。\n1行代码就对应一个图层，层层叠加，靠后的图层在上面。\n一步一步的运行，更方便理解图层的概念：\n\nggplot()\n\n\n\n\n\n\n\n\n\nggplot(data = mpg, # 数据\n       mapping = aes(x = displ, y = hwy))\n\n\n\n\n\n\n\n\n\nggplot(data = mpg, # 数据\n       mapping = aes(x = displ, y = hwy))+ # 图形属性映射\n  geom_point()    # 几何对象\n\n\n\n\n\n\n\n\n\n\n14.2.3 颜色、大小、形状和其他图形属性\n为了展示更多信息，我们可以调整其他图形属性，比如：颜色、形状、大小等。\n将车辆类型映射为颜色（用不同的颜色表示不同的车辆类型）：\n\nggplot(mpg, aes(displ, hwy, color = class))+\n  geom_point()\n\n\n\n\n\n\n\n\n用不同的形状表示驱动方式：\n\nggplot(mpg, aes(displ, hwy, shape = drv))+\n  geom_point()\n\n\n\n\n\n\n\n\n用不同的大小表示发动机缸数：\n\nggplot(mpg, aes(displ, hwy, size = cyl))+\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n14.2.4 标度\n标度（scale）可以对颜色、大小、形状等属性进行更改。前面用我们不同的图形属性表示不同的变量，通过标度可以进行具体的修改。比如：\n\n用颜色表示车辆类型，到底用哪种颜色？\n用形状表示驱动方式，到底用哪几种形状？\n用点的大小表示汽车缸数，那点的大小是从多大到多大？\n\n下面这张图是没修改的默认图形属性：\n\nggplot(mpg, aes(displ, hwy, size = cyl, shape = drv, color = class))+\n  geom_point()\n\n\n\n\n\n\n\n\n如果我们想要修改颜色，怎么办？通过标度修改即可。\n\n修改颜色：scale_color_xxx\n修改大小：scale_size_xxx\n修改形状：scale_shape_xxx\n…….(?scale_)\n\n\nggplot(mpg, aes(displ, hwy, size = cyl, shape = drv, color = class))+\n  geom_point()+\n  scale_size_continuous(range = c(2,8))+ # 修改大小\n  scale_color_brewer()+                  # 修改颜色\n  scale_shape_manual(values = c(15:17))  # 修改形状\n\n\n\n\n\n\n\n\n形状有20+种：https://ggplot2.tidyverse.org/reference/scale_shape.html\n\n\n14.2.5 分面\n对于分类变量，比如class，可以使用不同的颜色、形状等表示，还可以使用分面的形式表示。\n\nggplot(mpg, aes(displ, hwy))+\n  geom_point()+\n  facet_wrap(vars(class)) # 分面\n\n\n\n\n\n\n\n\n\n\n14.2.6 几何对象\nggplot2几乎覆盖了所有的图形类型，比如常见的：\n\n散点图\n折线图\n条形图\n直方图\n密度图\n箱线图\n小提琴图\n热图\n等高线图\n……\n\n只要修改geom_xxx即可，非常简单。\n比如添加一条拟合线就用geom_smooth即可，不同的geom_xxx有不同的参数：\nggplot(mpg, aes(displ, hwy))+\n  geom_point()+\n  geom_smooth() # 添加拟合线\n## `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\nggplot(mpg, aes(displ, hwy))+\n  geom_point()+\n  geom_smooth(span = 0.2) # 修改平滑度\n## `geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\nggplot(mpg, aes(displ, hwy))+\n  geom_point()+\n  geom_smooth(method = \"lm\") # 修改方法，默认是loess\n## `geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\n绘制散点图：\n\nggplot(mpg, aes(drv, hwy))+\n  geom_point() # 散点图\n\n\n\n\n\n\n\n\n有时点太多会重叠，可以增加随机抖动，让点分散开，不会该变原有的数据分布，使布局更加合理：\n\nggplot(mpg, aes(drv, hwy))+\n  geom_jitter() # 抖动散点图\n\n\n\n\n\n\n\n\n箱线图：\n\nggplot(mpg, aes(drv, hwy))+\n  geom_boxplot()\n\n\n\n\n\n\n\n\n小提琴图：\n\nggplot(mpg, aes(drv, hwy))+\n  geom_violin()\n\n\n\n\n\n\n\n\n直方图：\n\nggplot(mpg, aes(hwy))+\n  geom_histogram()\n## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n频数多边形图：\n\nggplot(mpg, aes(hwy))+\n  geom_freqpoly()\n## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n密度图：\n\nggplot(mpg, aes(hwy))+\n  geom_density()\n\n\n\n\n\n\n\n\n条形图：\n\nggplot(mpg, aes(manufacturer))+\n  geom_bar()\n\n\n\n\n\n\n\n\n上面的条形图的映射中只有一个manufacturer变量，此时ggplot2会自动给你计算每个类型的数量：\n\ntable(mpg$manufacturer)\n## \n##       audi  chevrolet      dodge       ford      honda    hyundai       jeep \n##         18         19         37         25          9         14          8 \n## land rover    lincoln    mercury     nissan    pontiac     subaru     toyota \n##          4          3          4         13          5         14         34 \n## volkswagen \n##         27\n\n但多数情况下都是用两个变量的，其中1个变量是数量，不需要它帮我们计算，此时需要加stat = \"identity\"参数：\ndrugs &lt;- data.frame(\n  drug = c(\"a\", \"b\", \"c\"),\n  effect = c(4.2, 9.7, 6.1)\n)\n\nggplot(drugs, aes(drug, effect)) + \n  geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\n\n\n14.2.7 坐标轴\n坐标轴的各种细节都可以修改，比如标题、标签、颜色、粗细等。\n# 默认坐标轴标签\nggplot(mpg, aes(cty, hwy)) +\n  geom_point(alpha = 1 / 3)\n\n# 修改坐标轴标签\nggplot(mpg, aes(cty, hwy)) +\n  geom_point(alpha = 1 / 3) + \n  xlab(\"city driving (mpg)\") + \n  ylab(\"highway driving (mpg)\")\n\n# 移除坐标轴标签\nggplot(mpg, aes(cty, hwy)) +\n  geom_point(alpha = 1 / 3) + \n  xlab(NULL) + \n  ylab(NULL)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n14.2.8 主题\n用于修改各种细节。\n\np &lt;- ggplot(mpg, aes(drv, hwy, color = drv))+\n  geom_boxplot()\np\n\n\n\n\n\n\n\n\nggplot2自带一些默认主题：\np+theme_bw()\np+theme_classic()\n\n\n\n\n\n\n\n\n\n\n所有细节都可以修改：\n\n\n\n\n14.2.9 保存图片\n\nggplot(mpg, aes(displ, hwy, colour = factor(cyl))) +\n  geom_point()\n\n# 默认保存最后一次绘制的图形\nggsave(\"plot.png\", width = 5, height = 5)\n\n\n\n14.2.10 扩展包\n\n100+免费的ggplot2扩展包：https://exts.ggplot2.tidyverse.org/gallery/\n\n\n\n\n14.2.11 金字塔图\n使用ggplot2绘制上面的金字塔图。\n\ndata = read.table(\"datasets/02-splitbarplot_PopGermany.csv\", sep = \",\", header = TRUE)\n\nlibrary(tidyr)\n\ndata &lt;- pivot_longer(data, cols = 2:3,names_to = \"group\",values_to = \"values\")\ndata$values &lt;- ifelse(data$group==\"male\",-data$values,data$values)\n\n\nlibrary(ggplot2)\nlibrary(scales)\n\nggplot(data)+\n  geom_bar(stat = \"identity\",aes(values, age.span,fill = group))+\n  scale_fill_manual(values = c(\"#C0392B\",\"#2980B9\"),guide=\"none\")+\n  annotate(\"text\",x=-Inf,y=Inf,label=\"male\",hjust=-0.2,vjust=1)+\n  annotate(\"text\",x=Inf,y=Inf,label=\"female\",hjust=1.2,vjust=1)+\n  annotate(\"text\",\n           x=ifelse(data[7:40,]$group==\"male\",-150000,150000),\n           y=data[7:40,]$age.span,\n           label=paste0(round(abs(data[7:40,]$values)/1000000,1),\"m\"),\n           color=\"white\",size=3,\n           hjust=ifelse(data[7:40,]$group==\"male\",1,0))+\n  annotate(\"text\",\n           x=ifelse(data[1:6,]$group==\"male\",\n                    data[1:6,]$values-150000,\n                    data[1:6,]$values+150000),\n           y=data[1:6,]$age.span,\n           label=paste0(round(abs(data[1:6,]$values)/1000,1),\"k\"),\n           color=\"black\",size=3,\n           hjust=ifelse(data[1:6,]$group==\"male\",1,0))+\n  labs(x=NULL,y=NULL,\n       caption = \"Projection from 2015 \\n based on continued trend with higher immigration\")+\n  theme(panel.grid.minor.x = element_blank(),\n        panel.grid.major.x = element_blank(),\n        #panel.grid.major.y = element_blank(),\n        axis.text.x = element_blank(),\n        axis.ticks = element_blank(),\n        axis.text.y = element_text(color=\"black\"),\n        plot.caption = element_text(color = \"gray50\",face = 3))\n\n\n\n\n\n\n\n\n\n\n14.2.12 参考资料\n前两个是ggplot2参考资料，唯2真神！！\n\n《ggplot2：数据分析与图形艺术》：https://ggplot2-book.org/\n《R数据可视化手册》：https://r-graphics.org/\n《R绘图系统》\n\n免费的R语言绘图网站：\n\nhttps://r-charts.com/\nhttps://r-graph-gallery.com/",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>R绘图入门</span>"
    ]
  },
  {
    "objectID": "15-tidyverse简介.html",
    "href": "15-tidyverse简介.html",
    "title": "15  tidyverse简介",
    "section": "",
    "text": "15.1 tidyverse简介\ntidyverse是专门为数据科学（数据整理、数据清洗、数据读取和保存、数据可视化等）而设计的系列R包。加载它即可加载以下R包：\ntidyverse::tidyverse_packages()\n##  [1] \"broom\"         \"conflicted\"    \"cli\"           \"dbplyr\"       \n##  [5] \"dplyr\"         \"dtplyr\"        \"forcats\"       \"ggplot2\"      \n##  [9] \"googledrive\"   \"googlesheets4\" \"haven\"         \"hms\"          \n## [13] \"httr\"          \"jsonlite\"      \"lubridate\"     \"magrittr\"     \n## [17] \"modelr\"        \"pillar\"        \"purrr\"         \"ragg\"         \n## [21] \"readr\"         \"readxl\"        \"reprex\"        \"rlang\"        \n## [25] \"rstudioapi\"    \"rvest\"         \"stringr\"       \"tibble\"       \n## [29] \"tidyr\"         \"xml2\"          \"tidyverse\"\n其中比较重要的有：\n这些包共享高级设计理念和低级语法以及数据结构，因此学习一个包就可以更轻松地学习下一个包。\ntidyverse聚焦于设计可以被广泛使用和轻松理解的R包和函数。无论是过去还是现在，很大一部分R用户都不是软件或工具创建者，而只是使用工具的人。因此R用户通常没有（或需要）计算机科学背景，并且许多人对编写自己的R包不感兴趣。\n在函数命名方面，tidyverse的解决方法是使用描述性和显式的函数名称，而不是那些简短的和隐式的函数名称。常见方法通过单个动词实现，动词-名词组合式命名也非常有效。比如：",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>tidyverse简介</span>"
    ]
  },
  {
    "objectID": "15-tidyverse简介.html#tidyverse简介",
    "href": "15-tidyverse简介.html#tidyverse简介",
    "title": "15  tidyverse简介",
    "section": "",
    "text": "tibble\ntidyr\ndplyr\nggplot2\nforcats\nstringr\nlubridate\npurrr\n\n\n\n\n\nfilter：筛选行\narrange：排列行\nselect：选择列\nmutate：新建列\nrename：重命名列",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>tidyverse简介</span>"
    ]
  },
  {
    "objectID": "15-tidyverse简介.html#管道符简介",
    "href": "15-tidyverse简介.html#管道符简介",
    "title": "15  tidyverse简介",
    "section": "15.2 管道符简介",
    "text": "15.2 管道符简介\ntidyverse另一个比较特殊的特性是管道符（%&gt;%）的使用。管道符可以把多个操作连接起来，像一个管道一样让数据流通。\n使用ggplot2自带的数据进行说明，这是一个不同汽车的耗油量数据。\n\nlibrary(tidyverse)\n## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n## ✔ dplyr     1.1.4     ✔ readr     2.1.5\n## ✔ forcats   1.0.0     ✔ stringr   1.5.1\n## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n## ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n## ✔ purrr     1.0.2     \n## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n## ✖ dplyr::filter() masks stats::filter()\n## ✖ dplyr::lag()    masks stats::lag()\n## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nmpg\n## # A tibble: 234 × 11\n##    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class\n##    &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;\n##  1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp…\n##  2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp…\n##  3 audi         a4           2    2008     4 manu… f        20    31 p     comp…\n##  4 audi         a4           2    2008     4 auto… f        21    30 p     comp…\n##  5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp…\n##  6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp…\n##  7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp…\n##  8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp…\n##  9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp…\n## 10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp…\n## # ℹ 224 more rows\n\n\ncty：城市\nhwy：耗油量\ndispl：发动机排量\ndrv：驱动系统，前驱、后驱、四驱\nmodel：车辆型号，共38种车型\ncyl：发动机缸数\nclass：车辆类型，双座、SUV、小型汽车等\n\n假如我们要进行以下操作：\n1.选择”manufacturer”,“cyl”,“drv”,“hwy”这4列； 2.筛选manufacturer是”audi”的行； 3.将manufacturer重命名为manuf; 4.按照drv进行分组，计算每组的hwy的平均值\n如果是在R语言基础语法中，可以像下面这样写：\n\ntmp &lt;- mpg[mpg$manufacturer == \"audi\",c(\"manufacturer\",\"cyl\",\"drv\",\"hwy\")]\ncolnames(tmp)[1] &lt;- \"manuf\"\ntapply(tmp$hwy, tmp$drv, mean)\n##        4        f \n## 25.27273 28.28571\n\n这样做没什么问题，但是中间步骤需要不停地取名字（如果步骤很多的话就要取很多名字），而且使用的语法和函数形式也不够统一，不够“优雅”。\n但是使用tidyverse和管道符，可以像下面这样写：\n\n# tidyverse中变量的名字不用加引号，\n# 但是如果变量名字中有中文或者空格，建议用``引起来\nmpg %&gt;% \n  select(manufacturer, cyl, drv, hwy) %&gt;%       # 选择列\n  filter(manufacturer == \"audi\") %&gt;%            # 筛选行\n  rename(manuf = manufacturer) %&gt;%              # 重命名\n  group_by(drv) %&gt;%                             # 分组\n  summarise(mm = mean(hwy))                     # 分组汇总\n## # A tibble: 2 × 2\n##   drv      mm\n##   &lt;chr&gt; &lt;dbl&gt;\n## 1 4      25.3\n## 2 f      28.3\n\n所有函数使用%&gt;%连接起来，中间不需要取名字，各个函数的名字也十分形象，代码很容易看懂。管道符左侧函数的结果可以作为右侧函数的输入。\n我们一步一步的分解看一下：\n\n# 第一步\nselect(mpg, manufacturer, cyl, drv, hwy)\n## # A tibble: 234 × 4\n##    manufacturer   cyl drv     hwy\n##    &lt;chr&gt;        &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n##  1 audi             4 f        29\n##  2 audi             4 f        29\n##  3 audi             4 f        31\n##  4 audi             4 f        30\n##  5 audi             6 f        26\n##  6 audi             6 f        26\n##  7 audi             6 f        27\n##  8 audi             4 4        26\n##  9 audi             4 4        25\n## 10 audi             4 4        28\n## # ℹ 224 more rows\n\n# 第二步\nfilter(select(mpg, manufacturer, cyl, drv, hwy),\n       manufacturer == \"audi\")\n## # A tibble: 18 × 4\n##    manufacturer   cyl drv     hwy\n##    &lt;chr&gt;        &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n##  1 audi             4 f        29\n##  2 audi             4 f        29\n##  3 audi             4 f        31\n##  4 audi             4 f        30\n##  5 audi             6 f        26\n##  6 audi             6 f        26\n##  7 audi             6 f        27\n##  8 audi             4 4        26\n##  9 audi             4 4        25\n## 10 audi             4 4        28\n## 11 audi             4 4        27\n## 12 audi             6 4        25\n## 13 audi             6 4        25\n## 14 audi             6 4        25\n## 15 audi             6 4        25\n## 16 audi             6 4        24\n## 17 audi             6 4        25\n## 18 audi             8 4        23\n\n# 第三步\nrename(filter(select(mpg, manufacturer, cyl, drv, hwy),\n              manufacturer == \"audi\"),\n       manuf = manufacturer)\n## # A tibble: 18 × 4\n##    manuf   cyl drv     hwy\n##    &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n##  1 audi      4 f        29\n##  2 audi      4 f        29\n##  3 audi      4 f        31\n##  4 audi      4 f        30\n##  5 audi      6 f        26\n##  6 audi      6 f        26\n##  7 audi      6 f        27\n##  8 audi      4 4        26\n##  9 audi      4 4        25\n## 10 audi      4 4        28\n## 11 audi      4 4        27\n## 12 audi      6 4        25\n## 13 audi      6 4        25\n## 14 audi      6 4        25\n## 15 audi      6 4        25\n## 16 audi      6 4        24\n## 17 audi      6 4        25\n## 18 audi      8 4        23\n\n# 第四步\ngroup_by(rename(filter(select(mpg, manufacturer, cyl, drv, hwy),\n                       manufacturer == \"audi\"),\n                manuf = manufacturer),\n         drv)\n## # A tibble: 18 × 4\n## # Groups:   drv [2]\n##    manuf   cyl drv     hwy\n##    &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt;\n##  1 audi      4 f        29\n##  2 audi      4 f        29\n##  3 audi      4 f        31\n##  4 audi      4 f        30\n##  5 audi      6 f        26\n##  6 audi      6 f        26\n##  7 audi      6 f        27\n##  8 audi      4 4        26\n##  9 audi      4 4        25\n## 10 audi      4 4        28\n## 11 audi      4 4        27\n## 12 audi      6 4        25\n## 13 audi      6 4        25\n## 14 audi      6 4        25\n## 15 audi      6 4        25\n## 16 audi      6 4        24\n## 17 audi      6 4        25\n## 18 audi      8 4        23\n\n# 第五步\nsummarise(group_by(rename(filter(select(mpg, manufacturer, cyl, drv, hwy),\n                                 manufacturer == \"audi\"),\n                          manuf = manufacturer),\n                   drv),\n          mm = mean(hwy))\n## # A tibble: 2 × 2\n##   drv      mm\n##   &lt;chr&gt; &lt;dbl&gt;\n## 1 4      25.3\n## 2 f      28.3\n\n这种写法能够流畅运行主要得益于tidyverse系列函数的统一设计标准，上面演示的这些函数中，它们的第一个参数都是.data，刚好能够让上一步的结果作为下一步的输入数据，而且还可以省略.data参数。\n\n?select\n?filter\n?rename\n\n所以完整的写法应该是下面这样的，用.表示上一步得到的结果，但是由于tidyverse完美的设计，这种情况下不写第一个参数也完全OK：\n\nmpg %&gt;% \n  select(.data = . , manufacturer, cyl, drv, hwy) %&gt;% \n  filter(.data = . , manufacturer == \"audi\") %&gt;% \n  rename(.data = . , manuf = manufacturer) %&gt;% \n  group_by(.data = . , drv) %&gt;% \n  summarise(.data = . , mm = mean(hwy))\n## # A tibble: 2 × 2\n##   drv      mm\n##   &lt;chr&gt; &lt;dbl&gt;\n## 1 4      25.3\n## 2 f      28.3\n\n并且在Rstudio中，管道符有快捷键，直接按：control+shift+m，即可输入管道符。\ntidyverse还有各种人性化的设计，种种优点使其大受欢迎！\n%&gt;%管道符其实是magrittr包中的，你需要先加载这个R包才能使用（加载tidyverse会自动加载这个包）。在R语言4.1版本之后，R也引入了原生的管道符：|&gt;，在大多数情况下，原生管道符和tidyverse管道符可以替换使用，但是二者也有一些差别（具体不展开，可参考：比较R中的管道符）。所以，以上代码你写成下面这样也OK:\n\nmpg |&gt; select(manufacturer, cyl, drv, hwy) |&gt;\n  filter(manufacturer == \"audi\") |&gt;\n  rename(manuf = manufacturer) |&gt;\n  group_by(drv) |&gt;\n  summarise(mm = mean(hwy))  \n## # A tibble: 2 × 2\n##   drv      mm\n##   &lt;chr&gt; &lt;dbl&gt;\n## 1 4      25.3\n## 2 f      28.3\n\n管道符和tidyverse是天生绝配，那基础语法和管道符可以连用吗？答案是可以。但是由于基础语法中的函数设计不如tidyverse那么统一规范，会出现各种初学者搞不懂的报错！所以我建议你只在使用tidyverse时才使用管道符，在基础语法中不要用（大佬例外）。\n默认快捷键可修改到底是哪种管道符：",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>tidyverse简介</span>"
    ]
  },
  {
    "objectID": "15-tidyverse简介.html#使用简介",
    "href": "15-tidyverse简介.html#使用简介",
    "title": "15  tidyverse简介",
    "section": "15.3 使用简介",
    "text": "15.3 使用简介\n下面用一个简单的示例演示tidyverse中部分函数的用法。更多的用法我会在tidyverse合集中详细介绍。\n还是以TCGA官网下载的乳腺癌患者的临床信息为例，该数据包含：患者ID、样本ID、样本类型（normal还是tumor？）、年龄、性别等。\n该示例将全部使用tidyverse完成，大家可以和前面介绍的R语言基础语法对数据框的操作进行比较。\n加载R包：\n\nlibrary(tidyverse)\n\n\n# 读取文件\nlibrary(readxl)\nbrca_clin &lt;- read_xlsx(\"F:/R_books/R_beginners/brca_clin.xlsx\", col_names = T)\n\n# 查看数据基本情况\nglimpse(brca_clin)\n## Rows: 20\n## Columns: 9\n## $ barcode                &lt;chr&gt; \"TCGA-BH-A1FC-11A-32R-A13Q-07\", \"TCGA-AC-A2FM-1…\n## $ patient                &lt;chr&gt; \"TCGA-BH-A1FC\", \"TCGA-AC-A2FM\", \"TCGA-BH-A0DO\",…\n## $ sample                 &lt;chr&gt; \"TCGA-BH-A1FC-11A\", \"TCGA-AC-A2FM-11B\", \"TCGA-B…\n## $ sample_type            &lt;chr&gt; \"Solid Tissue Normal\", \"Solid Tissue Normal\", \"…\n## $ initial_weight         &lt;dbl&gt; 260, 220, 130, 260, 200, 60, 320, 310, 100, 250…\n## $ ajcc_pathologic_stage  &lt;chr&gt; \"Stage IIA\", \"Stage IIB\", \"Stage I\", \"Stage IA\"…\n## $ days_to_last_follow_up &lt;chr&gt; \"NA\", \"NA\", \"1644\", \"501\", \"660\", \"3247\", \"NA\",…\n## $ gender                 &lt;chr&gt; \"female\", \"female\", \"female\", \"female\", \"female…\n## $ age_at_index           &lt;dbl&gt; 78, 87, 78, 63, 41, 59, 60, 39, 54, 51, 51, 44,…\n\n变量名修改：\n\nbrca_clin &lt;- brca_clin %&gt;% \n  rename(weight = initial_weight, stage = ajcc_pathologic_stage,\n         days = days_to_last_follow_up, age = age_at_index)\ncolnames(brca_clin)\n## [1] \"barcode\"     \"patient\"     \"sample\"      \"sample_type\" \"weight\"     \n## [6] \"stage\"       \"days\"        \"gender\"      \"age\"\n\n选择第5~9列：\n\nbrca_clin &lt;- brca_clin %&gt;% \n  select(5:9)\nglimpse(brca_clin)\n## Rows: 20\n## Columns: 5\n## $ weight &lt;dbl&gt; 260, 220, 130, 260, 200, 60, 320, 310, 100, 250, 130, 110, 470,…\n## $ stage  &lt;chr&gt; \"Stage IIA\", \"Stage IIB\", \"Stage I\", \"Stage IA\", \"Stage IIB\", \"…\n## $ days   &lt;chr&gt; \"NA\", \"NA\", \"1644\", \"501\", \"660\", \"3247\", \"NA\", \"NA\", \"1876\", \"…\n## $ gender &lt;chr&gt; \"female\", \"female\", \"female\", \"female\", \"female\", \"female\", \"fe…\n## $ age    &lt;dbl&gt; 78, 87, 78, 63, 41, 59, 60, 39, 54, 51, 51, 44, 64, 56, 71, 71,…\n\n按照age从小到大排序数据框：\n\nbrca_clin &lt;- brca_clin %&gt;% \n  arrange(age)\n#brca_clin\n\n按照从大到小的顺序排列：\n\nbrca_clin &lt;- brca_clin %&gt;% \n  arrange(desc(age))\n\n查看有几个类别，以及每个类别的数量：\n\nbrca_clin %&gt;% count(stage)\n## # A tibble: 6 × 2\n##   stage          n\n##   &lt;chr&gt;      &lt;int&gt;\n## 1 Stage I        3\n## 2 Stage IA       3\n## 3 Stage IIA      5\n## 4 Stage IIB      6\n## 5 Stage IIIA     2\n## 6 Stage IIIC     1\n\n变量重编码和修改：\n用case_when：\n\nbrca_clin %&gt;% \n  mutate(stage = case_when(stage == \"Stage IIB\" ~ \"Stage_2\",\n                           stage == \"Stage IIA\" ~ \"Stage_2\",\n                           stage == \"Stage IA\" ~ \"Stage_1\",\n                           stage == \"Stage I\" ~ \"Stage_1\",\n                           stage == \"Stage IIIA\" ~ \"Stage_3\",\n                           stage == \"Stage IIIC\" ~ \"Stage_3\",\n                           .default = NULL\n                           )) %&gt;% \n  count(stage)\n## # A tibble: 3 × 2\n##   stage       n\n##   &lt;chr&gt;   &lt;int&gt;\n## 1 Stage_1     6\n## 2 Stage_2    11\n## 3 Stage_3     3\n\ncase_when另一种用法：\n\nbrca_clin %&gt;% \n  mutate(stage = case_when(stage %in% c(\"Stage IIB\",\"Stage IIA\") ~ \"Stage_2\",\n                           stage %in% c(\"Stage IA\",\"Stage I\") ~ \"Stage_1\",\n                           stage %in% c(\"Stage IIIA\",\"Stage IIIC\") ~ \"Stage_3\",\n                           )) %&gt;% \n  count(stage)\n## # A tibble: 3 × 2\n##   stage       n\n##   &lt;chr&gt;   &lt;int&gt;\n## 1 Stage_1     6\n## 2 Stage_2    11\n## 3 Stage_3     3\n\n或者用case_match:\n\nbrca_clin %&gt;% \n  mutate(stage = case_match(stage,\n                           c(\"Stage IIB\",\"Stage IIA\") ~ \"Stage_2\",\n                           c(\"Stage IA\",\"Stage I\") ~ \"Stage_1\",\n                           c(\"Stage IIIA\",\"Stage IIIC\") ~ \"Stage_3\"\n                           )) %&gt;% \n  count(stage)\n## # A tibble: 3 × 2\n##   stage       n\n##   &lt;chr&gt;   &lt;int&gt;\n## 1 Stage_1     6\n## 2 Stage_2    11\n## 3 Stage_3     3\n\n根据年龄进行分组，大于60岁是old，小于等于60岁是young:\n\n# 先看下年龄是不是数值型\nglimpse(brca_clin)\n## Rows: 20\n## Columns: 5\n## $ weight &lt;dbl&gt; 220, 260, 130, 200, 70, 470, 260, 130, 320, 60, 90, 100, 200, 2…\n## $ stage  &lt;chr&gt; \"Stage IIB\", \"Stage IIA\", \"Stage I\", \"Stage IIA\", \"Stage IIA\", …\n## $ days   &lt;chr&gt; \"NA\", \"NA\", \"1644\", \"385\", \"1800\", \"1972\", \"501\", \"214\", \"NA\", …\n## $ gender &lt;chr&gt; \"female\", \"female\", \"female\", \"female\", \"female\", \"female\", \"fe…\n## $ age    &lt;dbl&gt; 87, 78, 78, 71, 71, 64, 63, 63, 60, 59, 56, 54, 54, 51, 51, 47,…\nis.numeric(brca_clin$age)\n## [1] TRUE\n\n开始修改：\n\nbrca_clin &lt;- brca_clin %&gt;% \n  mutate(age = ifelse(age&gt;60,\"old\",\"young\"))\n\nbrca_clin %&gt;% count(age)\n## # A tibble: 2 × 2\n##   age       n\n##   &lt;chr&gt; &lt;int&gt;\n## 1 old       8\n## 2 young    12\n\nNA修改(这个数据框里的NA是字符型，并不是真正的NA)：\n\nbrca_clin &lt;- brca_clin %&gt;% \n  mutate(days = ifelse(days == \"NA\",NA,days))\nbrca_clin %&gt;% select(days)\n## # A tibble: 20 × 1\n##    days \n##    &lt;chr&gt;\n##  1 &lt;NA&gt; \n##  2 &lt;NA&gt; \n##  3 1644 \n##  4 385  \n##  5 1800 \n##  6 1972 \n##  7 501  \n##  8 214  \n##  9 &lt;NA&gt; \n## 10 3247 \n## 11 1321 \n## 12 1876 \n## 13 2442 \n## 14 707  \n## 15 5749 \n## 16 1206 \n## 17 &lt;NA&gt; \n## 18 660  \n## 19 &lt;NA&gt; \n## 20 &lt;NA&gt;",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>tidyverse简介</span>"
    ]
  },
  {
    "objectID": "15-tidyverse简介.html#其他示例",
    "href": "15-tidyverse简介.html#其他示例",
    "title": "15  tidyverse简介",
    "section": "15.4 其他示例",
    "text": "15.4 其他示例\nR语言可视化系列合集：\n\nR可视化\n\npurrr的使用（等我在tidyverse合集中再详细介绍）：\n\n批量保存图片：免疫浸润结果可视化\n批量建模：R语言亚组分析及森林图绘制\n批量t检验：R语言倾向性评分：回归和分层\n……\n\n详细的R包介绍推文：\n\ndplyr系列：\n\n使用dplyr进行数据分析：入门篇\ndplyr强大的分组汇总\ndplyr中的across操作\ndplyr中的行操作\n\nforcats系列：\n\nR语言处理因子之forcats包介绍（1）\nR语言处理因子之forcats包介绍（2）\nR语言处理因子之forcats包介绍（3）\nR语言处理因子之forcats包介绍（4）\n\ntidyr系列：\n\n宽数据变为长数据的5种情况\n长数据变为宽数据的7种情况\n长宽数据转换的特殊情况\n\n使用lubridate处理日期时间",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>tidyverse简介</span>"
    ]
  },
  {
    "objectID": "9999-appendix.html",
    "href": "9999-appendix.html",
    "title": "附录 A — 其他合集",
    "section": "",
    "text": "A.1 R语言零基础入门",
    "crumbs": [
      "附录",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>其他合集</span>"
    ]
  },
  {
    "objectID": "9999-appendix.html#r语言零基础入门",
    "href": "9999-appendix.html#r语言零基础入门",
    "title": "附录 A — 其他合集",
    "section": "",
    "text": "R语言实战医学统计合集：R语言零基础入门\n在线版电子书：R语言零基础入门\ngithub地址：R语言零基础入门\n视频版教程：R语言零基础入门",
    "crumbs": [
      "附录",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>其他合集</span>"
    ]
  },
  {
    "objectID": "9999-appendix.html#医学统计",
    "href": "9999-appendix.html#医学统计",
    "title": "附录 A — 其他合集",
    "section": "A.2 医学统计",
    "text": "A.2 医学统计\n\nR语言实战医学统计合集：R语言实战医学统计\n在线版电子书：R语言实战医学统计\nPDF版电子书：R语言实战医学统计\ngithub地址：R语言实战医学统计\n视频版教程：R语言实战医学统计",
    "crumbs": [
      "附录",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>其他合集</span>"
    ]
  },
  {
    "objectID": "9999-appendix.html#临床预测模型",
    "href": "9999-appendix.html#临床预测模型",
    "title": "附录 A — 其他合集",
    "section": "A.3 临床预测模型",
    "text": "A.3 临床预测模型\n\n临床预测模型合集：临床预测模型\n在线版电子书：R语言实战临床预测模型\nPDF版电子书：R语言实战临床预测模型\ngithub地址：R语言实战临床预测模型",
    "crumbs": [
      "附录",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>其他合集</span>"
    ]
  },
  {
    "objectID": "9999-appendix.html#机器学习",
    "href": "9999-appendix.html#机器学习",
    "title": "附录 A — 其他合集",
    "section": "A.4 机器学习",
    "text": "A.4 机器学习\n医学和生信笔记后台回复caret即可获取caret包的合集教程；回复tidymodels即可获取tidymodels的合集教程；回复mlr3即可获取mlr3合集教程，回复机器学习即可获取机器学习推文合集。\n\nR语言机器学习合集：R语言机器学习\n在线版电子书：R语言实战机器学习\nPDF版电子书：R语言实战机器学习\ngithub地址：R语言实战机器学习",
    "crumbs": [
      "附录",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>其他合集</span>"
    ]
  },
  {
    "objectID": "9999-appendix.html#模型解释",
    "href": "9999-appendix.html#模型解释",
    "title": "附录 A — 其他合集",
    "section": "A.5 模型解释",
    "text": "A.5 模型解释\n包括各种黑盒模型的解释方法，如SHAP、局部代理法、分解解释等：\n\n模型解释合集：模型解释合集",
    "crumbs": [
      "附录",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>其他合集</span>"
    ]
  },
  {
    "objectID": "9999-appendix.html#生信数据挖掘",
    "href": "9999-appendix.html#生信数据挖掘",
    "title": "附录 A — 其他合集",
    "section": "A.6 生信数据挖掘",
    "text": "A.6 生信数据挖掘\n生信数据挖掘合集：生信数据挖掘\n医学和生信笔记公众号所有关于生信数据挖掘的推文都可以免费下载使用，请看：“灌水”生信类文章会用到哪些生信下游分析？（附下载地址）\ngithub地址：R语言生信数据挖掘",
    "crumbs": [
      "附录",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>其他合集</span>"
    ]
  },
  {
    "objectID": "9999-appendix.html#扫码关注",
    "href": "9999-appendix.html#扫码关注",
    "title": "附录 A — 其他合集",
    "section": "A.7 扫码关注",
    "text": "A.7 扫码关注\n欢迎扫码关注：医学和生信笔记",
    "crumbs": [
      "附录",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>其他合集</span>"
    ]
  }
]