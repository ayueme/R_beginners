---
title: "控制结构和自编函数"
---

在正常情况下，R中的代码是从上到下按顺序执行的，但是有些时候我们可能想要重复执行某些操作，或者只在满足某些条件时执行某个操作，而在不满足条件时执行另一种操作。这时候就需要不同的控制结构。

本章会介绍两种控制结构，一种是循环结构，另一种是分支结构。

## 循环结构

在处理实际问题时，我们经常会遇到以下问题，比如：重复执行某个操作，这时候就要用到一些常见的控制语句，比如：`for`循环、`while`循环等。

### for循环

重复执行某个操作，直到变量的值不再包含在序列seq中为止。基本语法：

```r
for (var in seq) { statment }
```

举个简单的例子，如果`i`在1-5里面，就打印`你好`：

```{r}
# i会从1开始一直取到5
for(i in 1:5) { 
  print("你好")
}
```

在实际使用时，最好先准备一个**容器**，用来存放`for`循环的输出，这样可以加快运行速度。

假如我们有一个数据框如下：

```{r}
set.seed(123)
df <- data.frame(a = rnorm(10),
                 b = rnorm(10),
                 c = rnorm(10),
                 d = rnorm(10)
                 )
df
```

现在我们要计算每列的中位数，我们可以使用for循环实现：

```{r}
output <- vector("double", ncol(df)) # 准备容器

for(i in 1:ncol(df)){                # for循环
  output[i] <- median(df[,i])
}

output
```

以上也是最常见的for循环的结构，主要包括3个部分：

- 输出：`output <- vector("double", ncol(df))`。在开始循环之前就要给输出分配足够的空间，这样做可以提高运行速度；
- 序列：`i in 1:ncol(df)`。
- 循环体：output[i] <- median(df[,i])。这部分是具体运行的操作，每次运行都会使用一个不同的i值，第1次是output[1] <- median(df[,1])，第2次是output[2] <- median(df[,2])，以此类推。

### while循环

while循环也是重复执行某个操作，直到条件不再满足为止，适用于不知道循环几次的情况。

```r
while (cond) { statment }
```
while循环比for循环简单，for循环总是可以改写成while循环，但是while循环不一定能改写成for循环：

```r
for( i in seq_along(x)){
  statment
}

# 等价于
i = 1
while(i <= length(x)){
  statment
  i = i +1
}
```

while循环不如for循环常见，大家感兴趣可以自己学习。

## 分支结构

如果符合条件（必须返回逻辑值，即`TRUE`或者`FALSE`），就执行某个操作。是大家中学数学中都学过的`if-else`结构。`if-else`经常和`for`循环连用。

### if-else

1个分支的情况比较少见，但是也有，基本语法如下：

```r
if(条件) {
  操作
}
```

举个简单例子，如果x>5，就打印“大于5”：

```{r}
x <- 7

if(x > 5){print("大于5")}

# 可以简写成
if(x > 5) print("大于5")
```

两个分支是最常见的操作，如果符合条件，就执行某个操作，如果不符合，就执行另一个操作。基本语法为：

```r
if(条件){
  操作1
} else {
  操作2
}
```

这种结构由于比较常见，也可以简写为：

```r
# 这种写法使用很频繁
ifelse(条件, 操作1, 操作2)
```

使用第5章开头用的TCGA的乳腺癌数据为例。

TCGA每个样本的barcode是有明确含义的，它的第14位和第15为数字如果小于10，说明这个样本是`tumor`，否则就是`normal`。

我们可以根据此特点，创建一个新的变量用来表示样本类型（tumor还是normal）。

```{r}
# 读取数据
df <- read.csv("datasets/brca_clin.csv", header = T)

# 展示下第一个样本的barcode
df$barcode[1]

# 新建一个变量，用来表示样本类型
group <- ifelse(as.numeric(substr(df$barcode,14,15))<10,"tumor", "normal")
group
```

如果一个表达式函数太多，你看不懂，那你就从最里面一层开始看。比如上面的最后1行代码，我们从最里面的一层开始看：

- `df$barcode`：取`df`的`barcode`这一列
- `substr(df$barcode,14,15)`：截取barcode的第14位和第15位
- `as.numeric(substr(df$barcode,14,15)`：把第14位和第15位转换为数值型，以便和10比较
- `as.numeric(substr(df$barcode,14,15))<10`：判断是不是小于10，返回`TRUE`或者`FALSE`
- `ifelse(xxx, "tumor", "normal")`：根据条件执行操作

多个分支也是常见操作，基本语法如下：

```r
if(条件1) {
  操作1
} else if(条件2) {
  操作2
} else if(条件n) {
  操作n
} else {
  操作x
}
```

中间可以有任意多个条件和操作。

## 自编函数

有时可能并没有合适的、可直接使用的R包能满足我们个性化的需求，这时候就需要自己写函数实现。

在使用代码实现自己的需求前，首先你自己得搞清楚解决这个问题的逻辑，也就是你脑海中要知道，为了解决这个问题，第一步需要做什么？第二步需要做什么？第三步需要做什么？然后再通过代码实现你的这几个步骤。

一个函数的结构如下所示：

```r
myfunction <- function(参数1, 参数2, ... ){
  操作
  return(返回值)
}
```

假设你想编写一个函数，用来计算数据的集中趋势和离散趋势。此函数应当可以选择性地给出参数统计量（均值和标准差）和非参数统计量（中位数和绝对中位差）。结果应当以一个含名称列表的形式给出。另外，用户应当可以选择是否自动输出结果。除非另外指定，否则此函数的默认行为应当是计算参数统计量并且不输出结果。

假如你想编写一个函数，用来计算一个数值型向量的集中趋势（均值和标准差）或者离散趋势（中位数和绝对中位差），默认是计算均值和标准差，但是也可以通过修改参数，让函数计算中位数和绝对中位差。

为了写出这个函数，我们**首先**确定，这个函数需要哪些参数？它的最终返回结果是什么？

对于这个问题来说，第一个参数就是一个数值型向量；除此之外，还需要第2个参数，用来控制到底是计算集中趋势还是计算离散趋势。

函数的输出结果就是两个值，要么是均值和标准差，要么是中位数和绝对中位差。

**然后**是确定具体的执行步骤，对于这个问题也就是计算均值和标准差（或者中位数和绝对中位差），如何实现呢？这个问题当然是通过`if-else`了，如果满足条件就计算集中趋势，不满足就计算离散趋势。

确定好具体的步骤之后，我们就可以开始写这个函数了。

```{r}
mystats <- function(v, center=TRUE){ # 2个参数，第2个参数默认值是TRUE
  if(center == TRUE){          # 满足条件则...
    均值 <- mean(v)
    标准差 <- sd(v)
    res <- c(均值,标准差)
  } else {                     # 不满足条件则...
    中位数 <- median(v)
    绝对中位差 <- mad(v)
    res <- c(中位数, 绝对中位差)
  }
  return(res) # 不写这句也可以
}
```

写好之后，要使用这个函数，你可以直接全选这个函数，然后`Run`一下，就可以在`Environment`面板中看到这个函数了：

![](figs/PixPin_2024-08-01_18-59-16.png)

然后就可以使用了。

随机创建一个数值型向量用于演示：

```{r}
set.seed(1234)
x <- rnorm(500)
```

用编写的函数计算：

```{r}
# center=TRUE 可以不写，不写就是默认TRUE，计算集中趋势
y <- mystats(v = x)
y

# 或者计算离散趋势
y <- mystats(v = x, center = F)
y
```

除了选中运行外，还可以把这个函数保存为一个R脚本文件，要使用前先`source`一下即可。

我们把上面的函数保存为`mystats.R`，然后`source`一下：

```{r}
source("mystats.R") # 注意路径
```

看看`Environment`面板中是不是出现了这个函数？

## 实战1

再来一个实战。for循环和if-else连用。

我们根据年龄将TCGA中的样本分为老年、中年、青年，如果年龄小于40岁，就是“青年”，如果大于等于40且小于60，就是“中年”，否则就是“老年”。

先在脑海中想一下，怎么用计算机语言实现这一过程。

因为有条件（如果xxx就xxx，如果不xxx就zzz），所以肯定要用到`if-else`；然后对于每一个年龄，都要判断是不是满足条件，所以要用到`for`循环。

先定义一个容器，然后准备序列，然后根据条件判断。

```{r}
# 定义一个容器
age_groups <- vector("character", length(df$age_at_index))

for (i in 1:length(df$age_at_index)) {  # 序列
  if(df$age_at_index[i] < 40) {         # 判断条件
    age_groups[i] <- "青年"
  } else if (df$age_at_index[i] >= 40 & df$age_at_index[i] <= 60) {
    age_groups[i] <- "中年"
  } else if (df$age_at_index[i] > 60) {
    age_groups[i] <- "老年"
  }
}

age_groups
```

是不是还算简单，并没有想象中的难。

这个函数还有很多可以改进的地方，当你学习深入后可以尝试一下。

## 实战2

手动整理TCGA下载的转录组数据，把它变成一个标准的表达矩阵（把这个实战放在最后，这里略早）。
