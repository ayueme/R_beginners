---
title: "因子操作"
---

## R语言`forcats`包简介

今日学习处理因子变量的专用包`forcats`，这个包不是`tidyverse`的核心包，需要单独下载安装。

因子变量又被称为分类变量，它和普通的字符型变量不同，它包含一定的顺序，并且可以更改，对于统计建模、数据可视化等都非常重要。

先来一个简单的例子介绍下因子的作用。

假设我们要创建一个月份的变量，并按照月份的顺序进行排序，

```{r, warning = FALSE}
library(tidyverse)
library(forcats)

months <- c("Dec","Apr","Jan","Mar")
```

这时使用`sort`对它进行排序并不能出现我们想要的结果：

```{r}
sort(months)
```

我们可以通过将变量因子化，来解决这个问题：

```{r}
## 首先创建我们想要的顺序，然后让变量遵从这个顺序
month_levels <- c("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec")

months1 <- factor(months, levels = month_levels)
months1
```

这样就能解决排序的问题了，另外还能解决你的拼写错误问题，它会把不在你顺序中的值变成`NA`。

```{r}
x1 <- c("Apr","Mar","Jan","Dee")
factor(x1, levels = month_levels)
```

如果你的向量的顺序就是你想要的顺序，可以使用以下代码：

```{r}
factor(months, levels = unique(months))

months %>% factor() %>% fct_inorder()
```

## `forcats`包所有函数

根据`forcats`包官网介绍，这个包的函数主要分为6类（其实是5类，再加一个数据集）：

### 1. 修改因子向量顺序

保持因子的值不变，但改变它们的顺序。对建模、表和可视化特别有用

- `fct_relevel()`:手动调整顺序
- `fct_inorder()/fct_infreq()/fct_inseq()`:根据第一次出现的顺序、出现的频率多少、数字顺序进行排序
- `fct_reorder()/fct_recorder2()/last2()/first2()`:根据另外一个变量的值调整顺序
- `fct_shuffle()`:随机重新排列
- `fct_rev()`:反转因子水平
- `fct_shift()`:将因子向左或右移动

### 2. 修改因子向量名称

改变因子的值，同时保持原来的顺序(尽可能)

- `fct_anon()`:按照因素水平
- `fct_collapse()`:将因子水平折叠成手动定义的组
- `fct_lump()/fct_lump_min()/fct_lump_prop()/fct_lump_n()/fct_lump_lowfreq()`:将出现次数较少的合并为“其他”
- `fct_other()`:将指定的因子水平设置为“其他”
- `fct_recode()`:手动改变因子的值
- `fct_relabel()`:自动重新标记因子水平，必要时折叠

### 3. 增加/删除因子

- `fct_expand()`:
- `fct_explicit_na()`:使缺失值显式显示
- `fct_drop()`:
- `fct_unify()`:

### 4. 合并多个因子

- `fct_c()`:
- `fct_cross()`:

### 5.其他

- `as_factor()`:
- `fct_count()`:
- `fct_match()`:
- `fct_unique()`:
- `lvls_reorder()/lvls_revalue()/lvls_expand()`:
- `lvls_union()`:

### 6. 一个数据集
- `gss_cat`

接下来会详细介绍每一个函数。

## 修改顺序
### 1.1 `fct_relevel()`

```{r}
## 创建一个因子型向量
f <- factor(c("a", "b", "c", "d"), levels = c("b", "c", "d", "a"))
f
```
```{r}
## 把c,d放在地第1位，第2位
fct_relevel(f, c("c", "d"))
```

```{r}
## 把`a`放在第3的水平
fct_relevel(f, "a", after = 2)
```

```{r}
# 把`a`放到最后的位置
fct_relevel(f, "a", after = Inf)
```
```{r}
## 按照某个函数重新排序
fct_relevel(f, sort)
## 注意这时的顺序是按照`sort(c("a","b","c","d"))`，不是按照`sort(f)`
```
```{r}
## 按照随机顺序
fct_relevel(f, sample)

## 反转顺序
fct_relevel(f, rev)
```

下面是一个看起来很复杂，其实不复杂的例子，使用的是内置数据：`gss_cat`，只选择其中的2列，我们的目标是把每一列中的`Don't know`放到最后。

```{r}
## 先看下原来的因子水平
df  <- forcats::gss_cat[, c("rincome", "denom")]
lapply(df, levels) # 对df的每一列都使用`levels()`函数
```

可以看到每一列都有一个`Don't know`，我们要把它放到最后，顺便学习`lapply`的用法。

```{r}
# 对df的每一列使用`fct_relevel(..., "Don't know", after = Inf)`
df2 <- lapply(df, fct_relevel, "Don't know", after = Inf) 

lapply(df2, levels) # 可以看到"Don't know"都被排在最后了
```

如果当前没有某个值会报错

```{r}
fct_relevel(f, "e")
```

### 1.2 `fct_inorder()/fct_infreq()/fct_inseq()`

这3个是同一家族函数，意思一样，具体用法稍有区别：

- `fct_inorder()`: 按照第一次出现的顺序

- `fct_infreq()`: 按照每个水平出现的频率（从大到小）

- `fct_inseq()`: 按照数字大小

```{r}
f <- factor(c("b", "b", "a", "c", "c", "c"))
f #默认按字母顺序

fct_inorder(f) # 按第一次出现的顺序

fct_infreq(f) # 按出现的频率从大到小排列

f <- factor(1:3, levels = c("3", "2", "1"))
f

fct_inseq(f) # 按照数字顺序排列，虽然你定义的顺序是"3", "2", "1"
```

一个在画图中很有用的例子：

你画了一幅图如下：

```{r}
library(ggplot2)

ggplot(starwars, aes(x = hair_color)) + 
  geom_bar() + 
  coord_flip()
```

但你发现这并不是你想要的，你想按照每一种的个数多少排列好画出来，你可以选择画图前就把顺序排好，或者像这样：

```{r}
ggplot(starwars, aes(x = fct_infreq(hair_color))) +
  geom_bar() +
  coord_flip()
```

完美解决问题！


### 1.3 `fct_reorder()/fct_recorder2()/last2()/first2()`

`fct_reorder()`对于因子映射到位置的一维显示非常有用;`fct_reorder2()`用于2维显示，其中因子被映射到非位置。`last2()`和`first2()`是`fct_reorder2()`的辅助函数;`last2()`在y按照x排序时，查找y的最后一个值;`first2()`查找第一个值。

```{r}
## 生成一个简单的tibble
df <- tibble::tribble(
  ~color,     ~a, ~b,
  "blue",      1,  2,
  "green",     6,  2,
  "purple",    3,  3,
  "red",       2,  3,
  "yellow",    5,  1
)


## 查看color这一列的顺序
df$color <- factor(df$color)
df$color
```

按照a这一列从小到大的顺序，排序color这一列，可以看到color的levels已经变了

```{r}
fct_reorder(df$color, df$a, min)
```

`fct_reorder()`用于画图小例子：

```{r}
boxplot(Sepal.Width ~ Species, data = iris)
boxplot(Sepal.Width ~ fct_reorder(Species, Sepal.Width), data = iris)
boxplot(Sepal.Width ~ fct_reorder(Species, Sepal.Width, .desc = TRUE), data = iris)

```




```{r}
fct_reorder2(df$color, df$a, df$b)
```

`fct_reorder2()`感觉很复杂的样子，但是你只要记住在画图的时候可能会用到它，神奇功能：使图例的顺序和线条的顺序一致。
下面是一个小例子：

```{r}
chks <- subset(ChickWeight, as.integer(Chick) < 10)
chks <- transform(chks, Chick = fct_shuffle(Chick))
chks

ggplot(chks, aes(Time, weight, colour = Chick)) +
  geom_point() +
  geom_line()


# 图例的顺序和线的顺序一样
ggplot(chks, aes(Time, weight, colour = fct_reorder2(Chick, Time, weight))) +
  geom_point() +
  geom_line() +
  labs(colour = "Chick")
```

### 1.4 `fct_shuffle()`

随机重排，完全打乱顺序

```{r}
f <- factor(c("a", "b", "c"))
f
set.seed(111)
fct_shuffle(f) # 每次运行都会出现不同的顺序，除非设置种子数
```

### 1.5 `fct_rev()`

反转顺序

```{r}
f <- factor(c("a", "b", "c"))
f
fct_rev(f)
```

```{r}
# 等价于：
fct_relevel(f,rev)
```



### 1.6 `fct_shift()`

将因子水平左右移动，默认向左移

```{r}
x <- factor(
  c("Mon", "Tue", "Wed"),
  levels = c("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"),
  ordered = TRUE
)
x

fct_shift(x)

fct_shift(x, 2)

fct_shift(x, -1)
```

### 2.1 `fct_anon`

用任意数字标识符替换因子级别。值和级别的顺序都不会被保留

```{r}
gss_cat$relig %>% fct_count()
```

```{r}
gss_cat$relig %>% fct_anon() %>% fct_count()
```

```{r}
gss_cat$relig %>% fct_anon("X") %>% fct_count()
```

### 2.2 `fct_collapse()`

简单的说就是可以给因子分组。

```{r}
fct_count(gss_cat$partyid)
```

一共有10行，也就是10个水平，现在我们可以把10个水平分组，手动定义新的组：

```{r}
partyid2 <- fct_collapse(gss_cat$partyid,
                         missing = c("No answer", "Don't know"),
                         rep = c("Strong republican", "Not str republican"),
                         other = "Other party",
                         ind = c("Ind,near rep", "Independent", "Ind,near dem"),
                         dem = c("Not str democrat", "Strong democrat")
                         )
fct_count(partyid2)
```

### 2.3 `fct_lump()`

这个是一系列函数，可以将满足某些条件的水平合并为一组。如果你经常做机器学习、统计建模等工作，你可能会经常需要把一些占比比较低的组都变成“其他”组。Python中的pandas可以很容易做到，R语言当然也可以。

- `fct_lump_min()`: 把小于某些次数的归为其他类.

- `fct_lump_prop()`: 把小于某个比例的归为其他类.

- `fct_lump_n()`: 把个数最多的n个留下，其他的归为一类（如果n < 0，则个数最少的n个留下）.

- `fct_lump_lowfreq()`: 将最不频繁的级别合并在一起.


```{r}
x <- factor(rep(LETTERS[1:9], times = c(40, 10, 5, 27, 1, 1, 1, 1, 1)))
x %>% fct_count()
```

把个数最多的3个留下，其他归为一类

```{r}
x %>% fct_lump_n(3) %>% table() # ties.method = c("min", "average", "first", "last", "random", "max")

x %>% fct_lump(n = 3) %>% fct_count() # 两种写法等价
```

把个数最少的n个留下，其他归为一类：

```{r}
x %>% fct_lump_n(-3) %>% table()

# 或者：
x %>% fct_lump(n = -7) %>% fct_count()
```

把比例小于0.1的归为一类

```{r}
x %>% fct_lump_prop(0.1) %>% table()

# 或者：
x %>% fct_lump(prop = 0.1) %>% fct_count()
```

把小于2次的归为其他类

```{r}
x %>% fct_lump_min(2, other_level = "其他") %>% table()
```

把频率小的归为其他类，同时确保其他类仍然是频率最小的

```{r}
x %>% fct_lump_lowfreq() %>% table()
```

### 2.4 `fct_other()`

把某些因子归为其他类，类似于 `fct_lump`

```{r}
x <- factor(rep(LETTERS[1:9], times = c(40, 10, 5, 27, 1, 1, 1, 1, 1)))

# 把A,B留下，其他归为一类
fct_other(x, keep = c("A", "B"), other_level = "other")

# 把A,B归为一类，其他留下
fct_other(x, drop = c("A", "B"), other_level = "hhahah")
```

### 2.5 `fct_recode()`

手动更改因子水平

```{r}
x <- factor(c("apple", "bear", "banana", "dear"))
x

fct_recode(x, fruit = "apple", fruit = "banana")
```

```{r}
fct_recode(x, NULL = "apple", fruit = "banana")
```

```{r}
fct_recode(x, "an apple" = "apple", "a bear" = "bear")
```

```{r}
x <- factor(c("apple", "bear", "banana", "dear"))
levels <- c(fruit = "apple", fruit = "banana")
fct_recode(x, !!!levels)
```

### 2.6 `fct_relable()`

```{r}
gss_cat$partyid %>% fct_count()
```

```{r}
gss_cat$partyid %>% fct_relabel(~ gsub(",", ", ", .x)) %>% fct_count()
```


### 3.1 `fct_expand()`

增加因子水平

```{r}
f <- factor(sample(letters[1:3], 20, replace = TRUE))
f

fct_expand(f, "d", "e", "f")
```

### 3.2 `fct_drop()`

删除没用的因子水平

```{r}
f <- factor(c("a", "b"), levels = c("a", "b", "c"))
f

fct_drop(f, "c")
```

### 3.3 `fct_explicit_na()`

给 `NA` 一个水平，确保画图或汇总的时候能用上

```{r}
f1 <- factor(c("a", "a", NA, NA, "a", "b", NA, "c", "a", "c", "b"))
fct_count(f1)
```

```{r}
f2 <- fct_explicit_na(f1, na_level = "missing")
fct_count(f2)
```

### 3.4 `fct_unify()`

这个函数是作用于列表的，用于统一列表内的因子水平

```{r}
fs <- list(factor("a"), 
           factor("b"), 
           factor(c("a", "b")))

fct_unify(fs, levels = c("a", "b", "c"))
```

### 4.1 `fct_c()`

拼接因子向量

```{r}
fa <- factor("a")
fb <- factor("b")
fab <- factor(c("a", "b"))

c(fa, fb, fab)

fct_c(fa, fb, fab)
```

### 4.2 `fct_cross()`

组合因子向量，形成新的因子向量，不是简单的连在一起

```{r}
fruit <- factor(c("apple", "kiwi", "apple", "apple"))
colour <- factor(c("green", "green", "red", "green"))
eaten <- c("yes", "no", "yes", "no")

fct_cross(fruit, colour)

fct_cross(fruit, colour, eaten)
```

### 5.1 `as_factor()`

变成因子向量,和 `as.factor()` 作用一样,但略有不同

```{r}
x <- c("a", "z", "g")
as.factor(x) # 会改变顺序
as_factor(x) # 还是按照原来的顺序
```

### 5.2 `fct_count()`

统计因子个数

```{r}
f <- factor(sample(letters)[rpois(1000, 10)])
table(f)
```

```{r}
fct_count(f, sort = T, prop = T) # 计算个数，按顺序排列，并计算比例
```

### 5.3 `fct_match()`

检查是否存在某个因子

```{r}
table(fct_match(gss_cat$marital, c("Married", "Divorced")))
```

### 5.4 `fct_unique()`

每个水平只保留一个因子

```{r}
f <- factor(letters[rpois(100, 10)])
unique(f)

fct_unique(f)
```

### 5.5 `lvls_reorder()`

```{r}
f <- factor(c("a", "b", "c"))

lvls_reorder(f, 3:1)

lvls_revalue(f, c("apple", "banana", "carrot"))

lvls_expand(f, c("a", "b", "c", "d"))
```

### 5.6 `fct_union()`

作用于列表

```{r}
fs <- list(factor("a"), factor("b"), factor(c("a", "b")))
lvls_union(fs)
```

